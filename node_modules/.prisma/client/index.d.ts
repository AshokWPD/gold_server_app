
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Read
 * 
 */
export type Read = $Result.DefaultSelection<Prisma.$ReadPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model RiskAssessment
 * 
 */
export type RiskAssessment = $Result.DefaultSelection<Prisma.$RiskAssessmentPayload>
/**
 * Model OtherFile
 * 
 */
export type OtherFile = $Result.DefaultSelection<Prisma.$OtherFilePayload>
/**
 * Model UserOrientation
 * 
 */
export type UserOrientation = $Result.DefaultSelection<Prisma.$UserOrientationPayload>
/**
 * Model UserOrientationRead
 * 
 */
export type UserOrientationRead = $Result.DefaultSelection<Prisma.$UserOrientationReadPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model FeedbackAssignment
 * 
 */
export type FeedbackAssignment = $Result.DefaultSelection<Prisma.$FeedbackAssignmentPayload>
/**
 * Model FeedbackFile
 * 
 */
export type FeedbackFile = $Result.DefaultSelection<Prisma.$FeedbackFilePayload>
/**
 * Model FeedbackActionFile
 * 
 */
export type FeedbackActionFile = $Result.DefaultSelection<Prisma.$FeedbackActionFilePayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model MembersList
 * 
 */
export type MembersList = $Result.DefaultSelection<Prisma.$MembersListPayload>
/**
 * Model MembersAttended
 * 
 */
export type MembersAttended = $Result.DefaultSelection<Prisma.$MembersAttendedPayload>
/**
 * Model DigitalSignatureFile
 * 
 */
export type DigitalSignatureFile = $Result.DefaultSelection<Prisma.$DigitalSignatureFilePayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  user: 'user',
  subAdmin: 'subAdmin',
  userAndSubAdmin: 'userAndSubAdmin',
  admin: 'admin'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const AdminApproved: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type AdminApproved = (typeof AdminApproved)[keyof typeof AdminApproved]


export const FeedbackColor: {
  red: 'red',
  yellow: 'yellow',
  green: 'green'
};

export type FeedbackColor = (typeof FeedbackColor)[keyof typeof FeedbackColor]


export const Status: {
  inProgress: 'inProgress',
  rejected: 'rejected',
  closed: 'closed',
  closedWithoutAction: 'closedWithoutAction'
};

export type Status = (typeof Status)[keyof typeof Status]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type AdminApproved = $Enums.AdminApproved

export const AdminApproved: typeof $Enums.AdminApproved

export type FeedbackColor = $Enums.FeedbackColor

export const FeedbackColor: typeof $Enums.FeedbackColor

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.read`: Exposes CRUD operations for the **Read** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reads
    * const reads = await prisma.read.findMany()
    * ```
    */
  get read(): Prisma.ReadDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs>;

  /**
   * `prisma.riskAssessment`: Exposes CRUD operations for the **RiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAssessments
    * const riskAssessments = await prisma.riskAssessment.findMany()
    * ```
    */
  get riskAssessment(): Prisma.RiskAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.otherFile`: Exposes CRUD operations for the **OtherFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtherFiles
    * const otherFiles = await prisma.otherFile.findMany()
    * ```
    */
  get otherFile(): Prisma.OtherFileDelegate<ExtArgs>;

  /**
   * `prisma.userOrientation`: Exposes CRUD operations for the **UserOrientation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOrientations
    * const userOrientations = await prisma.userOrientation.findMany()
    * ```
    */
  get userOrientation(): Prisma.UserOrientationDelegate<ExtArgs>;

  /**
   * `prisma.userOrientationRead`: Exposes CRUD operations for the **UserOrientationRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOrientationReads
    * const userOrientationReads = await prisma.userOrientationRead.findMany()
    * ```
    */
  get userOrientationRead(): Prisma.UserOrientationReadDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.feedbackAssignment`: Exposes CRUD operations for the **FeedbackAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackAssignments
    * const feedbackAssignments = await prisma.feedbackAssignment.findMany()
    * ```
    */
  get feedbackAssignment(): Prisma.FeedbackAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.feedbackFile`: Exposes CRUD operations for the **FeedbackFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackFiles
    * const feedbackFiles = await prisma.feedbackFile.findMany()
    * ```
    */
  get feedbackFile(): Prisma.FeedbackFileDelegate<ExtArgs>;

  /**
   * `prisma.feedbackActionFile`: Exposes CRUD operations for the **FeedbackActionFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackActionFiles
    * const feedbackActionFiles = await prisma.feedbackActionFile.findMany()
    * ```
    */
  get feedbackActionFile(): Prisma.FeedbackActionFileDelegate<ExtArgs>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs>;

  /**
   * `prisma.membersList`: Exposes CRUD operations for the **MembersList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembersLists
    * const membersLists = await prisma.membersList.findMany()
    * ```
    */
  get membersList(): Prisma.MembersListDelegate<ExtArgs>;

  /**
   * `prisma.membersAttended`: Exposes CRUD operations for the **MembersAttended** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembersAttendeds
    * const membersAttendeds = await prisma.membersAttended.findMany()
    * ```
    */
  get membersAttended(): Prisma.MembersAttendedDelegate<ExtArgs>;

  /**
   * `prisma.digitalSignatureFile`: Exposes CRUD operations for the **DigitalSignatureFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DigitalSignatureFiles
    * const digitalSignatureFiles = await prisma.digitalSignatureFile.findMany()
    * ```
    */
  get digitalSignatureFile(): Prisma.DigitalSignatureFileDelegate<ExtArgs>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Group: 'Group',
    Member: 'Member',
    Message: 'Message',
    Read: 'Read',
    File: 'File',
    RiskAssessment: 'RiskAssessment',
    OtherFile: 'OtherFile',
    UserOrientation: 'UserOrientation',
    UserOrientationRead: 'UserOrientationRead',
    Feedback: 'Feedback',
    FeedbackAssignment: 'FeedbackAssignment',
    FeedbackFile: 'FeedbackFile',
    FeedbackActionFile: 'FeedbackActionFile',
    Meeting: 'Meeting',
    MembersList: 'MembersList',
    MembersAttended: 'MembersAttended',
    DigitalSignatureFile: 'DigitalSignatureFile',
    Form: 'Form'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'group' | 'member' | 'message' | 'read' | 'file' | 'riskAssessment' | 'otherFile' | 'userOrientation' | 'userOrientationRead' | 'feedback' | 'feedbackAssignment' | 'feedbackFile' | 'feedbackActionFile' | 'meeting' | 'membersList' | 'membersAttended' | 'digitalSignatureFile' | 'form'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Read: {
        payload: Prisma.$ReadPayload<ExtArgs>
        fields: Prisma.ReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>
          }
          findFirst: {
            args: Prisma.ReadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>
          }
          findMany: {
            args: Prisma.ReadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>[]
          }
          create: {
            args: Prisma.ReadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>
          }
          createMany: {
            args: Prisma.ReadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>
          }
          update: {
            args: Prisma.ReadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>
          }
          deleteMany: {
            args: Prisma.ReadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReadPayload>
          }
          aggregate: {
            args: Prisma.ReadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRead>
          }
          groupBy: {
            args: Prisma.ReadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReadCountArgs<ExtArgs>,
            result: $Utils.Optional<ReadCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>,
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      RiskAssessment: {
        payload: Prisma.$RiskAssessmentPayload<ExtArgs>
        fields: Prisma.RiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAssessmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.RiskAssessmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAssessmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.RiskAssessmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.RiskAssessmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.RiskAssessmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RiskAssessmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          update: {
            args: Prisma.RiskAssessmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.RiskAssessmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAssessmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RiskAssessmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.RiskAssessmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRiskAssessment>
          }
          groupBy: {
            args: Prisma.RiskAssessmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAssessmentCountArgs<ExtArgs>,
            result: $Utils.Optional<RiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
      OtherFile: {
        payload: Prisma.$OtherFilePayload<ExtArgs>
        fields: Prisma.OtherFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtherFileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtherFileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>
          }
          findFirst: {
            args: Prisma.OtherFileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtherFileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>
          }
          findMany: {
            args: Prisma.OtherFileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>[]
          }
          create: {
            args: Prisma.OtherFileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>
          }
          createMany: {
            args: Prisma.OtherFileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OtherFileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>
          }
          update: {
            args: Prisma.OtherFileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>
          }
          deleteMany: {
            args: Prisma.OtherFileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OtherFileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OtherFileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OtherFilePayload>
          }
          aggregate: {
            args: Prisma.OtherFileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOtherFile>
          }
          groupBy: {
            args: Prisma.OtherFileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OtherFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtherFileCountArgs<ExtArgs>,
            result: $Utils.Optional<OtherFileCountAggregateOutputType> | number
          }
        }
      }
      UserOrientation: {
        payload: Prisma.$UserOrientationPayload<ExtArgs>
        fields: Prisma.UserOrientationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOrientationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOrientationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>
          }
          findFirst: {
            args: Prisma.UserOrientationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOrientationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>
          }
          findMany: {
            args: Prisma.UserOrientationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>[]
          }
          create: {
            args: Prisma.UserOrientationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>
          }
          createMany: {
            args: Prisma.UserOrientationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserOrientationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>
          }
          update: {
            args: Prisma.UserOrientationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>
          }
          deleteMany: {
            args: Prisma.UserOrientationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserOrientationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserOrientationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationPayload>
          }
          aggregate: {
            args: Prisma.UserOrientationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserOrientation>
          }
          groupBy: {
            args: Prisma.UserOrientationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserOrientationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOrientationCountArgs<ExtArgs>,
            result: $Utils.Optional<UserOrientationCountAggregateOutputType> | number
          }
        }
      }
      UserOrientationRead: {
        payload: Prisma.$UserOrientationReadPayload<ExtArgs>
        fields: Prisma.UserOrientationReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOrientationReadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOrientationReadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>
          }
          findFirst: {
            args: Prisma.UserOrientationReadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOrientationReadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>
          }
          findMany: {
            args: Prisma.UserOrientationReadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>[]
          }
          create: {
            args: Prisma.UserOrientationReadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>
          }
          createMany: {
            args: Prisma.UserOrientationReadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserOrientationReadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>
          }
          update: {
            args: Prisma.UserOrientationReadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>
          }
          deleteMany: {
            args: Prisma.UserOrientationReadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserOrientationReadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserOrientationReadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOrientationReadPayload>
          }
          aggregate: {
            args: Prisma.UserOrientationReadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserOrientationRead>
          }
          groupBy: {
            args: Prisma.UserOrientationReadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserOrientationReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOrientationReadCountArgs<ExtArgs>,
            result: $Utils.Optional<UserOrientationReadCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      FeedbackAssignment: {
        payload: Prisma.$FeedbackAssignmentPayload<ExtArgs>
        fields: Prisma.FeedbackAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackAssignmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackAssignmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>
          }
          findFirst: {
            args: Prisma.FeedbackAssignmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackAssignmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>
          }
          findMany: {
            args: Prisma.FeedbackAssignmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>[]
          }
          create: {
            args: Prisma.FeedbackAssignmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>
          }
          createMany: {
            args: Prisma.FeedbackAssignmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackAssignmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>
          }
          update: {
            args: Prisma.FeedbackAssignmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackAssignmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackAssignmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackAssignmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackAssignmentPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAssignmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedbackAssignment>
          }
          groupBy: {
            args: Prisma.FeedbackAssignmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackAssignmentCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackAssignmentCountAggregateOutputType> | number
          }
        }
      }
      FeedbackFile: {
        payload: Prisma.$FeedbackFilePayload<ExtArgs>
        fields: Prisma.FeedbackFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>
          }
          findFirst: {
            args: Prisma.FeedbackFileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>
          }
          findMany: {
            args: Prisma.FeedbackFileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>[]
          }
          create: {
            args: Prisma.FeedbackFileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>
          }
          createMany: {
            args: Prisma.FeedbackFileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackFileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>
          }
          update: {
            args: Prisma.FeedbackFileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>
          }
          deleteMany: {
            args: Prisma.FeedbackFileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackFileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackFileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackFilePayload>
          }
          aggregate: {
            args: Prisma.FeedbackFileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedbackFile>
          }
          groupBy: {
            args: Prisma.FeedbackFileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackFileCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackFileCountAggregateOutputType> | number
          }
        }
      }
      FeedbackActionFile: {
        payload: Prisma.$FeedbackActionFilePayload<ExtArgs>
        fields: Prisma.FeedbackActionFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackActionFileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackActionFileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>
          }
          findFirst: {
            args: Prisma.FeedbackActionFileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackActionFileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>
          }
          findMany: {
            args: Prisma.FeedbackActionFileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>[]
          }
          create: {
            args: Prisma.FeedbackActionFileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>
          }
          createMany: {
            args: Prisma.FeedbackActionFileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackActionFileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>
          }
          update: {
            args: Prisma.FeedbackActionFileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>
          }
          deleteMany: {
            args: Prisma.FeedbackActionFileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackActionFileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackActionFileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackActionFilePayload>
          }
          aggregate: {
            args: Prisma.FeedbackActionFileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedbackActionFile>
          }
          groupBy: {
            args: Prisma.FeedbackActionFileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackActionFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackActionFileCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackActionFileCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>,
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      MembersList: {
        payload: Prisma.$MembersListPayload<ExtArgs>
        fields: Prisma.MembersListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembersListFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembersListFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>
          }
          findFirst: {
            args: Prisma.MembersListFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembersListFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>
          }
          findMany: {
            args: Prisma.MembersListFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>[]
          }
          create: {
            args: Prisma.MembersListCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>
          }
          createMany: {
            args: Prisma.MembersListCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MembersListDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>
          }
          update: {
            args: Prisma.MembersListUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>
          }
          deleteMany: {
            args: Prisma.MembersListDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MembersListUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MembersListUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersListPayload>
          }
          aggregate: {
            args: Prisma.MembersListAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMembersList>
          }
          groupBy: {
            args: Prisma.MembersListGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MembersListGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembersListCountArgs<ExtArgs>,
            result: $Utils.Optional<MembersListCountAggregateOutputType> | number
          }
        }
      }
      MembersAttended: {
        payload: Prisma.$MembersAttendedPayload<ExtArgs>
        fields: Prisma.MembersAttendedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembersAttendedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembersAttendedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>
          }
          findFirst: {
            args: Prisma.MembersAttendedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembersAttendedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>
          }
          findMany: {
            args: Prisma.MembersAttendedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>[]
          }
          create: {
            args: Prisma.MembersAttendedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>
          }
          createMany: {
            args: Prisma.MembersAttendedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MembersAttendedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>
          }
          update: {
            args: Prisma.MembersAttendedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>
          }
          deleteMany: {
            args: Prisma.MembersAttendedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MembersAttendedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MembersAttendedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MembersAttendedPayload>
          }
          aggregate: {
            args: Prisma.MembersAttendedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMembersAttended>
          }
          groupBy: {
            args: Prisma.MembersAttendedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MembersAttendedGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembersAttendedCountArgs<ExtArgs>,
            result: $Utils.Optional<MembersAttendedCountAggregateOutputType> | number
          }
        }
      }
      DigitalSignatureFile: {
        payload: Prisma.$DigitalSignatureFilePayload<ExtArgs>
        fields: Prisma.DigitalSignatureFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DigitalSignatureFileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DigitalSignatureFileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>
          }
          findFirst: {
            args: Prisma.DigitalSignatureFileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DigitalSignatureFileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>
          }
          findMany: {
            args: Prisma.DigitalSignatureFileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>[]
          }
          create: {
            args: Prisma.DigitalSignatureFileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>
          }
          createMany: {
            args: Prisma.DigitalSignatureFileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DigitalSignatureFileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>
          }
          update: {
            args: Prisma.DigitalSignatureFileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>
          }
          deleteMany: {
            args: Prisma.DigitalSignatureFileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DigitalSignatureFileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DigitalSignatureFileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DigitalSignatureFilePayload>
          }
          aggregate: {
            args: Prisma.DigitalSignatureFileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDigitalSignatureFile>
          }
          groupBy: {
            args: Prisma.DigitalSignatureFileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DigitalSignatureFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.DigitalSignatureFileCountArgs<ExtArgs>,
            result: $Utils.Optional<DigitalSignatureFileCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>,
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    memberInGroups: number
    messages: number
    reads: number
    feedbacks: number
    feedbackAssignments: number
    userOrientationReads: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberInGroups?: boolean | UserCountOutputTypeCountMemberInGroupsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    reads?: boolean | UserCountOutputTypeCountReadsArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    feedbackAssignments?: boolean | UserCountOutputTypeCountFeedbackAssignmentsArgs
    userOrientationReads?: boolean | UserCountOutputTypeCountUserOrientationReadsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemberInGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackAssignmentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserOrientationReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrientationReadWhereInput
  }



  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    assessments: number
    messages: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    assessments?: boolean | GroupCountOutputTypeCountAssessmentsArgs
    messages?: boolean | GroupCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
  }


  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }



  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    read: number
    files: number
    groups: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    read?: boolean | MessageCountOutputTypeCountReadArgs
    files?: boolean | MessageCountOutputTypeCountFilesArgs
    groups?: boolean | MessageCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadWhereInput
  }


  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }



  /**
   * Count Type UserOrientationCountOutputType
   */

  export type UserOrientationCountOutputType = {
    userOrientationReads: number
  }

  export type UserOrientationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userOrientationReads?: boolean | UserOrientationCountOutputTypeCountUserOrientationReadsArgs
  }

  // Custom InputTypes

  /**
   * UserOrientationCountOutputType without action
   */
  export type UserOrientationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationCountOutputType
     */
    select?: UserOrientationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserOrientationCountOutputType without action
   */
  export type UserOrientationCountOutputTypeCountUserOrientationReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrientationReadWhereInput
  }



  /**
   * Count Type FeedbackCountOutputType
   */

  export type FeedbackCountOutputType = {
    files: number
    actionFiles: number
    feedbackAssignments: number
  }

  export type FeedbackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | FeedbackCountOutputTypeCountFilesArgs
    actionFiles?: boolean | FeedbackCountOutputTypeCountActionFilesArgs
    feedbackAssignments?: boolean | FeedbackCountOutputTypeCountFeedbackAssignmentsArgs
  }

  // Custom InputTypes

  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackCountOutputType
     */
    select?: FeedbackCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFileWhereInput
  }


  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeCountActionFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackActionFileWhereInput
  }


  /**
   * FeedbackCountOutputType without action
   */
  export type FeedbackCountOutputTypeCountFeedbackAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackAssignmentWhereInput
  }



  /**
   * Count Type MeetingCountOutputType
   */

  export type MeetingCountOutputType = {
    membersList: number
    membersAttended: number
  }

  export type MeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membersList?: boolean | MeetingCountOutputTypeCountMembersListArgs
    membersAttended?: boolean | MeetingCountOutputTypeCountMembersAttendedArgs
  }

  // Custom InputTypes

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingCountOutputType
     */
    select?: MeetingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountMembersListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersListWhereInput
  }


  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountMembersAttendedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersAttendedWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    avatar: string | null
    name: string | null
    email: string | null
    phone: string | null
    department: string | null
    employeeNumber: string | null
    password: string | null
    fcmToken: string | null
    type: $Enums.UserType | null
    adminApproved: $Enums.AdminApproved | null
    resetPasswordToken: string | null
    resetPasswordExpire: Date | null
    active: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    avatar: string | null
    name: string | null
    email: string | null
    phone: string | null
    department: string | null
    employeeNumber: string | null
    password: string | null
    fcmToken: string | null
    type: $Enums.UserType | null
    adminApproved: $Enums.AdminApproved | null
    resetPasswordToken: string | null
    resetPasswordExpire: Date | null
    active: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    avatar: number
    name: number
    email: number
    phone: number
    department: number
    employeeNumber: number
    password: number
    fcmToken: number
    type: number
    adminApproved: number
    resetPasswordToken: number
    resetPasswordExpire: number
    active: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    avatar?: true
    name?: true
    email?: true
    phone?: true
    department?: true
    employeeNumber?: true
    password?: true
    fcmToken?: true
    type?: true
    adminApproved?: true
    resetPasswordToken?: true
    resetPasswordExpire?: true
    active?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    avatar?: true
    name?: true
    email?: true
    phone?: true
    department?: true
    employeeNumber?: true
    password?: true
    fcmToken?: true
    type?: true
    adminApproved?: true
    resetPasswordToken?: true
    resetPasswordExpire?: true
    active?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    avatar?: true
    name?: true
    email?: true
    phone?: true
    department?: true
    employeeNumber?: true
    password?: true
    fcmToken?: true
    type?: true
    adminApproved?: true
    resetPasswordToken?: true
    resetPasswordExpire?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    avatar: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber: string
    password: string
    fcmToken: string | null
    type: $Enums.UserType
    adminApproved: $Enums.AdminApproved
    resetPasswordToken: string | null
    resetPasswordExpire: Date | null
    active: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatar?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    department?: boolean
    employeeNumber?: boolean
    password?: boolean
    fcmToken?: boolean
    type?: boolean
    adminApproved?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpire?: boolean
    active?: boolean
    createdAt?: boolean
    memberInGroups?: boolean | User$memberInGroupsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    reads?: boolean | User$readsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    feedbackAssignments?: boolean | User$feedbackAssignmentsArgs<ExtArgs>
    userOrientationReads?: boolean | User$userOrientationReadsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    avatar?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    department?: boolean
    employeeNumber?: boolean
    password?: boolean
    fcmToken?: boolean
    type?: boolean
    adminApproved?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpire?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberInGroups?: boolean | User$memberInGroupsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    reads?: boolean | User$readsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    feedbackAssignments?: boolean | User$feedbackAssignmentsArgs<ExtArgs>
    userOrientationReads?: boolean | User$userOrientationReadsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      memberInGroups: Prisma.$MemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      reads: Prisma.$ReadPayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      feedbackAssignments: Prisma.$FeedbackAssignmentPayload<ExtArgs>[]
      userOrientationReads: Prisma.$UserOrientationReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      avatar: string | null
      name: string
      email: string
      phone: string
      department: string
      employeeNumber: string
      password: string
      fcmToken: string | null
      type: $Enums.UserType
      adminApproved: $Enums.AdminApproved
      resetPasswordToken: string | null
      resetPasswordExpire: Date | null
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    memberInGroups<T extends User$memberInGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$memberInGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    reads<T extends User$readsArgs<ExtArgs> = {}>(args?: Subset<T, User$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedbackAssignments<T extends User$feedbackAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    userOrientationReads<T extends User$userOrientationReadsArgs<ExtArgs> = {}>(args?: Subset<T, User$userOrientationReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly employeeNumber: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly fcmToken: FieldRef<"User", 'String'>
    readonly type: FieldRef<"User", 'UserType'>
    readonly adminApproved: FieldRef<"User", 'AdminApproved'>
    readonly resetPasswordToken: FieldRef<"User", 'String'>
    readonly resetPasswordExpire: FieldRef<"User", 'DateTime'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.memberInGroups
   */
  export type User$memberInGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * User.reads
   */
  export type User$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    where?: ReadWhereInput
    orderBy?: ReadOrderByWithRelationInput | ReadOrderByWithRelationInput[]
    cursor?: ReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadScalarFieldEnum | ReadScalarFieldEnum[]
  }


  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * User.feedbackAssignments
   */
  export type User$feedbackAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    where?: FeedbackAssignmentWhereInput
    orderBy?: FeedbackAssignmentOrderByWithRelationInput | FeedbackAssignmentOrderByWithRelationInput[]
    cursor?: FeedbackAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackAssignmentScalarFieldEnum | FeedbackAssignmentScalarFieldEnum[]
  }


  /**
   * User.userOrientationReads
   */
  export type User$userOrientationReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    where?: UserOrientationReadWhereInput
    orderBy?: UserOrientationReadOrderByWithRelationInput | UserOrientationReadOrderByWithRelationInput[]
    cursor?: UserOrientationReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOrientationReadScalarFieldEnum | UserOrientationReadScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    avatar: string | null
    name: string | null
    createdAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    avatar: string | null
    name: string | null
    createdAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    avatar: number
    name: number
    createdAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    avatar?: true
    name?: true
    createdAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    avatar?: true
    name?: true
    createdAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    avatar?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    avatar: string | null
    name: string
    createdAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatar?: boolean
    name?: boolean
    createdAt?: boolean
    members?: boolean | Group$membersArgs<ExtArgs>
    assessments?: boolean | Group$assessmentsArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    avatar?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Group$membersArgs<ExtArgs>
    assessments?: boolean | Group$assessmentsArgs<ExtArgs>
    messages?: boolean | Group$messagesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      assessments: Prisma.$RiskAssessmentPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      avatar: string | null
      name: string
      createdAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }


  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
    **/
    create<T extends GroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupCreateArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groups.
     *     @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const group = await prisma.group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
    **/
    delete<T extends GroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
    **/
    upsert<T extends GroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    assessments<T extends Group$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, Group$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    messages<T extends Group$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Group$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly avatar: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }


  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }


  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }


  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }


  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Group.assessments
   */
  export type Group$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    cursor?: RiskAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }


  /**
   * Group.messages
   */
  export type Group$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
  }



  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type MemberSumAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type MemberMinAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type MemberMaxAggregateOutputType = {
    groupId: number | null
    userId: number | null
  }

  export type MemberCountAggregateOutputType = {
    groupId: number
    userId: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type MemberSumAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type MemberMinAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type MemberMaxAggregateInputType = {
    groupId?: true
    userId?: true
  }

  export type MemberCountAggregateInputType = {
    groupId?: true
    userId?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    groupId: number
    userId: number
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    userId?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    groupId?: boolean
    userId?: boolean
  }

  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groupId: number
      userId: number
    }, ExtArgs["result"]["member"]>
    composites: {}
  }


  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Member that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const memberWithGroupIdOnly = await prisma.member.findMany({ select: { groupId: true } })
     * 
    **/
    findMany<T extends MemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
    **/
    create<T extends MemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCreateArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Members.
     *     @param {MemberCreateManyArgs} args - Arguments to create many Members.
     *     @example
     *     // Create many Members
     *     const member = await prisma.member.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
    **/
    delete<T extends MemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
    **/
    upsert<T extends MemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Member model
   */ 
  interface MemberFieldRefs {
    readonly groupId: FieldRef<"Member", 'Int'>
    readonly userId: FieldRef<"Member", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }


  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }


  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }


  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }


  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    timer: number | null
    createdById: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    timer: number | null
    createdById: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    timer: number | null
    createdById: number | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    timer: number | null
    createdById: number | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    title: number
    content: number
    timer: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    timer?: true
    createdById?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    timer?: true
    createdById?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    timer?: true
    createdById?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    timer?: true
    createdById?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    timer?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    title: string
    content: string
    timer: number
    createdById: number
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    timer?: boolean
    createdById?: boolean
    createdAt?: boolean
    read?: boolean | Message$readArgs<ExtArgs>
    files?: boolean | Message$filesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    groups?: boolean | Message$groupsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    timer?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    read?: boolean | Message$readArgs<ExtArgs>
    files?: boolean | Message$filesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    groups?: boolean | Message$groupsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      read: Prisma.$ReadPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      groups: Prisma.$GroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      timer: number
      createdById: number
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    read<T extends Message$readArgs<ExtArgs> = {}>(args?: Subset<T, Message$readArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findMany'> | Null>;

    files<T extends Message$filesArgs<ExtArgs> = {}>(args?: Subset<T, Message$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findMany'> | Null>;

    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    groups<T extends Message$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Message$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly title: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly timer: FieldRef<"Message", 'Int'>
    readonly createdById: FieldRef<"Message", 'Int'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message.read
   */
  export type Message$readArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    where?: ReadWhereInput
    orderBy?: ReadOrderByWithRelationInput | ReadOrderByWithRelationInput[]
    cursor?: ReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadScalarFieldEnum | ReadScalarFieldEnum[]
  }


  /**
   * Message.files
   */
  export type Message$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * Message.groups
   */
  export type Message$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Model Read
   */

  export type AggregateRead = {
    _count: ReadCountAggregateOutputType | null
    _avg: ReadAvgAggregateOutputType | null
    _sum: ReadSumAggregateOutputType | null
    _min: ReadMinAggregateOutputType | null
    _max: ReadMaxAggregateOutputType | null
  }

  export type ReadAvgAggregateOutputType = {
    id: number | null
    messageId: number | null
    groupId: number | null
    userId: number | null
  }

  export type ReadSumAggregateOutputType = {
    id: number | null
    messageId: number | null
    groupId: number | null
    userId: number | null
  }

  export type ReadMinAggregateOutputType = {
    id: number | null
    messageId: number | null
    groupId: number | null
    userId: number | null
    reply: string | null
    mode: string | null
    readAt: Date | null
  }

  export type ReadMaxAggregateOutputType = {
    id: number | null
    messageId: number | null
    groupId: number | null
    userId: number | null
    reply: string | null
    mode: string | null
    readAt: Date | null
  }

  export type ReadCountAggregateOutputType = {
    id: number
    messageId: number
    groupId: number
    userId: number
    reply: number
    mode: number
    readAt: number
    _all: number
  }


  export type ReadAvgAggregateInputType = {
    id?: true
    messageId?: true
    groupId?: true
    userId?: true
  }

  export type ReadSumAggregateInputType = {
    id?: true
    messageId?: true
    groupId?: true
    userId?: true
  }

  export type ReadMinAggregateInputType = {
    id?: true
    messageId?: true
    groupId?: true
    userId?: true
    reply?: true
    mode?: true
    readAt?: true
  }

  export type ReadMaxAggregateInputType = {
    id?: true
    messageId?: true
    groupId?: true
    userId?: true
    reply?: true
    mode?: true
    readAt?: true
  }

  export type ReadCountAggregateInputType = {
    id?: true
    messageId?: true
    groupId?: true
    userId?: true
    reply?: true
    mode?: true
    readAt?: true
    _all?: true
  }

  export type ReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Read to aggregate.
     */
    where?: ReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reads to fetch.
     */
    orderBy?: ReadOrderByWithRelationInput | ReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reads
    **/
    _count?: true | ReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReadMaxAggregateInputType
  }

  export type GetReadAggregateType<T extends ReadAggregateArgs> = {
        [P in keyof T & keyof AggregateRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRead[P]>
      : GetScalarType<T[P], AggregateRead[P]>
  }




  export type ReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadWhereInput
    orderBy?: ReadOrderByWithAggregationInput | ReadOrderByWithAggregationInput[]
    by: ReadScalarFieldEnum[] | ReadScalarFieldEnum
    having?: ReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReadCountAggregateInputType | true
    _avg?: ReadAvgAggregateInputType
    _sum?: ReadSumAggregateInputType
    _min?: ReadMinAggregateInputType
    _max?: ReadMaxAggregateInputType
  }

  export type ReadGroupByOutputType = {
    id: number
    messageId: number
    groupId: number
    userId: number
    reply: string | null
    mode: string | null
    readAt: Date
    _count: ReadCountAggregateOutputType | null
    _avg: ReadAvgAggregateOutputType | null
    _sum: ReadSumAggregateOutputType | null
    _min: ReadMinAggregateOutputType | null
    _max: ReadMaxAggregateOutputType | null
  }

  type GetReadGroupByPayload<T extends ReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReadGroupByOutputType[P]>
            : GetScalarType<T[P], ReadGroupByOutputType[P]>
        }
      >
    >


  export type ReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    groupId?: boolean
    userId?: boolean
    reply?: boolean
    mode?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["read"]>

  export type ReadSelectScalar = {
    id?: boolean
    messageId?: boolean
    groupId?: boolean
    userId?: boolean
    reply?: boolean
    mode?: boolean
    readAt?: boolean
  }

  export type ReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Read"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      messageId: number
      groupId: number
      userId: number
      reply: string | null
      mode: string | null
      readAt: Date
    }, ExtArgs["result"]["read"]>
    composites: {}
  }


  type ReadGetPayload<S extends boolean | null | undefined | ReadDefaultArgs> = $Result.GetResult<Prisma.$ReadPayload, S>

  type ReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ReadCountAggregateInputType | true
    }

  export interface ReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Read'], meta: { name: 'Read' } }
    /**
     * Find zero or one Read that matches the filter.
     * @param {ReadFindUniqueArgs} args - Arguments to find a Read
     * @example
     * // Get one Read
     * const read = await prisma.read.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReadFindUniqueArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Read that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReadFindUniqueOrThrowArgs} args - Arguments to find a Read
     * @example
     * // Get one Read
     * const read = await prisma.read.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Read that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadFindFirstArgs} args - Arguments to find a Read
     * @example
     * // Get one Read
     * const read = await prisma.read.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReadFindFirstArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Read that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadFindFirstOrThrowArgs} args - Arguments to find a Read
     * @example
     * // Get one Read
     * const read = await prisma.read.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reads
     * const reads = await prisma.read.findMany()
     * 
     * // Get first 10 Reads
     * const reads = await prisma.read.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const readWithIdOnly = await prisma.read.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Read.
     * @param {ReadCreateArgs} args - Arguments to create a Read.
     * @example
     * // Create one Read
     * const Read = await prisma.read.create({
     *   data: {
     *     // ... data to create a Read
     *   }
     * })
     * 
    **/
    create<T extends ReadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReadCreateArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reads.
     *     @param {ReadCreateManyArgs} args - Arguments to create many Reads.
     *     @example
     *     // Create many Reads
     *     const read = await prisma.read.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Read.
     * @param {ReadDeleteArgs} args - Arguments to delete one Read.
     * @example
     * // Delete one Read
     * const Read = await prisma.read.delete({
     *   where: {
     *     // ... filter to delete one Read
     *   }
     * })
     * 
    **/
    delete<T extends ReadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReadDeleteArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Read.
     * @param {ReadUpdateArgs} args - Arguments to update one Read.
     * @example
     * // Update one Read
     * const read = await prisma.read.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReadUpdateArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reads.
     * @param {ReadDeleteManyArgs} args - Arguments to filter Reads to delete.
     * @example
     * // Delete a few Reads
     * const { count } = await prisma.read.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reads
     * const read = await prisma.read.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Read.
     * @param {ReadUpsertArgs} args - Arguments to update or create a Read.
     * @example
     * // Update or create a Read
     * const read = await prisma.read.upsert({
     *   create: {
     *     // ... data to create a Read
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Read we want to update
     *   }
     * })
    **/
    upsert<T extends ReadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReadUpsertArgs<ExtArgs>>
    ): Prisma__ReadClient<$Result.GetResult<Prisma.$ReadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadCountArgs} args - Arguments to filter Reads to count.
     * @example
     * // Count the number of Reads
     * const count = await prisma.read.count({
     *   where: {
     *     // ... the filter for the Reads we want to count
     *   }
     * })
    **/
    count<T extends ReadCountArgs>(
      args?: Subset<T, ReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Read.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReadAggregateArgs>(args: Subset<T, ReadAggregateArgs>): Prisma.PrismaPromise<GetReadAggregateType<T>>

    /**
     * Group by Read.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReadGroupByArgs['orderBy'] }
        : { orderBy?: ReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Read model
   */
  readonly fields: ReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Read.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Read model
   */ 
  interface ReadFieldRefs {
    readonly id: FieldRef<"Read", 'Int'>
    readonly messageId: FieldRef<"Read", 'Int'>
    readonly groupId: FieldRef<"Read", 'Int'>
    readonly userId: FieldRef<"Read", 'Int'>
    readonly reply: FieldRef<"Read", 'String'>
    readonly mode: FieldRef<"Read", 'String'>
    readonly readAt: FieldRef<"Read", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Read findUnique
   */
  export type ReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * Filter, which Read to fetch.
     */
    where: ReadWhereUniqueInput
  }


  /**
   * Read findUniqueOrThrow
   */
  export type ReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * Filter, which Read to fetch.
     */
    where: ReadWhereUniqueInput
  }


  /**
   * Read findFirst
   */
  export type ReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * Filter, which Read to fetch.
     */
    where?: ReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reads to fetch.
     */
    orderBy?: ReadOrderByWithRelationInput | ReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reads.
     */
    cursor?: ReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reads.
     */
    distinct?: ReadScalarFieldEnum | ReadScalarFieldEnum[]
  }


  /**
   * Read findFirstOrThrow
   */
  export type ReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * Filter, which Read to fetch.
     */
    where?: ReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reads to fetch.
     */
    orderBy?: ReadOrderByWithRelationInput | ReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reads.
     */
    cursor?: ReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reads.
     */
    distinct?: ReadScalarFieldEnum | ReadScalarFieldEnum[]
  }


  /**
   * Read findMany
   */
  export type ReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * Filter, which Reads to fetch.
     */
    where?: ReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reads to fetch.
     */
    orderBy?: ReadOrderByWithRelationInput | ReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reads.
     */
    cursor?: ReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reads.
     */
    skip?: number
    distinct?: ReadScalarFieldEnum | ReadScalarFieldEnum[]
  }


  /**
   * Read create
   */
  export type ReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * The data needed to create a Read.
     */
    data: XOR<ReadCreateInput, ReadUncheckedCreateInput>
  }


  /**
   * Read createMany
   */
  export type ReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reads.
     */
    data: ReadCreateManyInput | ReadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Read update
   */
  export type ReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * The data needed to update a Read.
     */
    data: XOR<ReadUpdateInput, ReadUncheckedUpdateInput>
    /**
     * Choose, which Read to update.
     */
    where: ReadWhereUniqueInput
  }


  /**
   * Read updateMany
   */
  export type ReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reads.
     */
    data: XOR<ReadUpdateManyMutationInput, ReadUncheckedUpdateManyInput>
    /**
     * Filter which Reads to update
     */
    where?: ReadWhereInput
  }


  /**
   * Read upsert
   */
  export type ReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * The filter to search for the Read to update in case it exists.
     */
    where: ReadWhereUniqueInput
    /**
     * In case the Read found by the `where` argument doesn't exist, create a new Read with this data.
     */
    create: XOR<ReadCreateInput, ReadUncheckedCreateInput>
    /**
     * In case the Read was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReadUpdateInput, ReadUncheckedUpdateInput>
  }


  /**
   * Read delete
   */
  export type ReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
    /**
     * Filter which Read to delete.
     */
    where: ReadWhereUniqueInput
  }


  /**
   * Read deleteMany
   */
  export type ReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reads to delete
     */
    where?: ReadWhereInput
  }


  /**
   * Read without action
   */
  export type ReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Read
     */
    select?: ReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReadInclude<ExtArgs> | null
  }



  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    id: number | null
    messageId: number | null
  }

  export type FileSumAggregateOutputType = {
    id: number | null
    messageId: number | null
  }

  export type FileMinAggregateOutputType = {
    id: number | null
    name: string | null
    fileType: string | null
    messageId: number | null
  }

  export type FileMaxAggregateOutputType = {
    id: number | null
    name: string | null
    fileType: string | null
    messageId: number | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    fileType: number
    messageId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    id?: true
    messageId?: true
  }

  export type FileSumAggregateInputType = {
    id?: true
    messageId?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    messageId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    messageId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    messageId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: number
    name: string
    fileType: string
    messageId: number
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileType?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    fileType?: boolean
    messageId?: boolean
  }

  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }


  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      fileType: string
      messageId: number
    }, ExtArgs["result"]["file"]>
    composites: {}
  }


  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one File that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
    **/
    create<T extends FileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FileCreateArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Files.
     *     @param {FileCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const file = await prisma.file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
    **/
    delete<T extends FileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FileDeleteArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FileUpdateArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
    **/
    upsert<T extends FileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FileUpsertArgs<ExtArgs>>
    ): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the File model
   */ 
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'Int'>
    readonly name: FieldRef<"File", 'String'>
    readonly fileType: FieldRef<"File", 'String'>
    readonly messageId: FieldRef<"File", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }


  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }


  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
  }


  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }


  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
  }


  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude<ExtArgs> | null
  }



  /**
   * Model RiskAssessment
   */

  export type AggregateRiskAssessment = {
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  export type RiskAssessmentAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
  }

  export type RiskAssessmentSumAggregateOutputType = {
    id: number | null
    groupId: number | null
  }

  export type RiskAssessmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    groupId: number | null
    createdAt: Date | null
  }

  export type RiskAssessmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    groupId: number | null
    createdAt: Date | null
  }

  export type RiskAssessmentCountAggregateOutputType = {
    id: number
    name: number
    groupId: number
    createdAt: number
    _all: number
  }


  export type RiskAssessmentAvgAggregateInputType = {
    id?: true
    groupId?: true
  }

  export type RiskAssessmentSumAggregateInputType = {
    id?: true
    groupId?: true
  }

  export type RiskAssessmentMinAggregateInputType = {
    id?: true
    name?: true
    groupId?: true
    createdAt?: true
  }

  export type RiskAssessmentMaxAggregateInputType = {
    id?: true
    name?: true
    groupId?: true
    createdAt?: true
  }

  export type RiskAssessmentCountAggregateInputType = {
    id?: true
    name?: true
    groupId?: true
    createdAt?: true
    _all?: true
  }

  export type RiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessment to aggregate.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAssessments
    **/
    _count?: true | RiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type GetRiskAssessmentAggregateType<T extends RiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAssessment[P]>
      : GetScalarType<T[P], AggregateRiskAssessment[P]>
  }




  export type RiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithAggregationInput | RiskAssessmentOrderByWithAggregationInput[]
    by: RiskAssessmentScalarFieldEnum[] | RiskAssessmentScalarFieldEnum
    having?: RiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAssessmentCountAggregateInputType | true
    _avg?: RiskAssessmentAvgAggregateInputType
    _sum?: RiskAssessmentSumAggregateInputType
    _min?: RiskAssessmentMinAggregateInputType
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type RiskAssessmentGroupByOutputType = {
    id: number
    name: string
    groupId: number
    createdAt: Date
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  type GetRiskAssessmentGroupByPayload<T extends RiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type RiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    groupId?: boolean
    createdAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectScalar = {
    id?: boolean
    name?: boolean
    groupId?: boolean
    createdAt?: boolean
  }

  export type RiskAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }


  export type $RiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAssessment"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      groupId: number
      createdAt: Date
    }, ExtArgs["result"]["riskAssessment"]>
    composites: {}
  }


  type RiskAssessmentGetPayload<S extends boolean | null | undefined | RiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$RiskAssessmentPayload, S>

  type RiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RiskAssessmentCountAggregateInputType | true
    }

  export interface RiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAssessment'], meta: { name: 'RiskAssessment' } }
    /**
     * Find zero or one RiskAssessment that matches the filter.
     * @param {RiskAssessmentFindUniqueArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RiskAssessmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RiskAssessmentFindUniqueArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RiskAssessment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RiskAssessmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RiskAssessmentFindFirstArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany()
     * 
     * // Get first 10 RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RiskAssessmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RiskAssessmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RiskAssessment.
     * @param {RiskAssessmentCreateArgs} args - Arguments to create a RiskAssessment.
     * @example
     * // Create one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.create({
     *   data: {
     *     // ... data to create a RiskAssessment
     *   }
     * })
     * 
    **/
    create<T extends RiskAssessmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RiskAssessmentCreateArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RiskAssessments.
     *     @param {RiskAssessmentCreateManyArgs} args - Arguments to create many RiskAssessments.
     *     @example
     *     // Create many RiskAssessments
     *     const riskAssessment = await prisma.riskAssessment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RiskAssessmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RiskAssessmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RiskAssessment.
     * @param {RiskAssessmentDeleteArgs} args - Arguments to delete one RiskAssessment.
     * @example
     * // Delete one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.delete({
     *   where: {
     *     // ... filter to delete one RiskAssessment
     *   }
     * })
     * 
    **/
    delete<T extends RiskAssessmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RiskAssessmentDeleteArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RiskAssessment.
     * @param {RiskAssessmentUpdateArgs} args - Arguments to update one RiskAssessment.
     * @example
     * // Update one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RiskAssessmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RiskAssessmentUpdateArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RiskAssessments.
     * @param {RiskAssessmentDeleteManyArgs} args - Arguments to filter RiskAssessments to delete.
     * @example
     * // Delete a few RiskAssessments
     * const { count } = await prisma.riskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RiskAssessmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RiskAssessmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RiskAssessmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RiskAssessmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskAssessment.
     * @param {RiskAssessmentUpsertArgs} args - Arguments to update or create a RiskAssessment.
     * @example
     * // Update or create a RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.upsert({
     *   create: {
     *     // ... data to create a RiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAssessment we want to update
     *   }
     * })
    **/
    upsert<T extends RiskAssessmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RiskAssessmentUpsertArgs<ExtArgs>>
    ): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentCountArgs} args - Arguments to filter RiskAssessments to count.
     * @example
     * // Count the number of RiskAssessments
     * const count = await prisma.riskAssessment.count({
     *   where: {
     *     // ... the filter for the RiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends RiskAssessmentCountArgs>(
      args?: Subset<T, RiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAssessmentAggregateArgs>(args: Subset<T, RiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetRiskAssessmentAggregateType<T>>

    /**
     * Group by RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: RiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAssessment model
   */
  readonly fields: RiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RiskAssessment model
   */ 
  interface RiskAssessmentFieldRefs {
    readonly id: FieldRef<"RiskAssessment", 'Int'>
    readonly name: FieldRef<"RiskAssessment", 'String'>
    readonly groupId: FieldRef<"RiskAssessment", 'Int'>
    readonly createdAt: FieldRef<"RiskAssessment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * RiskAssessment findUnique
   */
  export type RiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }


  /**
   * RiskAssessment findUniqueOrThrow
   */
  export type RiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }


  /**
   * RiskAssessment findFirst
   */
  export type RiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }


  /**
   * RiskAssessment findFirstOrThrow
   */
  export type RiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }


  /**
   * RiskAssessment findMany
   */
  export type RiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessments to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }


  /**
   * RiskAssessment create
   */
  export type RiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskAssessment.
     */
    data: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
  }


  /**
   * RiskAssessment createMany
   */
  export type RiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RiskAssessment update
   */
  export type RiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskAssessment.
     */
    data: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which RiskAssessment to update.
     */
    where: RiskAssessmentWhereUniqueInput
  }


  /**
   * RiskAssessment updateMany
   */
  export type RiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAssessments.
     */
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which RiskAssessments to update
     */
    where?: RiskAssessmentWhereInput
  }


  /**
   * RiskAssessment upsert
   */
  export type RiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskAssessment to update in case it exists.
     */
    where: RiskAssessmentWhereUniqueInput
    /**
     * In case the RiskAssessment found by the `where` argument doesn't exist, create a new RiskAssessment with this data.
     */
    create: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
    /**
     * In case the RiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
  }


  /**
   * RiskAssessment delete
   */
  export type RiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter which RiskAssessment to delete.
     */
    where: RiskAssessmentWhereUniqueInput
  }


  /**
   * RiskAssessment deleteMany
   */
  export type RiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessments to delete
     */
    where?: RiskAssessmentWhereInput
  }


  /**
   * RiskAssessment without action
   */
  export type RiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
  }



  /**
   * Model OtherFile
   */

  export type AggregateOtherFile = {
    _count: OtherFileCountAggregateOutputType | null
    _avg: OtherFileAvgAggregateOutputType | null
    _sum: OtherFileSumAggregateOutputType | null
    _min: OtherFileMinAggregateOutputType | null
    _max: OtherFileMaxAggregateOutputType | null
  }

  export type OtherFileAvgAggregateOutputType = {
    id: number | null
  }

  export type OtherFileSumAggregateOutputType = {
    id: number | null
  }

  export type OtherFileMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type OtherFileMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type OtherFileCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type OtherFileAvgAggregateInputType = {
    id?: true
  }

  export type OtherFileSumAggregateInputType = {
    id?: true
  }

  export type OtherFileMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type OtherFileMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type OtherFileCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type OtherFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtherFile to aggregate.
     */
    where?: OtherFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherFiles to fetch.
     */
    orderBy?: OtherFileOrderByWithRelationInput | OtherFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtherFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtherFiles
    **/
    _count?: true | OtherFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtherFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtherFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtherFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtherFileMaxAggregateInputType
  }

  export type GetOtherFileAggregateType<T extends OtherFileAggregateArgs> = {
        [P in keyof T & keyof AggregateOtherFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtherFile[P]>
      : GetScalarType<T[P], AggregateOtherFile[P]>
  }




  export type OtherFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtherFileWhereInput
    orderBy?: OtherFileOrderByWithAggregationInput | OtherFileOrderByWithAggregationInput[]
    by: OtherFileScalarFieldEnum[] | OtherFileScalarFieldEnum
    having?: OtherFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtherFileCountAggregateInputType | true
    _avg?: OtherFileAvgAggregateInputType
    _sum?: OtherFileSumAggregateInputType
    _min?: OtherFileMinAggregateInputType
    _max?: OtherFileMaxAggregateInputType
  }

  export type OtherFileGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: OtherFileCountAggregateOutputType | null
    _avg: OtherFileAvgAggregateOutputType | null
    _sum: OtherFileSumAggregateOutputType | null
    _min: OtherFileMinAggregateOutputType | null
    _max: OtherFileMaxAggregateOutputType | null
  }

  type GetOtherFileGroupByPayload<T extends OtherFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtherFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtherFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtherFileGroupByOutputType[P]>
            : GetScalarType<T[P], OtherFileGroupByOutputType[P]>
        }
      >
    >


  export type OtherFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otherFile"]>

  export type OtherFileSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }


  export type $OtherFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtherFile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["otherFile"]>
    composites: {}
  }


  type OtherFileGetPayload<S extends boolean | null | undefined | OtherFileDefaultArgs> = $Result.GetResult<Prisma.$OtherFilePayload, S>

  type OtherFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtherFileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: OtherFileCountAggregateInputType | true
    }

  export interface OtherFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtherFile'], meta: { name: 'OtherFile' } }
    /**
     * Find zero or one OtherFile that matches the filter.
     * @param {OtherFileFindUniqueArgs} args - Arguments to find a OtherFile
     * @example
     * // Get one OtherFile
     * const otherFile = await prisma.otherFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OtherFileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OtherFileFindUniqueArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OtherFile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OtherFileFindUniqueOrThrowArgs} args - Arguments to find a OtherFile
     * @example
     * // Get one OtherFile
     * const otherFile = await prisma.otherFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OtherFileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtherFileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OtherFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileFindFirstArgs} args - Arguments to find a OtherFile
     * @example
     * // Get one OtherFile
     * const otherFile = await prisma.otherFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OtherFileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OtherFileFindFirstArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OtherFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileFindFirstOrThrowArgs} args - Arguments to find a OtherFile
     * @example
     * // Get one OtherFile
     * const otherFile = await prisma.otherFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OtherFileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtherFileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OtherFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtherFiles
     * const otherFiles = await prisma.otherFile.findMany()
     * 
     * // Get first 10 OtherFiles
     * const otherFiles = await prisma.otherFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otherFileWithIdOnly = await prisma.otherFile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OtherFileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtherFileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OtherFile.
     * @param {OtherFileCreateArgs} args - Arguments to create a OtherFile.
     * @example
     * // Create one OtherFile
     * const OtherFile = await prisma.otherFile.create({
     *   data: {
     *     // ... data to create a OtherFile
     *   }
     * })
     * 
    **/
    create<T extends OtherFileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OtherFileCreateArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OtherFiles.
     *     @param {OtherFileCreateManyArgs} args - Arguments to create many OtherFiles.
     *     @example
     *     // Create many OtherFiles
     *     const otherFile = await prisma.otherFile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OtherFileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtherFileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OtherFile.
     * @param {OtherFileDeleteArgs} args - Arguments to delete one OtherFile.
     * @example
     * // Delete one OtherFile
     * const OtherFile = await prisma.otherFile.delete({
     *   where: {
     *     // ... filter to delete one OtherFile
     *   }
     * })
     * 
    **/
    delete<T extends OtherFileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OtherFileDeleteArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OtherFile.
     * @param {OtherFileUpdateArgs} args - Arguments to update one OtherFile.
     * @example
     * // Update one OtherFile
     * const otherFile = await prisma.otherFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OtherFileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OtherFileUpdateArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OtherFiles.
     * @param {OtherFileDeleteManyArgs} args - Arguments to filter OtherFiles to delete.
     * @example
     * // Delete a few OtherFiles
     * const { count } = await prisma.otherFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OtherFileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtherFileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtherFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtherFiles
     * const otherFile = await prisma.otherFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OtherFileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OtherFileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OtherFile.
     * @param {OtherFileUpsertArgs} args - Arguments to update or create a OtherFile.
     * @example
     * // Update or create a OtherFile
     * const otherFile = await prisma.otherFile.upsert({
     *   create: {
     *     // ... data to create a OtherFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtherFile we want to update
     *   }
     * })
    **/
    upsert<T extends OtherFileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OtherFileUpsertArgs<ExtArgs>>
    ): Prisma__OtherFileClient<$Result.GetResult<Prisma.$OtherFilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OtherFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileCountArgs} args - Arguments to filter OtherFiles to count.
     * @example
     * // Count the number of OtherFiles
     * const count = await prisma.otherFile.count({
     *   where: {
     *     // ... the filter for the OtherFiles we want to count
     *   }
     * })
    **/
    count<T extends OtherFileCountArgs>(
      args?: Subset<T, OtherFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtherFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtherFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtherFileAggregateArgs>(args: Subset<T, OtherFileAggregateArgs>): Prisma.PrismaPromise<GetOtherFileAggregateType<T>>

    /**
     * Group by OtherFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtherFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtherFileGroupByArgs['orderBy'] }
        : { orderBy?: OtherFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtherFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtherFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtherFile model
   */
  readonly fields: OtherFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtherFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtherFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OtherFile model
   */ 
  interface OtherFileFieldRefs {
    readonly id: FieldRef<"OtherFile", 'Int'>
    readonly name: FieldRef<"OtherFile", 'String'>
    readonly createdAt: FieldRef<"OtherFile", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OtherFile findUnique
   */
  export type OtherFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * Filter, which OtherFile to fetch.
     */
    where: OtherFileWhereUniqueInput
  }


  /**
   * OtherFile findUniqueOrThrow
   */
  export type OtherFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * Filter, which OtherFile to fetch.
     */
    where: OtherFileWhereUniqueInput
  }


  /**
   * OtherFile findFirst
   */
  export type OtherFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * Filter, which OtherFile to fetch.
     */
    where?: OtherFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherFiles to fetch.
     */
    orderBy?: OtherFileOrderByWithRelationInput | OtherFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherFiles.
     */
    cursor?: OtherFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherFiles.
     */
    distinct?: OtherFileScalarFieldEnum | OtherFileScalarFieldEnum[]
  }


  /**
   * OtherFile findFirstOrThrow
   */
  export type OtherFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * Filter, which OtherFile to fetch.
     */
    where?: OtherFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherFiles to fetch.
     */
    orderBy?: OtherFileOrderByWithRelationInput | OtherFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherFiles.
     */
    cursor?: OtherFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherFiles.
     */
    distinct?: OtherFileScalarFieldEnum | OtherFileScalarFieldEnum[]
  }


  /**
   * OtherFile findMany
   */
  export type OtherFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * Filter, which OtherFiles to fetch.
     */
    where?: OtherFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherFiles to fetch.
     */
    orderBy?: OtherFileOrderByWithRelationInput | OtherFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtherFiles.
     */
    cursor?: OtherFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherFiles.
     */
    skip?: number
    distinct?: OtherFileScalarFieldEnum | OtherFileScalarFieldEnum[]
  }


  /**
   * OtherFile create
   */
  export type OtherFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * The data needed to create a OtherFile.
     */
    data: XOR<OtherFileCreateInput, OtherFileUncheckedCreateInput>
  }


  /**
   * OtherFile createMany
   */
  export type OtherFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtherFiles.
     */
    data: OtherFileCreateManyInput | OtherFileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OtherFile update
   */
  export type OtherFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * The data needed to update a OtherFile.
     */
    data: XOR<OtherFileUpdateInput, OtherFileUncheckedUpdateInput>
    /**
     * Choose, which OtherFile to update.
     */
    where: OtherFileWhereUniqueInput
  }


  /**
   * OtherFile updateMany
   */
  export type OtherFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtherFiles.
     */
    data: XOR<OtherFileUpdateManyMutationInput, OtherFileUncheckedUpdateManyInput>
    /**
     * Filter which OtherFiles to update
     */
    where?: OtherFileWhereInput
  }


  /**
   * OtherFile upsert
   */
  export type OtherFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * The filter to search for the OtherFile to update in case it exists.
     */
    where: OtherFileWhereUniqueInput
    /**
     * In case the OtherFile found by the `where` argument doesn't exist, create a new OtherFile with this data.
     */
    create: XOR<OtherFileCreateInput, OtherFileUncheckedCreateInput>
    /**
     * In case the OtherFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtherFileUpdateInput, OtherFileUncheckedUpdateInput>
  }


  /**
   * OtherFile delete
   */
  export type OtherFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
    /**
     * Filter which OtherFile to delete.
     */
    where: OtherFileWhereUniqueInput
  }


  /**
   * OtherFile deleteMany
   */
  export type OtherFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtherFiles to delete
     */
    where?: OtherFileWhereInput
  }


  /**
   * OtherFile without action
   */
  export type OtherFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtherFile
     */
    select?: OtherFileSelect<ExtArgs> | null
  }



  /**
   * Model UserOrientation
   */

  export type AggregateUserOrientation = {
    _count: UserOrientationCountAggregateOutputType | null
    _avg: UserOrientationAvgAggregateOutputType | null
    _sum: UserOrientationSumAggregateOutputType | null
    _min: UserOrientationMinAggregateOutputType | null
    _max: UserOrientationMaxAggregateOutputType | null
  }

  export type UserOrientationAvgAggregateOutputType = {
    id: number | null
  }

  export type UserOrientationSumAggregateOutputType = {
    id: number | null
  }

  export type UserOrientationMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type UserOrientationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type UserOrientationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type UserOrientationAvgAggregateInputType = {
    id?: true
  }

  export type UserOrientationSumAggregateInputType = {
    id?: true
  }

  export type UserOrientationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type UserOrientationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type UserOrientationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type UserOrientationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrientation to aggregate.
     */
    where?: UserOrientationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientations to fetch.
     */
    orderBy?: UserOrientationOrderByWithRelationInput | UserOrientationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOrientationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOrientations
    **/
    _count?: true | UserOrientationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOrientationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOrientationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOrientationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOrientationMaxAggregateInputType
  }

  export type GetUserOrientationAggregateType<T extends UserOrientationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOrientation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOrientation[P]>
      : GetScalarType<T[P], AggregateUserOrientation[P]>
  }




  export type UserOrientationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrientationWhereInput
    orderBy?: UserOrientationOrderByWithAggregationInput | UserOrientationOrderByWithAggregationInput[]
    by: UserOrientationScalarFieldEnum[] | UserOrientationScalarFieldEnum
    having?: UserOrientationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOrientationCountAggregateInputType | true
    _avg?: UserOrientationAvgAggregateInputType
    _sum?: UserOrientationSumAggregateInputType
    _min?: UserOrientationMinAggregateInputType
    _max?: UserOrientationMaxAggregateInputType
  }

  export type UserOrientationGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: UserOrientationCountAggregateOutputType | null
    _avg: UserOrientationAvgAggregateOutputType | null
    _sum: UserOrientationSumAggregateOutputType | null
    _min: UserOrientationMinAggregateOutputType | null
    _max: UserOrientationMaxAggregateOutputType | null
  }

  type GetUserOrientationGroupByPayload<T extends UserOrientationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOrientationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOrientationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOrientationGroupByOutputType[P]>
            : GetScalarType<T[P], UserOrientationGroupByOutputType[P]>
        }
      >
    >


  export type UserOrientationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    userOrientationReads?: boolean | UserOrientation$userOrientationReadsArgs<ExtArgs>
    _count?: boolean | UserOrientationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOrientation"]>

  export type UserOrientationSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type UserOrientationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userOrientationReads?: boolean | UserOrientation$userOrientationReadsArgs<ExtArgs>
    _count?: boolean | UserOrientationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserOrientationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOrientation"
    objects: {
      userOrientationReads: Prisma.$UserOrientationReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["userOrientation"]>
    composites: {}
  }


  type UserOrientationGetPayload<S extends boolean | null | undefined | UserOrientationDefaultArgs> = $Result.GetResult<Prisma.$UserOrientationPayload, S>

  type UserOrientationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserOrientationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserOrientationCountAggregateInputType | true
    }

  export interface UserOrientationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOrientation'], meta: { name: 'UserOrientation' } }
    /**
     * Find zero or one UserOrientation that matches the filter.
     * @param {UserOrientationFindUniqueArgs} args - Arguments to find a UserOrientation
     * @example
     * // Get one UserOrientation
     * const userOrientation = await prisma.userOrientation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserOrientationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationFindUniqueArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserOrientation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserOrientationFindUniqueOrThrowArgs} args - Arguments to find a UserOrientation
     * @example
     * // Get one UserOrientation
     * const userOrientation = await prisma.userOrientation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserOrientationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserOrientation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationFindFirstArgs} args - Arguments to find a UserOrientation
     * @example
     * // Get one UserOrientation
     * const userOrientation = await prisma.userOrientation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserOrientationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationFindFirstArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserOrientation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationFindFirstOrThrowArgs} args - Arguments to find a UserOrientation
     * @example
     * // Get one UserOrientation
     * const userOrientation = await prisma.userOrientation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserOrientationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserOrientations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOrientations
     * const userOrientations = await prisma.userOrientation.findMany()
     * 
     * // Get first 10 UserOrientations
     * const userOrientations = await prisma.userOrientation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOrientationWithIdOnly = await prisma.userOrientation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserOrientationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserOrientation.
     * @param {UserOrientationCreateArgs} args - Arguments to create a UserOrientation.
     * @example
     * // Create one UserOrientation
     * const UserOrientation = await prisma.userOrientation.create({
     *   data: {
     *     // ... data to create a UserOrientation
     *   }
     * })
     * 
    **/
    create<T extends UserOrientationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationCreateArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserOrientations.
     *     @param {UserOrientationCreateManyArgs} args - Arguments to create many UserOrientations.
     *     @example
     *     // Create many UserOrientations
     *     const userOrientation = await prisma.userOrientation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserOrientationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserOrientation.
     * @param {UserOrientationDeleteArgs} args - Arguments to delete one UserOrientation.
     * @example
     * // Delete one UserOrientation
     * const UserOrientation = await prisma.userOrientation.delete({
     *   where: {
     *     // ... filter to delete one UserOrientation
     *   }
     * })
     * 
    **/
    delete<T extends UserOrientationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationDeleteArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserOrientation.
     * @param {UserOrientationUpdateArgs} args - Arguments to update one UserOrientation.
     * @example
     * // Update one UserOrientation
     * const userOrientation = await prisma.userOrientation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserOrientationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationUpdateArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserOrientations.
     * @param {UserOrientationDeleteManyArgs} args - Arguments to filter UserOrientations to delete.
     * @example
     * // Delete a few UserOrientations
     * const { count } = await prisma.userOrientation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserOrientationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOrientations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOrientations
     * const userOrientation = await prisma.userOrientation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserOrientationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOrientation.
     * @param {UserOrientationUpsertArgs} args - Arguments to update or create a UserOrientation.
     * @example
     * // Update or create a UserOrientation
     * const userOrientation = await prisma.userOrientation.upsert({
     *   create: {
     *     // ... data to create a UserOrientation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOrientation we want to update
     *   }
     * })
    **/
    upsert<T extends UserOrientationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationUpsertArgs<ExtArgs>>
    ): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserOrientations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationCountArgs} args - Arguments to filter UserOrientations to count.
     * @example
     * // Count the number of UserOrientations
     * const count = await prisma.userOrientation.count({
     *   where: {
     *     // ... the filter for the UserOrientations we want to count
     *   }
     * })
    **/
    count<T extends UserOrientationCountArgs>(
      args?: Subset<T, UserOrientationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOrientationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOrientation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOrientationAggregateArgs>(args: Subset<T, UserOrientationAggregateArgs>): Prisma.PrismaPromise<GetUserOrientationAggregateType<T>>

    /**
     * Group by UserOrientation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOrientationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOrientationGroupByArgs['orderBy'] }
        : { orderBy?: UserOrientationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOrientationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOrientationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOrientation model
   */
  readonly fields: UserOrientationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOrientation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOrientationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userOrientationReads<T extends UserOrientation$userOrientationReadsArgs<ExtArgs> = {}>(args?: Subset<T, UserOrientation$userOrientationReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserOrientation model
   */ 
  interface UserOrientationFieldRefs {
    readonly id: FieldRef<"UserOrientation", 'Int'>
    readonly name: FieldRef<"UserOrientation", 'String'>
    readonly createdAt: FieldRef<"UserOrientation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * UserOrientation findUnique
   */
  export type UserOrientationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientation to fetch.
     */
    where: UserOrientationWhereUniqueInput
  }


  /**
   * UserOrientation findUniqueOrThrow
   */
  export type UserOrientationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientation to fetch.
     */
    where: UserOrientationWhereUniqueInput
  }


  /**
   * UserOrientation findFirst
   */
  export type UserOrientationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientation to fetch.
     */
    where?: UserOrientationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientations to fetch.
     */
    orderBy?: UserOrientationOrderByWithRelationInput | UserOrientationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrientations.
     */
    cursor?: UserOrientationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrientations.
     */
    distinct?: UserOrientationScalarFieldEnum | UserOrientationScalarFieldEnum[]
  }


  /**
   * UserOrientation findFirstOrThrow
   */
  export type UserOrientationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientation to fetch.
     */
    where?: UserOrientationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientations to fetch.
     */
    orderBy?: UserOrientationOrderByWithRelationInput | UserOrientationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrientations.
     */
    cursor?: UserOrientationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrientations.
     */
    distinct?: UserOrientationScalarFieldEnum | UserOrientationScalarFieldEnum[]
  }


  /**
   * UserOrientation findMany
   */
  export type UserOrientationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientations to fetch.
     */
    where?: UserOrientationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientations to fetch.
     */
    orderBy?: UserOrientationOrderByWithRelationInput | UserOrientationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOrientations.
     */
    cursor?: UserOrientationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientations.
     */
    skip?: number
    distinct?: UserOrientationScalarFieldEnum | UserOrientationScalarFieldEnum[]
  }


  /**
   * UserOrientation create
   */
  export type UserOrientationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOrientation.
     */
    data: XOR<UserOrientationCreateInput, UserOrientationUncheckedCreateInput>
  }


  /**
   * UserOrientation createMany
   */
  export type UserOrientationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOrientations.
     */
    data: UserOrientationCreateManyInput | UserOrientationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserOrientation update
   */
  export type UserOrientationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOrientation.
     */
    data: XOR<UserOrientationUpdateInput, UserOrientationUncheckedUpdateInput>
    /**
     * Choose, which UserOrientation to update.
     */
    where: UserOrientationWhereUniqueInput
  }


  /**
   * UserOrientation updateMany
   */
  export type UserOrientationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOrientations.
     */
    data: XOR<UserOrientationUpdateManyMutationInput, UserOrientationUncheckedUpdateManyInput>
    /**
     * Filter which UserOrientations to update
     */
    where?: UserOrientationWhereInput
  }


  /**
   * UserOrientation upsert
   */
  export type UserOrientationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOrientation to update in case it exists.
     */
    where: UserOrientationWhereUniqueInput
    /**
     * In case the UserOrientation found by the `where` argument doesn't exist, create a new UserOrientation with this data.
     */
    create: XOR<UserOrientationCreateInput, UserOrientationUncheckedCreateInput>
    /**
     * In case the UserOrientation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOrientationUpdateInput, UserOrientationUncheckedUpdateInput>
  }


  /**
   * UserOrientation delete
   */
  export type UserOrientationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
    /**
     * Filter which UserOrientation to delete.
     */
    where: UserOrientationWhereUniqueInput
  }


  /**
   * UserOrientation deleteMany
   */
  export type UserOrientationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrientations to delete
     */
    where?: UserOrientationWhereInput
  }


  /**
   * UserOrientation.userOrientationReads
   */
  export type UserOrientation$userOrientationReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    where?: UserOrientationReadWhereInput
    orderBy?: UserOrientationReadOrderByWithRelationInput | UserOrientationReadOrderByWithRelationInput[]
    cursor?: UserOrientationReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOrientationReadScalarFieldEnum | UserOrientationReadScalarFieldEnum[]
  }


  /**
   * UserOrientation without action
   */
  export type UserOrientationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientation
     */
    select?: UserOrientationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationInclude<ExtArgs> | null
  }



  /**
   * Model UserOrientationRead
   */

  export type AggregateUserOrientationRead = {
    _count: UserOrientationReadCountAggregateOutputType | null
    _avg: UserOrientationReadAvgAggregateOutputType | null
    _sum: UserOrientationReadSumAggregateOutputType | null
    _min: UserOrientationReadMinAggregateOutputType | null
    _max: UserOrientationReadMaxAggregateOutputType | null
  }

  export type UserOrientationReadAvgAggregateOutputType = {
    id: number | null
    userOrientationId: number | null
    userId: number | null
  }

  export type UserOrientationReadSumAggregateOutputType = {
    id: number | null
    userOrientationId: number | null
    userId: number | null
  }

  export type UserOrientationReadMinAggregateOutputType = {
    id: number | null
    userOrientationId: number | null
    userId: number | null
    readAt: Date | null
  }

  export type UserOrientationReadMaxAggregateOutputType = {
    id: number | null
    userOrientationId: number | null
    userId: number | null
    readAt: Date | null
  }

  export type UserOrientationReadCountAggregateOutputType = {
    id: number
    userOrientationId: number
    userId: number
    readAt: number
    _all: number
  }


  export type UserOrientationReadAvgAggregateInputType = {
    id?: true
    userOrientationId?: true
    userId?: true
  }

  export type UserOrientationReadSumAggregateInputType = {
    id?: true
    userOrientationId?: true
    userId?: true
  }

  export type UserOrientationReadMinAggregateInputType = {
    id?: true
    userOrientationId?: true
    userId?: true
    readAt?: true
  }

  export type UserOrientationReadMaxAggregateInputType = {
    id?: true
    userOrientationId?: true
    userId?: true
    readAt?: true
  }

  export type UserOrientationReadCountAggregateInputType = {
    id?: true
    userOrientationId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type UserOrientationReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrientationRead to aggregate.
     */
    where?: UserOrientationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientationReads to fetch.
     */
    orderBy?: UserOrientationReadOrderByWithRelationInput | UserOrientationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOrientationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOrientationReads
    **/
    _count?: true | UserOrientationReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOrientationReadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOrientationReadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOrientationReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOrientationReadMaxAggregateInputType
  }

  export type GetUserOrientationReadAggregateType<T extends UserOrientationReadAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOrientationRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOrientationRead[P]>
      : GetScalarType<T[P], AggregateUserOrientationRead[P]>
  }




  export type UserOrientationReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOrientationReadWhereInput
    orderBy?: UserOrientationReadOrderByWithAggregationInput | UserOrientationReadOrderByWithAggregationInput[]
    by: UserOrientationReadScalarFieldEnum[] | UserOrientationReadScalarFieldEnum
    having?: UserOrientationReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOrientationReadCountAggregateInputType | true
    _avg?: UserOrientationReadAvgAggregateInputType
    _sum?: UserOrientationReadSumAggregateInputType
    _min?: UserOrientationReadMinAggregateInputType
    _max?: UserOrientationReadMaxAggregateInputType
  }

  export type UserOrientationReadGroupByOutputType = {
    id: number
    userOrientationId: number
    userId: number
    readAt: Date
    _count: UserOrientationReadCountAggregateOutputType | null
    _avg: UserOrientationReadAvgAggregateOutputType | null
    _sum: UserOrientationReadSumAggregateOutputType | null
    _min: UserOrientationReadMinAggregateOutputType | null
    _max: UserOrientationReadMaxAggregateOutputType | null
  }

  type GetUserOrientationReadGroupByPayload<T extends UserOrientationReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOrientationReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOrientationReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOrientationReadGroupByOutputType[P]>
            : GetScalarType<T[P], UserOrientationReadGroupByOutputType[P]>
        }
      >
    >


  export type UserOrientationReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userOrientationId?: boolean
    userId?: boolean
    readAt?: boolean
    userOrientation?: boolean | UserOrientationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOrientationRead"]>

  export type UserOrientationReadSelectScalar = {
    id?: boolean
    userOrientationId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type UserOrientationReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userOrientation?: boolean | UserOrientationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $UserOrientationReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOrientationRead"
    objects: {
      userOrientation: Prisma.$UserOrientationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userOrientationId: number
      userId: number
      readAt: Date
    }, ExtArgs["result"]["userOrientationRead"]>
    composites: {}
  }


  type UserOrientationReadGetPayload<S extends boolean | null | undefined | UserOrientationReadDefaultArgs> = $Result.GetResult<Prisma.$UserOrientationReadPayload, S>

  type UserOrientationReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserOrientationReadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserOrientationReadCountAggregateInputType | true
    }

  export interface UserOrientationReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOrientationRead'], meta: { name: 'UserOrientationRead' } }
    /**
     * Find zero or one UserOrientationRead that matches the filter.
     * @param {UserOrientationReadFindUniqueArgs} args - Arguments to find a UserOrientationRead
     * @example
     * // Get one UserOrientationRead
     * const userOrientationRead = await prisma.userOrientationRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserOrientationReadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationReadFindUniqueArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserOrientationRead that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserOrientationReadFindUniqueOrThrowArgs} args - Arguments to find a UserOrientationRead
     * @example
     * // Get one UserOrientationRead
     * const userOrientationRead = await prisma.userOrientationRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserOrientationReadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationReadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserOrientationRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadFindFirstArgs} args - Arguments to find a UserOrientationRead
     * @example
     * // Get one UserOrientationRead
     * const userOrientationRead = await prisma.userOrientationRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserOrientationReadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationReadFindFirstArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserOrientationRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadFindFirstOrThrowArgs} args - Arguments to find a UserOrientationRead
     * @example
     * // Get one UserOrientationRead
     * const userOrientationRead = await prisma.userOrientationRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserOrientationReadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationReadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserOrientationReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOrientationReads
     * const userOrientationReads = await prisma.userOrientationRead.findMany()
     * 
     * // Get first 10 UserOrientationReads
     * const userOrientationReads = await prisma.userOrientationRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOrientationReadWithIdOnly = await prisma.userOrientationRead.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserOrientationReadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationReadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserOrientationRead.
     * @param {UserOrientationReadCreateArgs} args - Arguments to create a UserOrientationRead.
     * @example
     * // Create one UserOrientationRead
     * const UserOrientationRead = await prisma.userOrientationRead.create({
     *   data: {
     *     // ... data to create a UserOrientationRead
     *   }
     * })
     * 
    **/
    create<T extends UserOrientationReadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationReadCreateArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserOrientationReads.
     *     @param {UserOrientationReadCreateManyArgs} args - Arguments to create many UserOrientationReads.
     *     @example
     *     // Create many UserOrientationReads
     *     const userOrientationRead = await prisma.userOrientationRead.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserOrientationReadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationReadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserOrientationRead.
     * @param {UserOrientationReadDeleteArgs} args - Arguments to delete one UserOrientationRead.
     * @example
     * // Delete one UserOrientationRead
     * const UserOrientationRead = await prisma.userOrientationRead.delete({
     *   where: {
     *     // ... filter to delete one UserOrientationRead
     *   }
     * })
     * 
    **/
    delete<T extends UserOrientationReadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationReadDeleteArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserOrientationRead.
     * @param {UserOrientationReadUpdateArgs} args - Arguments to update one UserOrientationRead.
     * @example
     * // Update one UserOrientationRead
     * const userOrientationRead = await prisma.userOrientationRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserOrientationReadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationReadUpdateArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserOrientationReads.
     * @param {UserOrientationReadDeleteManyArgs} args - Arguments to filter UserOrientationReads to delete.
     * @example
     * // Delete a few UserOrientationReads
     * const { count } = await prisma.userOrientationRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserOrientationReadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOrientationReadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOrientationReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOrientationReads
     * const userOrientationRead = await prisma.userOrientationRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserOrientationReadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationReadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOrientationRead.
     * @param {UserOrientationReadUpsertArgs} args - Arguments to update or create a UserOrientationRead.
     * @example
     * // Update or create a UserOrientationRead
     * const userOrientationRead = await prisma.userOrientationRead.upsert({
     *   create: {
     *     // ... data to create a UserOrientationRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOrientationRead we want to update
     *   }
     * })
    **/
    upsert<T extends UserOrientationReadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserOrientationReadUpsertArgs<ExtArgs>>
    ): Prisma__UserOrientationReadClient<$Result.GetResult<Prisma.$UserOrientationReadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserOrientationReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadCountArgs} args - Arguments to filter UserOrientationReads to count.
     * @example
     * // Count the number of UserOrientationReads
     * const count = await prisma.userOrientationRead.count({
     *   where: {
     *     // ... the filter for the UserOrientationReads we want to count
     *   }
     * })
    **/
    count<T extends UserOrientationReadCountArgs>(
      args?: Subset<T, UserOrientationReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOrientationReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOrientationRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOrientationReadAggregateArgs>(args: Subset<T, UserOrientationReadAggregateArgs>): Prisma.PrismaPromise<GetUserOrientationReadAggregateType<T>>

    /**
     * Group by UserOrientationRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOrientationReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOrientationReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOrientationReadGroupByArgs['orderBy'] }
        : { orderBy?: UserOrientationReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOrientationReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOrientationReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOrientationRead model
   */
  readonly fields: UserOrientationReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOrientationRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOrientationReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userOrientation<T extends UserOrientationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserOrientationDefaultArgs<ExtArgs>>): Prisma__UserOrientationClient<$Result.GetResult<Prisma.$UserOrientationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserOrientationRead model
   */ 
  interface UserOrientationReadFieldRefs {
    readonly id: FieldRef<"UserOrientationRead", 'Int'>
    readonly userOrientationId: FieldRef<"UserOrientationRead", 'Int'>
    readonly userId: FieldRef<"UserOrientationRead", 'Int'>
    readonly readAt: FieldRef<"UserOrientationRead", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * UserOrientationRead findUnique
   */
  export type UserOrientationReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientationRead to fetch.
     */
    where: UserOrientationReadWhereUniqueInput
  }


  /**
   * UserOrientationRead findUniqueOrThrow
   */
  export type UserOrientationReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientationRead to fetch.
     */
    where: UserOrientationReadWhereUniqueInput
  }


  /**
   * UserOrientationRead findFirst
   */
  export type UserOrientationReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientationRead to fetch.
     */
    where?: UserOrientationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientationReads to fetch.
     */
    orderBy?: UserOrientationReadOrderByWithRelationInput | UserOrientationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrientationReads.
     */
    cursor?: UserOrientationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrientationReads.
     */
    distinct?: UserOrientationReadScalarFieldEnum | UserOrientationReadScalarFieldEnum[]
  }


  /**
   * UserOrientationRead findFirstOrThrow
   */
  export type UserOrientationReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientationRead to fetch.
     */
    where?: UserOrientationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientationReads to fetch.
     */
    orderBy?: UserOrientationReadOrderByWithRelationInput | UserOrientationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOrientationReads.
     */
    cursor?: UserOrientationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOrientationReads.
     */
    distinct?: UserOrientationReadScalarFieldEnum | UserOrientationReadScalarFieldEnum[]
  }


  /**
   * UserOrientationRead findMany
   */
  export type UserOrientationReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * Filter, which UserOrientationReads to fetch.
     */
    where?: UserOrientationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOrientationReads to fetch.
     */
    orderBy?: UserOrientationReadOrderByWithRelationInput | UserOrientationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOrientationReads.
     */
    cursor?: UserOrientationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOrientationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOrientationReads.
     */
    skip?: number
    distinct?: UserOrientationReadScalarFieldEnum | UserOrientationReadScalarFieldEnum[]
  }


  /**
   * UserOrientationRead create
   */
  export type UserOrientationReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOrientationRead.
     */
    data: XOR<UserOrientationReadCreateInput, UserOrientationReadUncheckedCreateInput>
  }


  /**
   * UserOrientationRead createMany
   */
  export type UserOrientationReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOrientationReads.
     */
    data: UserOrientationReadCreateManyInput | UserOrientationReadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserOrientationRead update
   */
  export type UserOrientationReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOrientationRead.
     */
    data: XOR<UserOrientationReadUpdateInput, UserOrientationReadUncheckedUpdateInput>
    /**
     * Choose, which UserOrientationRead to update.
     */
    where: UserOrientationReadWhereUniqueInput
  }


  /**
   * UserOrientationRead updateMany
   */
  export type UserOrientationReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOrientationReads.
     */
    data: XOR<UserOrientationReadUpdateManyMutationInput, UserOrientationReadUncheckedUpdateManyInput>
    /**
     * Filter which UserOrientationReads to update
     */
    where?: UserOrientationReadWhereInput
  }


  /**
   * UserOrientationRead upsert
   */
  export type UserOrientationReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOrientationRead to update in case it exists.
     */
    where: UserOrientationReadWhereUniqueInput
    /**
     * In case the UserOrientationRead found by the `where` argument doesn't exist, create a new UserOrientationRead with this data.
     */
    create: XOR<UserOrientationReadCreateInput, UserOrientationReadUncheckedCreateInput>
    /**
     * In case the UserOrientationRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOrientationReadUpdateInput, UserOrientationReadUncheckedUpdateInput>
  }


  /**
   * UserOrientationRead delete
   */
  export type UserOrientationReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
    /**
     * Filter which UserOrientationRead to delete.
     */
    where: UserOrientationReadWhereUniqueInput
  }


  /**
   * UserOrientationRead deleteMany
   */
  export type UserOrientationReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOrientationReads to delete
     */
    where?: UserOrientationReadWhereInput
  }


  /**
   * UserOrientationRead without action
   */
  export type UserOrientationReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOrientationRead
     */
    select?: UserOrientationReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserOrientationReadInclude<ExtArgs> | null
  }



  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    location: string | null
    organizationName: string | null
    date: string | null
    time: string | null
    feedback: string | null
    source: string | null
    color: $Enums.FeedbackColor | null
    selectedValues: string | null
    description: string | null
    reportedBy: string | null
    responsiblePerson: string | null
    actionTaken: string | null
    status: $Enums.Status | null
    userAcknowledgement: string | null
    createdById: number | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    location: string | null
    organizationName: string | null
    date: string | null
    time: string | null
    feedback: string | null
    source: string | null
    color: $Enums.FeedbackColor | null
    selectedValues: string | null
    description: string | null
    reportedBy: string | null
    responsiblePerson: string | null
    actionTaken: string | null
    status: $Enums.Status | null
    userAcknowledgement: string | null
    createdById: number | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    location: number
    organizationName: number
    date: number
    time: number
    feedback: number
    source: number
    color: number
    selectedValues: number
    description: number
    reportedBy: number
    responsiblePerson: number
    actionTaken: number
    status: number
    userAcknowledgement: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    location?: true
    organizationName?: true
    date?: true
    time?: true
    feedback?: true
    source?: true
    color?: true
    selectedValues?: true
    description?: true
    reportedBy?: true
    responsiblePerson?: true
    actionTaken?: true
    status?: true
    userAcknowledgement?: true
    createdById?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    location?: true
    organizationName?: true
    date?: true
    time?: true
    feedback?: true
    source?: true
    color?: true
    selectedValues?: true
    description?: true
    reportedBy?: true
    responsiblePerson?: true
    actionTaken?: true
    status?: true
    userAcknowledgement?: true
    createdById?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    location?: true
    organizationName?: true
    date?: true
    time?: true
    feedback?: true
    source?: true
    color?: true
    selectedValues?: true
    description?: true
    reportedBy?: true
    responsiblePerson?: true
    actionTaken?: true
    status?: true
    userAcknowledgement?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson: string | null
    actionTaken: string | null
    status: $Enums.Status | null
    userAcknowledgement: string | null
    createdById: number
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    organizationName?: boolean
    date?: boolean
    time?: boolean
    feedback?: boolean
    source?: boolean
    color?: boolean
    selectedValues?: boolean
    description?: boolean
    reportedBy?: boolean
    responsiblePerson?: boolean
    actionTaken?: boolean
    status?: boolean
    userAcknowledgement?: boolean
    createdById?: boolean
    createdAt?: boolean
    files?: boolean | Feedback$filesArgs<ExtArgs>
    actionFiles?: boolean | Feedback$actionFilesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    feedbackAssignments?: boolean | Feedback$feedbackAssignmentsArgs<ExtArgs>
    _count?: boolean | FeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    location?: boolean
    organizationName?: boolean
    date?: boolean
    time?: boolean
    feedback?: boolean
    source?: boolean
    color?: boolean
    selectedValues?: boolean
    description?: boolean
    reportedBy?: boolean
    responsiblePerson?: boolean
    actionTaken?: boolean
    status?: boolean
    userAcknowledgement?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | Feedback$filesArgs<ExtArgs>
    actionFiles?: boolean | Feedback$actionFilesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    feedbackAssignments?: boolean | Feedback$feedbackAssignmentsArgs<ExtArgs>
    _count?: boolean | FeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      files: Prisma.$FeedbackFilePayload<ExtArgs>[]
      actionFiles: Prisma.$FeedbackActionFilePayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      feedbackAssignments: Prisma.$FeedbackAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      location: string
      organizationName: string
      date: string
      time: string
      feedback: string
      source: string
      color: $Enums.FeedbackColor
      selectedValues: string
      description: string
      reportedBy: string
      responsiblePerson: string | null
      actionTaken: string | null
      status: $Enums.Status | null
      userAcknowledgement: string | null
      createdById: number
      createdAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }


  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends FeedbackCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feedbacks.
     *     @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    files<T extends Feedback$filesArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'findMany'> | Null>;

    actionFiles<T extends Feedback$actionFilesArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$actionFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'findMany'> | Null>;

    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    feedbackAssignments<T extends Feedback$feedbackAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$feedbackAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly location: FieldRef<"Feedback", 'String'>
    readonly organizationName: FieldRef<"Feedback", 'String'>
    readonly date: FieldRef<"Feedback", 'String'>
    readonly time: FieldRef<"Feedback", 'String'>
    readonly feedback: FieldRef<"Feedback", 'String'>
    readonly source: FieldRef<"Feedback", 'String'>
    readonly color: FieldRef<"Feedback", 'FeedbackColor'>
    readonly selectedValues: FieldRef<"Feedback", 'String'>
    readonly description: FieldRef<"Feedback", 'String'>
    readonly reportedBy: FieldRef<"Feedback", 'String'>
    readonly responsiblePerson: FieldRef<"Feedback", 'String'>
    readonly actionTaken: FieldRef<"Feedback", 'String'>
    readonly status: FieldRef<"Feedback", 'Status'>
    readonly userAcknowledgement: FieldRef<"Feedback", 'String'>
    readonly createdById: FieldRef<"Feedback", 'Int'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }


  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }


  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback.files
   */
  export type Feedback$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    where?: FeedbackFileWhereInput
    orderBy?: FeedbackFileOrderByWithRelationInput | FeedbackFileOrderByWithRelationInput[]
    cursor?: FeedbackFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackFileScalarFieldEnum | FeedbackFileScalarFieldEnum[]
  }


  /**
   * Feedback.actionFiles
   */
  export type Feedback$actionFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    where?: FeedbackActionFileWhereInput
    orderBy?: FeedbackActionFileOrderByWithRelationInput | FeedbackActionFileOrderByWithRelationInput[]
    cursor?: FeedbackActionFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackActionFileScalarFieldEnum | FeedbackActionFileScalarFieldEnum[]
  }


  /**
   * Feedback.feedbackAssignments
   */
  export type Feedback$feedbackAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    where?: FeedbackAssignmentWhereInput
    orderBy?: FeedbackAssignmentOrderByWithRelationInput | FeedbackAssignmentOrderByWithRelationInput[]
    cursor?: FeedbackAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackAssignmentScalarFieldEnum | FeedbackAssignmentScalarFieldEnum[]
  }


  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
  }



  /**
   * Model FeedbackAssignment
   */

  export type AggregateFeedbackAssignment = {
    _count: FeedbackAssignmentCountAggregateOutputType | null
    _avg: FeedbackAssignmentAvgAggregateOutputType | null
    _sum: FeedbackAssignmentSumAggregateOutputType | null
    _min: FeedbackAssignmentMinAggregateOutputType | null
    _max: FeedbackAssignmentMaxAggregateOutputType | null
  }

  export type FeedbackAssignmentAvgAggregateOutputType = {
    id: number | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackAssignmentSumAggregateOutputType = {
    id: number | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackAssignmentMinAggregateOutputType = {
    id: number | null
    assignmentCompleted: boolean | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackAssignmentMaxAggregateOutputType = {
    id: number | null
    assignmentCompleted: boolean | null
    feedbackId: number | null
    userId: number | null
  }

  export type FeedbackAssignmentCountAggregateOutputType = {
    id: number
    assignmentCompleted: number
    feedbackId: number
    userId: number
    _all: number
  }


  export type FeedbackAssignmentAvgAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackAssignmentSumAggregateInputType = {
    id?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackAssignmentMinAggregateInputType = {
    id?: true
    assignmentCompleted?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackAssignmentMaxAggregateInputType = {
    id?: true
    assignmentCompleted?: true
    feedbackId?: true
    userId?: true
  }

  export type FeedbackAssignmentCountAggregateInputType = {
    id?: true
    assignmentCompleted?: true
    feedbackId?: true
    userId?: true
    _all?: true
  }

  export type FeedbackAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackAssignment to aggregate.
     */
    where?: FeedbackAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackAssignments to fetch.
     */
    orderBy?: FeedbackAssignmentOrderByWithRelationInput | FeedbackAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackAssignments
    **/
    _count?: true | FeedbackAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackAssignmentMaxAggregateInputType
  }

  export type GetFeedbackAssignmentAggregateType<T extends FeedbackAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackAssignment[P]>
      : GetScalarType<T[P], AggregateFeedbackAssignment[P]>
  }




  export type FeedbackAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackAssignmentWhereInput
    orderBy?: FeedbackAssignmentOrderByWithAggregationInput | FeedbackAssignmentOrderByWithAggregationInput[]
    by: FeedbackAssignmentScalarFieldEnum[] | FeedbackAssignmentScalarFieldEnum
    having?: FeedbackAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackAssignmentCountAggregateInputType | true
    _avg?: FeedbackAssignmentAvgAggregateInputType
    _sum?: FeedbackAssignmentSumAggregateInputType
    _min?: FeedbackAssignmentMinAggregateInputType
    _max?: FeedbackAssignmentMaxAggregateInputType
  }

  export type FeedbackAssignmentGroupByOutputType = {
    id: number
    assignmentCompleted: boolean
    feedbackId: number
    userId: number
    _count: FeedbackAssignmentCountAggregateOutputType | null
    _avg: FeedbackAssignmentAvgAggregateOutputType | null
    _sum: FeedbackAssignmentSumAggregateOutputType | null
    _min: FeedbackAssignmentMinAggregateOutputType | null
    _max: FeedbackAssignmentMaxAggregateOutputType | null
  }

  type GetFeedbackAssignmentGroupByPayload<T extends FeedbackAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentCompleted?: boolean
    feedbackId?: boolean
    userId?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackAssignment"]>

  export type FeedbackAssignmentSelectScalar = {
    id?: boolean
    assignmentCompleted?: boolean
    feedbackId?: boolean
    userId?: boolean
  }

  export type FeedbackAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $FeedbackAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackAssignment"
    objects: {
      feedback: Prisma.$FeedbackPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assignmentCompleted: boolean
      feedbackId: number
      userId: number
    }, ExtArgs["result"]["feedbackAssignment"]>
    composites: {}
  }


  type FeedbackAssignmentGetPayload<S extends boolean | null | undefined | FeedbackAssignmentDefaultArgs> = $Result.GetResult<Prisma.$FeedbackAssignmentPayload, S>

  type FeedbackAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackAssignmentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FeedbackAssignmentCountAggregateInputType | true
    }

  export interface FeedbackAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackAssignment'], meta: { name: 'FeedbackAssignment' } }
    /**
     * Find zero or one FeedbackAssignment that matches the filter.
     * @param {FeedbackAssignmentFindUniqueArgs} args - Arguments to find a FeedbackAssignment
     * @example
     * // Get one FeedbackAssignment
     * const feedbackAssignment = await prisma.feedbackAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackAssignmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackAssignmentFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeedbackAssignment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackAssignmentFindUniqueOrThrowArgs} args - Arguments to find a FeedbackAssignment
     * @example
     * // Get one FeedbackAssignment
     * const feedbackAssignment = await prisma.feedbackAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackAssignmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackAssignmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeedbackAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentFindFirstArgs} args - Arguments to find a FeedbackAssignment
     * @example
     * // Get one FeedbackAssignment
     * const feedbackAssignment = await prisma.feedbackAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackAssignmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackAssignmentFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeedbackAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentFindFirstOrThrowArgs} args - Arguments to find a FeedbackAssignment
     * @example
     * // Get one FeedbackAssignment
     * const feedbackAssignment = await prisma.feedbackAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackAssignmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackAssignmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeedbackAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackAssignments
     * const feedbackAssignments = await prisma.feedbackAssignment.findMany()
     * 
     * // Get first 10 FeedbackAssignments
     * const feedbackAssignments = await prisma.feedbackAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackAssignmentWithIdOnly = await prisma.feedbackAssignment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackAssignmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackAssignmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeedbackAssignment.
     * @param {FeedbackAssignmentCreateArgs} args - Arguments to create a FeedbackAssignment.
     * @example
     * // Create one FeedbackAssignment
     * const FeedbackAssignment = await prisma.feedbackAssignment.create({
     *   data: {
     *     // ... data to create a FeedbackAssignment
     *   }
     * })
     * 
    **/
    create<T extends FeedbackAssignmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackAssignmentCreateArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FeedbackAssignments.
     *     @param {FeedbackAssignmentCreateManyArgs} args - Arguments to create many FeedbackAssignments.
     *     @example
     *     // Create many FeedbackAssignments
     *     const feedbackAssignment = await prisma.feedbackAssignment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackAssignmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackAssignmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackAssignment.
     * @param {FeedbackAssignmentDeleteArgs} args - Arguments to delete one FeedbackAssignment.
     * @example
     * // Delete one FeedbackAssignment
     * const FeedbackAssignment = await prisma.feedbackAssignment.delete({
     *   where: {
     *     // ... filter to delete one FeedbackAssignment
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackAssignmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackAssignmentDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeedbackAssignment.
     * @param {FeedbackAssignmentUpdateArgs} args - Arguments to update one FeedbackAssignment.
     * @example
     * // Update one FeedbackAssignment
     * const feedbackAssignment = await prisma.feedbackAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackAssignmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackAssignmentUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeedbackAssignments.
     * @param {FeedbackAssignmentDeleteManyArgs} args - Arguments to filter FeedbackAssignments to delete.
     * @example
     * // Delete a few FeedbackAssignments
     * const { count } = await prisma.feedbackAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackAssignmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackAssignmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackAssignments
     * const feedbackAssignment = await prisma.feedbackAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackAssignmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackAssignmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackAssignment.
     * @param {FeedbackAssignmentUpsertArgs} args - Arguments to update or create a FeedbackAssignment.
     * @example
     * // Update or create a FeedbackAssignment
     * const feedbackAssignment = await prisma.feedbackAssignment.upsert({
     *   create: {
     *     // ... data to create a FeedbackAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackAssignment we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackAssignmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackAssignmentUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackAssignmentClient<$Result.GetResult<Prisma.$FeedbackAssignmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeedbackAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentCountArgs} args - Arguments to filter FeedbackAssignments to count.
     * @example
     * // Count the number of FeedbackAssignments
     * const count = await prisma.feedbackAssignment.count({
     *   where: {
     *     // ... the filter for the FeedbackAssignments we want to count
     *   }
     * })
    **/
    count<T extends FeedbackAssignmentCountArgs>(
      args?: Subset<T, FeedbackAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAssignmentAggregateArgs>(args: Subset<T, FeedbackAssignmentAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAssignmentAggregateType<T>>

    /**
     * Group by FeedbackAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackAssignment model
   */
  readonly fields: FeedbackAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    feedback<T extends FeedbackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedbackDefaultArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeedbackAssignment model
   */ 
  interface FeedbackAssignmentFieldRefs {
    readonly id: FieldRef<"FeedbackAssignment", 'Int'>
    readonly assignmentCompleted: FieldRef<"FeedbackAssignment", 'Boolean'>
    readonly feedbackId: FieldRef<"FeedbackAssignment", 'Int'>
    readonly userId: FieldRef<"FeedbackAssignment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * FeedbackAssignment findUnique
   */
  export type FeedbackAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackAssignment to fetch.
     */
    where: FeedbackAssignmentWhereUniqueInput
  }


  /**
   * FeedbackAssignment findUniqueOrThrow
   */
  export type FeedbackAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackAssignment to fetch.
     */
    where: FeedbackAssignmentWhereUniqueInput
  }


  /**
   * FeedbackAssignment findFirst
   */
  export type FeedbackAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackAssignment to fetch.
     */
    where?: FeedbackAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackAssignments to fetch.
     */
    orderBy?: FeedbackAssignmentOrderByWithRelationInput | FeedbackAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackAssignments.
     */
    cursor?: FeedbackAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackAssignments.
     */
    distinct?: FeedbackAssignmentScalarFieldEnum | FeedbackAssignmentScalarFieldEnum[]
  }


  /**
   * FeedbackAssignment findFirstOrThrow
   */
  export type FeedbackAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackAssignment to fetch.
     */
    where?: FeedbackAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackAssignments to fetch.
     */
    orderBy?: FeedbackAssignmentOrderByWithRelationInput | FeedbackAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackAssignments.
     */
    cursor?: FeedbackAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackAssignments.
     */
    distinct?: FeedbackAssignmentScalarFieldEnum | FeedbackAssignmentScalarFieldEnum[]
  }


  /**
   * FeedbackAssignment findMany
   */
  export type FeedbackAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackAssignments to fetch.
     */
    where?: FeedbackAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackAssignments to fetch.
     */
    orderBy?: FeedbackAssignmentOrderByWithRelationInput | FeedbackAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackAssignments.
     */
    cursor?: FeedbackAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackAssignments.
     */
    skip?: number
    distinct?: FeedbackAssignmentScalarFieldEnum | FeedbackAssignmentScalarFieldEnum[]
  }


  /**
   * FeedbackAssignment create
   */
  export type FeedbackAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackAssignment.
     */
    data: XOR<FeedbackAssignmentCreateInput, FeedbackAssignmentUncheckedCreateInput>
  }


  /**
   * FeedbackAssignment createMany
   */
  export type FeedbackAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackAssignments.
     */
    data: FeedbackAssignmentCreateManyInput | FeedbackAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FeedbackAssignment update
   */
  export type FeedbackAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackAssignment.
     */
    data: XOR<FeedbackAssignmentUpdateInput, FeedbackAssignmentUncheckedUpdateInput>
    /**
     * Choose, which FeedbackAssignment to update.
     */
    where: FeedbackAssignmentWhereUniqueInput
  }


  /**
   * FeedbackAssignment updateMany
   */
  export type FeedbackAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackAssignments.
     */
    data: XOR<FeedbackAssignmentUpdateManyMutationInput, FeedbackAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackAssignments to update
     */
    where?: FeedbackAssignmentWhereInput
  }


  /**
   * FeedbackAssignment upsert
   */
  export type FeedbackAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackAssignment to update in case it exists.
     */
    where: FeedbackAssignmentWhereUniqueInput
    /**
     * In case the FeedbackAssignment found by the `where` argument doesn't exist, create a new FeedbackAssignment with this data.
     */
    create: XOR<FeedbackAssignmentCreateInput, FeedbackAssignmentUncheckedCreateInput>
    /**
     * In case the FeedbackAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackAssignmentUpdateInput, FeedbackAssignmentUncheckedUpdateInput>
  }


  /**
   * FeedbackAssignment delete
   */
  export type FeedbackAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
    /**
     * Filter which FeedbackAssignment to delete.
     */
    where: FeedbackAssignmentWhereUniqueInput
  }


  /**
   * FeedbackAssignment deleteMany
   */
  export type FeedbackAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackAssignments to delete
     */
    where?: FeedbackAssignmentWhereInput
  }


  /**
   * FeedbackAssignment without action
   */
  export type FeedbackAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackAssignment
     */
    select?: FeedbackAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackAssignmentInclude<ExtArgs> | null
  }



  /**
   * Model FeedbackFile
   */

  export type AggregateFeedbackFile = {
    _count: FeedbackFileCountAggregateOutputType | null
    _avg: FeedbackFileAvgAggregateOutputType | null
    _sum: FeedbackFileSumAggregateOutputType | null
    _min: FeedbackFileMinAggregateOutputType | null
    _max: FeedbackFileMaxAggregateOutputType | null
  }

  export type FeedbackFileAvgAggregateOutputType = {
    id: number | null
    feedbackId: number | null
  }

  export type FeedbackFileSumAggregateOutputType = {
    id: number | null
    feedbackId: number | null
  }

  export type FeedbackFileMinAggregateOutputType = {
    id: number | null
    name: string | null
    fileType: string | null
    feedbackId: number | null
  }

  export type FeedbackFileMaxAggregateOutputType = {
    id: number | null
    name: string | null
    fileType: string | null
    feedbackId: number | null
  }

  export type FeedbackFileCountAggregateOutputType = {
    id: number
    name: number
    fileType: number
    feedbackId: number
    _all: number
  }


  export type FeedbackFileAvgAggregateInputType = {
    id?: true
    feedbackId?: true
  }

  export type FeedbackFileSumAggregateInputType = {
    id?: true
    feedbackId?: true
  }

  export type FeedbackFileMinAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    feedbackId?: true
  }

  export type FeedbackFileMaxAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    feedbackId?: true
  }

  export type FeedbackFileCountAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    feedbackId?: true
    _all?: true
  }

  export type FeedbackFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackFile to aggregate.
     */
    where?: FeedbackFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackFiles to fetch.
     */
    orderBy?: FeedbackFileOrderByWithRelationInput | FeedbackFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackFiles
    **/
    _count?: true | FeedbackFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackFileMaxAggregateInputType
  }

  export type GetFeedbackFileAggregateType<T extends FeedbackFileAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackFile[P]>
      : GetScalarType<T[P], AggregateFeedbackFile[P]>
  }




  export type FeedbackFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFileWhereInput
    orderBy?: FeedbackFileOrderByWithAggregationInput | FeedbackFileOrderByWithAggregationInput[]
    by: FeedbackFileScalarFieldEnum[] | FeedbackFileScalarFieldEnum
    having?: FeedbackFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackFileCountAggregateInputType | true
    _avg?: FeedbackFileAvgAggregateInputType
    _sum?: FeedbackFileSumAggregateInputType
    _min?: FeedbackFileMinAggregateInputType
    _max?: FeedbackFileMaxAggregateInputType
  }

  export type FeedbackFileGroupByOutputType = {
    id: number
    name: string
    fileType: string
    feedbackId: number
    _count: FeedbackFileCountAggregateOutputType | null
    _avg: FeedbackFileAvgAggregateOutputType | null
    _sum: FeedbackFileSumAggregateOutputType | null
    _min: FeedbackFileMinAggregateOutputType | null
    _max: FeedbackFileMaxAggregateOutputType | null
  }

  type GetFeedbackFileGroupByPayload<T extends FeedbackFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackFileGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackFileGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileType?: boolean
    feedbackId?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackFile"]>

  export type FeedbackFileSelectScalar = {
    id?: boolean
    name?: boolean
    fileType?: boolean
    feedbackId?: boolean
  }

  export type FeedbackFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
  }


  export type $FeedbackFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackFile"
    objects: {
      feedback: Prisma.$FeedbackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      fileType: string
      feedbackId: number
    }, ExtArgs["result"]["feedbackFile"]>
    composites: {}
  }


  type FeedbackFileGetPayload<S extends boolean | null | undefined | FeedbackFileDefaultArgs> = $Result.GetResult<Prisma.$FeedbackFilePayload, S>

  type FeedbackFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FeedbackFileCountAggregateInputType | true
    }

  export interface FeedbackFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackFile'], meta: { name: 'FeedbackFile' } }
    /**
     * Find zero or one FeedbackFile that matches the filter.
     * @param {FeedbackFileFindUniqueArgs} args - Arguments to find a FeedbackFile
     * @example
     * // Get one FeedbackFile
     * const feedbackFile = await prisma.feedbackFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackFileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFileFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeedbackFile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackFileFindUniqueOrThrowArgs} args - Arguments to find a FeedbackFile
     * @example
     * // Get one FeedbackFile
     * const feedbackFile = await prisma.feedbackFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackFileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeedbackFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileFindFirstArgs} args - Arguments to find a FeedbackFile
     * @example
     * // Get one FeedbackFile
     * const feedbackFile = await prisma.feedbackFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackFileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFileFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeedbackFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileFindFirstOrThrowArgs} args - Arguments to find a FeedbackFile
     * @example
     * // Get one FeedbackFile
     * const feedbackFile = await prisma.feedbackFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackFileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeedbackFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackFiles
     * const feedbackFiles = await prisma.feedbackFile.findMany()
     * 
     * // Get first 10 FeedbackFiles
     * const feedbackFiles = await prisma.feedbackFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackFileWithIdOnly = await prisma.feedbackFile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackFileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeedbackFile.
     * @param {FeedbackFileCreateArgs} args - Arguments to create a FeedbackFile.
     * @example
     * // Create one FeedbackFile
     * const FeedbackFile = await prisma.feedbackFile.create({
     *   data: {
     *     // ... data to create a FeedbackFile
     *   }
     * })
     * 
    **/
    create<T extends FeedbackFileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFileCreateArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FeedbackFiles.
     *     @param {FeedbackFileCreateManyArgs} args - Arguments to create many FeedbackFiles.
     *     @example
     *     // Create many FeedbackFiles
     *     const feedbackFile = await prisma.feedbackFile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackFileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackFile.
     * @param {FeedbackFileDeleteArgs} args - Arguments to delete one FeedbackFile.
     * @example
     * // Delete one FeedbackFile
     * const FeedbackFile = await prisma.feedbackFile.delete({
     *   where: {
     *     // ... filter to delete one FeedbackFile
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackFileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFileDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeedbackFile.
     * @param {FeedbackFileUpdateArgs} args - Arguments to update one FeedbackFile.
     * @example
     * // Update one FeedbackFile
     * const feedbackFile = await prisma.feedbackFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackFileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFileUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeedbackFiles.
     * @param {FeedbackFileDeleteManyArgs} args - Arguments to filter FeedbackFiles to delete.
     * @example
     * // Delete a few FeedbackFiles
     * const { count } = await prisma.feedbackFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackFileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackFiles
     * const feedbackFile = await prisma.feedbackFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackFileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackFile.
     * @param {FeedbackFileUpsertArgs} args - Arguments to update or create a FeedbackFile.
     * @example
     * // Update or create a FeedbackFile
     * const feedbackFile = await prisma.feedbackFile.upsert({
     *   create: {
     *     // ... data to create a FeedbackFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackFile we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackFileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFileUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackFileClient<$Result.GetResult<Prisma.$FeedbackFilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeedbackFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileCountArgs} args - Arguments to filter FeedbackFiles to count.
     * @example
     * // Count the number of FeedbackFiles
     * const count = await prisma.feedbackFile.count({
     *   where: {
     *     // ... the filter for the FeedbackFiles we want to count
     *   }
     * })
    **/
    count<T extends FeedbackFileCountArgs>(
      args?: Subset<T, FeedbackFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackFileAggregateArgs>(args: Subset<T, FeedbackFileAggregateArgs>): Prisma.PrismaPromise<GetFeedbackFileAggregateType<T>>

    /**
     * Group by FeedbackFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackFileGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackFile model
   */
  readonly fields: FeedbackFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    feedback<T extends FeedbackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedbackDefaultArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeedbackFile model
   */ 
  interface FeedbackFileFieldRefs {
    readonly id: FieldRef<"FeedbackFile", 'Int'>
    readonly name: FieldRef<"FeedbackFile", 'String'>
    readonly fileType: FieldRef<"FeedbackFile", 'String'>
    readonly feedbackId: FieldRef<"FeedbackFile", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * FeedbackFile findUnique
   */
  export type FeedbackFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackFile to fetch.
     */
    where: FeedbackFileWhereUniqueInput
  }


  /**
   * FeedbackFile findUniqueOrThrow
   */
  export type FeedbackFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackFile to fetch.
     */
    where: FeedbackFileWhereUniqueInput
  }


  /**
   * FeedbackFile findFirst
   */
  export type FeedbackFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackFile to fetch.
     */
    where?: FeedbackFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackFiles to fetch.
     */
    orderBy?: FeedbackFileOrderByWithRelationInput | FeedbackFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackFiles.
     */
    cursor?: FeedbackFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackFiles.
     */
    distinct?: FeedbackFileScalarFieldEnum | FeedbackFileScalarFieldEnum[]
  }


  /**
   * FeedbackFile findFirstOrThrow
   */
  export type FeedbackFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackFile to fetch.
     */
    where?: FeedbackFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackFiles to fetch.
     */
    orderBy?: FeedbackFileOrderByWithRelationInput | FeedbackFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackFiles.
     */
    cursor?: FeedbackFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackFiles.
     */
    distinct?: FeedbackFileScalarFieldEnum | FeedbackFileScalarFieldEnum[]
  }


  /**
   * FeedbackFile findMany
   */
  export type FeedbackFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackFiles to fetch.
     */
    where?: FeedbackFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackFiles to fetch.
     */
    orderBy?: FeedbackFileOrderByWithRelationInput | FeedbackFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackFiles.
     */
    cursor?: FeedbackFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackFiles.
     */
    skip?: number
    distinct?: FeedbackFileScalarFieldEnum | FeedbackFileScalarFieldEnum[]
  }


  /**
   * FeedbackFile create
   */
  export type FeedbackFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackFile.
     */
    data: XOR<FeedbackFileCreateInput, FeedbackFileUncheckedCreateInput>
  }


  /**
   * FeedbackFile createMany
   */
  export type FeedbackFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackFiles.
     */
    data: FeedbackFileCreateManyInput | FeedbackFileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FeedbackFile update
   */
  export type FeedbackFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackFile.
     */
    data: XOR<FeedbackFileUpdateInput, FeedbackFileUncheckedUpdateInput>
    /**
     * Choose, which FeedbackFile to update.
     */
    where: FeedbackFileWhereUniqueInput
  }


  /**
   * FeedbackFile updateMany
   */
  export type FeedbackFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackFiles.
     */
    data: XOR<FeedbackFileUpdateManyMutationInput, FeedbackFileUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackFiles to update
     */
    where?: FeedbackFileWhereInput
  }


  /**
   * FeedbackFile upsert
   */
  export type FeedbackFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackFile to update in case it exists.
     */
    where: FeedbackFileWhereUniqueInput
    /**
     * In case the FeedbackFile found by the `where` argument doesn't exist, create a new FeedbackFile with this data.
     */
    create: XOR<FeedbackFileCreateInput, FeedbackFileUncheckedCreateInput>
    /**
     * In case the FeedbackFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackFileUpdateInput, FeedbackFileUncheckedUpdateInput>
  }


  /**
   * FeedbackFile delete
   */
  export type FeedbackFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
    /**
     * Filter which FeedbackFile to delete.
     */
    where: FeedbackFileWhereUniqueInput
  }


  /**
   * FeedbackFile deleteMany
   */
  export type FeedbackFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackFiles to delete
     */
    where?: FeedbackFileWhereInput
  }


  /**
   * FeedbackFile without action
   */
  export type FeedbackFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackFile
     */
    select?: FeedbackFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackFileInclude<ExtArgs> | null
  }



  /**
   * Model FeedbackActionFile
   */

  export type AggregateFeedbackActionFile = {
    _count: FeedbackActionFileCountAggregateOutputType | null
    _avg: FeedbackActionFileAvgAggregateOutputType | null
    _sum: FeedbackActionFileSumAggregateOutputType | null
    _min: FeedbackActionFileMinAggregateOutputType | null
    _max: FeedbackActionFileMaxAggregateOutputType | null
  }

  export type FeedbackActionFileAvgAggregateOutputType = {
    id: number | null
    feedbackId: number | null
  }

  export type FeedbackActionFileSumAggregateOutputType = {
    id: number | null
    feedbackId: number | null
  }

  export type FeedbackActionFileMinAggregateOutputType = {
    id: number | null
    name: string | null
    fileType: string | null
    feedbackId: number | null
  }

  export type FeedbackActionFileMaxAggregateOutputType = {
    id: number | null
    name: string | null
    fileType: string | null
    feedbackId: number | null
  }

  export type FeedbackActionFileCountAggregateOutputType = {
    id: number
    name: number
    fileType: number
    feedbackId: number
    _all: number
  }


  export type FeedbackActionFileAvgAggregateInputType = {
    id?: true
    feedbackId?: true
  }

  export type FeedbackActionFileSumAggregateInputType = {
    id?: true
    feedbackId?: true
  }

  export type FeedbackActionFileMinAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    feedbackId?: true
  }

  export type FeedbackActionFileMaxAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    feedbackId?: true
  }

  export type FeedbackActionFileCountAggregateInputType = {
    id?: true
    name?: true
    fileType?: true
    feedbackId?: true
    _all?: true
  }

  export type FeedbackActionFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackActionFile to aggregate.
     */
    where?: FeedbackActionFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackActionFiles to fetch.
     */
    orderBy?: FeedbackActionFileOrderByWithRelationInput | FeedbackActionFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackActionFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackActionFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackActionFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackActionFiles
    **/
    _count?: true | FeedbackActionFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackActionFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackActionFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackActionFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackActionFileMaxAggregateInputType
  }

  export type GetFeedbackActionFileAggregateType<T extends FeedbackActionFileAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackActionFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackActionFile[P]>
      : GetScalarType<T[P], AggregateFeedbackActionFile[P]>
  }




  export type FeedbackActionFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackActionFileWhereInput
    orderBy?: FeedbackActionFileOrderByWithAggregationInput | FeedbackActionFileOrderByWithAggregationInput[]
    by: FeedbackActionFileScalarFieldEnum[] | FeedbackActionFileScalarFieldEnum
    having?: FeedbackActionFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackActionFileCountAggregateInputType | true
    _avg?: FeedbackActionFileAvgAggregateInputType
    _sum?: FeedbackActionFileSumAggregateInputType
    _min?: FeedbackActionFileMinAggregateInputType
    _max?: FeedbackActionFileMaxAggregateInputType
  }

  export type FeedbackActionFileGroupByOutputType = {
    id: number
    name: string
    fileType: string
    feedbackId: number
    _count: FeedbackActionFileCountAggregateOutputType | null
    _avg: FeedbackActionFileAvgAggregateOutputType | null
    _sum: FeedbackActionFileSumAggregateOutputType | null
    _min: FeedbackActionFileMinAggregateOutputType | null
    _max: FeedbackActionFileMaxAggregateOutputType | null
  }

  type GetFeedbackActionFileGroupByPayload<T extends FeedbackActionFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackActionFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackActionFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackActionFileGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackActionFileGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackActionFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileType?: boolean
    feedbackId?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackActionFile"]>

  export type FeedbackActionFileSelectScalar = {
    id?: boolean
    name?: boolean
    fileType?: boolean
    feedbackId?: boolean
  }

  export type FeedbackActionFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
  }


  export type $FeedbackActionFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackActionFile"
    objects: {
      feedback: Prisma.$FeedbackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      fileType: string
      feedbackId: number
    }, ExtArgs["result"]["feedbackActionFile"]>
    composites: {}
  }


  type FeedbackActionFileGetPayload<S extends boolean | null | undefined | FeedbackActionFileDefaultArgs> = $Result.GetResult<Prisma.$FeedbackActionFilePayload, S>

  type FeedbackActionFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackActionFileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FeedbackActionFileCountAggregateInputType | true
    }

  export interface FeedbackActionFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackActionFile'], meta: { name: 'FeedbackActionFile' } }
    /**
     * Find zero or one FeedbackActionFile that matches the filter.
     * @param {FeedbackActionFileFindUniqueArgs} args - Arguments to find a FeedbackActionFile
     * @example
     * // Get one FeedbackActionFile
     * const feedbackActionFile = await prisma.feedbackActionFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackActionFileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackActionFileFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FeedbackActionFile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackActionFileFindUniqueOrThrowArgs} args - Arguments to find a FeedbackActionFile
     * @example
     * // Get one FeedbackActionFile
     * const feedbackActionFile = await prisma.feedbackActionFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackActionFileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackActionFileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FeedbackActionFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileFindFirstArgs} args - Arguments to find a FeedbackActionFile
     * @example
     * // Get one FeedbackActionFile
     * const feedbackActionFile = await prisma.feedbackActionFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackActionFileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackActionFileFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FeedbackActionFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileFindFirstOrThrowArgs} args - Arguments to find a FeedbackActionFile
     * @example
     * // Get one FeedbackActionFile
     * const feedbackActionFile = await prisma.feedbackActionFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackActionFileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackActionFileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FeedbackActionFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackActionFiles
     * const feedbackActionFiles = await prisma.feedbackActionFile.findMany()
     * 
     * // Get first 10 FeedbackActionFiles
     * const feedbackActionFiles = await prisma.feedbackActionFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackActionFileWithIdOnly = await prisma.feedbackActionFile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackActionFileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackActionFileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FeedbackActionFile.
     * @param {FeedbackActionFileCreateArgs} args - Arguments to create a FeedbackActionFile.
     * @example
     * // Create one FeedbackActionFile
     * const FeedbackActionFile = await prisma.feedbackActionFile.create({
     *   data: {
     *     // ... data to create a FeedbackActionFile
     *   }
     * })
     * 
    **/
    create<T extends FeedbackActionFileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackActionFileCreateArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FeedbackActionFiles.
     *     @param {FeedbackActionFileCreateManyArgs} args - Arguments to create many FeedbackActionFiles.
     *     @example
     *     // Create many FeedbackActionFiles
     *     const feedbackActionFile = await prisma.feedbackActionFile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackActionFileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackActionFileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackActionFile.
     * @param {FeedbackActionFileDeleteArgs} args - Arguments to delete one FeedbackActionFile.
     * @example
     * // Delete one FeedbackActionFile
     * const FeedbackActionFile = await prisma.feedbackActionFile.delete({
     *   where: {
     *     // ... filter to delete one FeedbackActionFile
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackActionFileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackActionFileDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FeedbackActionFile.
     * @param {FeedbackActionFileUpdateArgs} args - Arguments to update one FeedbackActionFile.
     * @example
     * // Update one FeedbackActionFile
     * const feedbackActionFile = await prisma.feedbackActionFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackActionFileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackActionFileUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FeedbackActionFiles.
     * @param {FeedbackActionFileDeleteManyArgs} args - Arguments to filter FeedbackActionFiles to delete.
     * @example
     * // Delete a few FeedbackActionFiles
     * const { count } = await prisma.feedbackActionFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackActionFileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackActionFileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackActionFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackActionFiles
     * const feedbackActionFile = await prisma.feedbackActionFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackActionFileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackActionFileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackActionFile.
     * @param {FeedbackActionFileUpsertArgs} args - Arguments to update or create a FeedbackActionFile.
     * @example
     * // Update or create a FeedbackActionFile
     * const feedbackActionFile = await prisma.feedbackActionFile.upsert({
     *   create: {
     *     // ... data to create a FeedbackActionFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackActionFile we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackActionFileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackActionFileUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackActionFileClient<$Result.GetResult<Prisma.$FeedbackActionFilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FeedbackActionFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileCountArgs} args - Arguments to filter FeedbackActionFiles to count.
     * @example
     * // Count the number of FeedbackActionFiles
     * const count = await prisma.feedbackActionFile.count({
     *   where: {
     *     // ... the filter for the FeedbackActionFiles we want to count
     *   }
     * })
    **/
    count<T extends FeedbackActionFileCountArgs>(
      args?: Subset<T, FeedbackActionFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackActionFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackActionFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackActionFileAggregateArgs>(args: Subset<T, FeedbackActionFileAggregateArgs>): Prisma.PrismaPromise<GetFeedbackActionFileAggregateType<T>>

    /**
     * Group by FeedbackActionFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackActionFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackActionFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackActionFileGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackActionFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackActionFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackActionFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackActionFile model
   */
  readonly fields: FeedbackActionFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackActionFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackActionFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    feedback<T extends FeedbackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedbackDefaultArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FeedbackActionFile model
   */ 
  interface FeedbackActionFileFieldRefs {
    readonly id: FieldRef<"FeedbackActionFile", 'Int'>
    readonly name: FieldRef<"FeedbackActionFile", 'String'>
    readonly fileType: FieldRef<"FeedbackActionFile", 'String'>
    readonly feedbackId: FieldRef<"FeedbackActionFile", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * FeedbackActionFile findUnique
   */
  export type FeedbackActionFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackActionFile to fetch.
     */
    where: FeedbackActionFileWhereUniqueInput
  }


  /**
   * FeedbackActionFile findUniqueOrThrow
   */
  export type FeedbackActionFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackActionFile to fetch.
     */
    where: FeedbackActionFileWhereUniqueInput
  }


  /**
   * FeedbackActionFile findFirst
   */
  export type FeedbackActionFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackActionFile to fetch.
     */
    where?: FeedbackActionFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackActionFiles to fetch.
     */
    orderBy?: FeedbackActionFileOrderByWithRelationInput | FeedbackActionFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackActionFiles.
     */
    cursor?: FeedbackActionFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackActionFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackActionFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackActionFiles.
     */
    distinct?: FeedbackActionFileScalarFieldEnum | FeedbackActionFileScalarFieldEnum[]
  }


  /**
   * FeedbackActionFile findFirstOrThrow
   */
  export type FeedbackActionFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackActionFile to fetch.
     */
    where?: FeedbackActionFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackActionFiles to fetch.
     */
    orderBy?: FeedbackActionFileOrderByWithRelationInput | FeedbackActionFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackActionFiles.
     */
    cursor?: FeedbackActionFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackActionFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackActionFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackActionFiles.
     */
    distinct?: FeedbackActionFileScalarFieldEnum | FeedbackActionFileScalarFieldEnum[]
  }


  /**
   * FeedbackActionFile findMany
   */
  export type FeedbackActionFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackActionFiles to fetch.
     */
    where?: FeedbackActionFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackActionFiles to fetch.
     */
    orderBy?: FeedbackActionFileOrderByWithRelationInput | FeedbackActionFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackActionFiles.
     */
    cursor?: FeedbackActionFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackActionFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackActionFiles.
     */
    skip?: number
    distinct?: FeedbackActionFileScalarFieldEnum | FeedbackActionFileScalarFieldEnum[]
  }


  /**
   * FeedbackActionFile create
   */
  export type FeedbackActionFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackActionFile.
     */
    data: XOR<FeedbackActionFileCreateInput, FeedbackActionFileUncheckedCreateInput>
  }


  /**
   * FeedbackActionFile createMany
   */
  export type FeedbackActionFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackActionFiles.
     */
    data: FeedbackActionFileCreateManyInput | FeedbackActionFileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FeedbackActionFile update
   */
  export type FeedbackActionFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackActionFile.
     */
    data: XOR<FeedbackActionFileUpdateInput, FeedbackActionFileUncheckedUpdateInput>
    /**
     * Choose, which FeedbackActionFile to update.
     */
    where: FeedbackActionFileWhereUniqueInput
  }


  /**
   * FeedbackActionFile updateMany
   */
  export type FeedbackActionFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackActionFiles.
     */
    data: XOR<FeedbackActionFileUpdateManyMutationInput, FeedbackActionFileUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackActionFiles to update
     */
    where?: FeedbackActionFileWhereInput
  }


  /**
   * FeedbackActionFile upsert
   */
  export type FeedbackActionFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackActionFile to update in case it exists.
     */
    where: FeedbackActionFileWhereUniqueInput
    /**
     * In case the FeedbackActionFile found by the `where` argument doesn't exist, create a new FeedbackActionFile with this data.
     */
    create: XOR<FeedbackActionFileCreateInput, FeedbackActionFileUncheckedCreateInput>
    /**
     * In case the FeedbackActionFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackActionFileUpdateInput, FeedbackActionFileUncheckedUpdateInput>
  }


  /**
   * FeedbackActionFile delete
   */
  export type FeedbackActionFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
    /**
     * Filter which FeedbackActionFile to delete.
     */
    where: FeedbackActionFileWhereUniqueInput
  }


  /**
   * FeedbackActionFile deleteMany
   */
  export type FeedbackActionFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackActionFiles to delete
     */
    where?: FeedbackActionFileWhereInput
  }


  /**
   * FeedbackActionFile without action
   */
  export type FeedbackActionFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackActionFile
     */
    select?: FeedbackActionFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackActionFileInclude<ExtArgs> | null
  }



  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    meetingId: number | null
    meetingTime: number | null
    createrId: number | null
    membersCount: number | null
    attId: number | null
  }

  export type MeetingSumAggregateOutputType = {
    meetingId: number | null
    meetingTime: number | null
    createrId: number | null
    membersCount: number | null
    attId: number | null
  }

  export type MeetingMinAggregateOutputType = {
    meetingId: number | null
    meetCreater: string | null
    meetDateTime: Date | null
    meetTitle: string | null
    meetingTime: number | null
    department: string | null
    createrId: number | null
    membersCount: number | null
    isOnline: boolean | null
    attId: number | null
    meetEndTime: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    meetingId: number | null
    meetCreater: string | null
    meetDateTime: Date | null
    meetTitle: string | null
    meetingTime: number | null
    department: string | null
    createrId: number | null
    membersCount: number | null
    isOnline: boolean | null
    attId: number | null
    meetEndTime: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    meetingId: number
    meetCreater: number
    meetDateTime: number
    meetTitle: number
    meetingTime: number
    department: number
    createrId: number
    membersCount: number
    isOnline: number
    attId: number
    meetEndTime: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    meetingId?: true
    meetingTime?: true
    createrId?: true
    membersCount?: true
    attId?: true
  }

  export type MeetingSumAggregateInputType = {
    meetingId?: true
    meetingTime?: true
    createrId?: true
    membersCount?: true
    attId?: true
  }

  export type MeetingMinAggregateInputType = {
    meetingId?: true
    meetCreater?: true
    meetDateTime?: true
    meetTitle?: true
    meetingTime?: true
    department?: true
    createrId?: true
    membersCount?: true
    isOnline?: true
    attId?: true
    meetEndTime?: true
  }

  export type MeetingMaxAggregateInputType = {
    meetingId?: true
    meetCreater?: true
    meetDateTime?: true
    meetTitle?: true
    meetingTime?: true
    department?: true
    createrId?: true
    membersCount?: true
    isOnline?: true
    attId?: true
    meetEndTime?: true
  }

  export type MeetingCountAggregateInputType = {
    meetingId?: true
    meetCreater?: true
    meetDateTime?: true
    meetTitle?: true
    meetingTime?: true
    department?: true
    createrId?: true
    membersCount?: true
    isOnline?: true
    attId?: true
    meetEndTime?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    meetingId: number
    meetCreater: string
    meetDateTime: Date
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId: number | null
    meetEndTime: Date
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    meetingId?: boolean
    meetCreater?: boolean
    meetDateTime?: boolean
    meetTitle?: boolean
    meetingTime?: boolean
    department?: boolean
    createrId?: boolean
    membersCount?: boolean
    isOnline?: boolean
    attId?: boolean
    meetEndTime?: boolean
    membersList?: boolean | Meeting$membersListArgs<ExtArgs>
    membersAttended?: boolean | Meeting$membersAttendedArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    meetingId?: boolean
    meetCreater?: boolean
    meetDateTime?: boolean
    meetTitle?: boolean
    meetingTime?: boolean
    department?: boolean
    createrId?: boolean
    membersCount?: boolean
    isOnline?: boolean
    attId?: boolean
    meetEndTime?: boolean
  }

  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membersList?: boolean | Meeting$membersListArgs<ExtArgs>
    membersAttended?: boolean | Meeting$membersAttendedArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      membersList: Prisma.$MembersListPayload<ExtArgs>[]
      membersAttended: Prisma.$MembersAttendedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      meetingId: number
      meetCreater: string
      meetDateTime: Date
      meetTitle: string
      meetingTime: number
      department: string
      createrId: number
      membersCount: number
      isOnline: boolean
      attId: number | null
      meetEndTime: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }


  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MeetingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Meeting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MeetingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `meetingId`
     * const meetingWithMeetingIdOnly = await prisma.meeting.findMany({ select: { meetingId: true } })
     * 
    **/
    findMany<T extends MeetingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
    **/
    create<T extends MeetingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Meetings.
     *     @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     *     @example
     *     // Create many Meetings
     *     const meeting = await prisma.meeting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MeetingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
    **/
    delete<T extends MeetingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MeetingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MeetingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MeetingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
    **/
    upsert<T extends MeetingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>
    ): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    membersList<T extends Meeting$membersListArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$membersListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'findMany'> | Null>;

    membersAttended<T extends Meeting$membersAttendedArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$membersAttendedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Meeting model
   */ 
  interface MeetingFieldRefs {
    readonly meetingId: FieldRef<"Meeting", 'Int'>
    readonly meetCreater: FieldRef<"Meeting", 'String'>
    readonly meetDateTime: FieldRef<"Meeting", 'DateTime'>
    readonly meetTitle: FieldRef<"Meeting", 'String'>
    readonly meetingTime: FieldRef<"Meeting", 'Int'>
    readonly department: FieldRef<"Meeting", 'String'>
    readonly createrId: FieldRef<"Meeting", 'Int'>
    readonly membersCount: FieldRef<"Meeting", 'Int'>
    readonly isOnline: FieldRef<"Meeting", 'Boolean'>
    readonly attId: FieldRef<"Meeting", 'Int'>
    readonly meetEndTime: FieldRef<"Meeting", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }


  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }


  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }


  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }


  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }


  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }


  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }


  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
  }


  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }


  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }


  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
  }


  /**
   * Meeting.membersList
   */
  export type Meeting$membersListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    where?: MembersListWhereInput
    orderBy?: MembersListOrderByWithRelationInput | MembersListOrderByWithRelationInput[]
    cursor?: MembersListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembersListScalarFieldEnum | MembersListScalarFieldEnum[]
  }


  /**
   * Meeting.membersAttended
   */
  export type Meeting$membersAttendedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    where?: MembersAttendedWhereInput
    orderBy?: MembersAttendedOrderByWithRelationInput | MembersAttendedOrderByWithRelationInput[]
    cursor?: MembersAttendedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembersAttendedScalarFieldEnum | MembersAttendedScalarFieldEnum[]
  }


  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeetingInclude<ExtArgs> | null
  }



  /**
   * Model MembersList
   */

  export type AggregateMembersList = {
    _count: MembersListCountAggregateOutputType | null
    _avg: MembersListAvgAggregateOutputType | null
    _sum: MembersListSumAggregateOutputType | null
    _min: MembersListMinAggregateOutputType | null
    _max: MembersListMaxAggregateOutputType | null
  }

  export type MembersListAvgAggregateOutputType = {
    id: number | null
    meetingId: number | null
  }

  export type MembersListSumAggregateOutputType = {
    id: number | null
    meetingId: number | null
  }

  export type MembersListMinAggregateOutputType = {
    id: number | null
    memberId: string | null
    memberName: string | null
    meetingId: number | null
  }

  export type MembersListMaxAggregateOutputType = {
    id: number | null
    memberId: string | null
    memberName: string | null
    meetingId: number | null
  }

  export type MembersListCountAggregateOutputType = {
    id: number
    memberId: number
    memberName: number
    meetingId: number
    _all: number
  }


  export type MembersListAvgAggregateInputType = {
    id?: true
    meetingId?: true
  }

  export type MembersListSumAggregateInputType = {
    id?: true
    meetingId?: true
  }

  export type MembersListMinAggregateInputType = {
    id?: true
    memberId?: true
    memberName?: true
    meetingId?: true
  }

  export type MembersListMaxAggregateInputType = {
    id?: true
    memberId?: true
    memberName?: true
    meetingId?: true
  }

  export type MembersListCountAggregateInputType = {
    id?: true
    memberId?: true
    memberName?: true
    meetingId?: true
    _all?: true
  }

  export type MembersListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembersList to aggregate.
     */
    where?: MembersListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersLists to fetch.
     */
    orderBy?: MembersListOrderByWithRelationInput | MembersListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembersListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembersLists
    **/
    _count?: true | MembersListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembersListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembersListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembersListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembersListMaxAggregateInputType
  }

  export type GetMembersListAggregateType<T extends MembersListAggregateArgs> = {
        [P in keyof T & keyof AggregateMembersList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembersList[P]>
      : GetScalarType<T[P], AggregateMembersList[P]>
  }




  export type MembersListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersListWhereInput
    orderBy?: MembersListOrderByWithAggregationInput | MembersListOrderByWithAggregationInput[]
    by: MembersListScalarFieldEnum[] | MembersListScalarFieldEnum
    having?: MembersListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembersListCountAggregateInputType | true
    _avg?: MembersListAvgAggregateInputType
    _sum?: MembersListSumAggregateInputType
    _min?: MembersListMinAggregateInputType
    _max?: MembersListMaxAggregateInputType
  }

  export type MembersListGroupByOutputType = {
    id: number
    memberId: string
    memberName: string
    meetingId: number
    _count: MembersListCountAggregateOutputType | null
    _avg: MembersListAvgAggregateOutputType | null
    _sum: MembersListSumAggregateOutputType | null
    _min: MembersListMinAggregateOutputType | null
    _max: MembersListMaxAggregateOutputType | null
  }

  type GetMembersListGroupByPayload<T extends MembersListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembersListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembersListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembersListGroupByOutputType[P]>
            : GetScalarType<T[P], MembersListGroupByOutputType[P]>
        }
      >
    >


  export type MembersListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    memberName?: boolean
    meetingId?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membersList"]>

  export type MembersListSelectScalar = {
    id?: boolean
    memberId?: boolean
    memberName?: boolean
    meetingId?: boolean
  }

  export type MembersListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
  }


  export type $MembersListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembersList"
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memberId: string
      memberName: string
      meetingId: number
    }, ExtArgs["result"]["membersList"]>
    composites: {}
  }


  type MembersListGetPayload<S extends boolean | null | undefined | MembersListDefaultArgs> = $Result.GetResult<Prisma.$MembersListPayload, S>

  type MembersListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembersListFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MembersListCountAggregateInputType | true
    }

  export interface MembersListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembersList'], meta: { name: 'MembersList' } }
    /**
     * Find zero or one MembersList that matches the filter.
     * @param {MembersListFindUniqueArgs} args - Arguments to find a MembersList
     * @example
     * // Get one MembersList
     * const membersList = await prisma.membersList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MembersListFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MembersListFindUniqueArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MembersList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MembersListFindUniqueOrThrowArgs} args - Arguments to find a MembersList
     * @example
     * // Get one MembersList
     * const membersList = await prisma.membersList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MembersListFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersListFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MembersList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListFindFirstArgs} args - Arguments to find a MembersList
     * @example
     * // Get one MembersList
     * const membersList = await prisma.membersList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MembersListFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersListFindFirstArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MembersList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListFindFirstOrThrowArgs} args - Arguments to find a MembersList
     * @example
     * // Get one MembersList
     * const membersList = await prisma.membersList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MembersListFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersListFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MembersLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembersLists
     * const membersLists = await prisma.membersList.findMany()
     * 
     * // Get first 10 MembersLists
     * const membersLists = await prisma.membersList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membersListWithIdOnly = await prisma.membersList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MembersListFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersListFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MembersList.
     * @param {MembersListCreateArgs} args - Arguments to create a MembersList.
     * @example
     * // Create one MembersList
     * const MembersList = await prisma.membersList.create({
     *   data: {
     *     // ... data to create a MembersList
     *   }
     * })
     * 
    **/
    create<T extends MembersListCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MembersListCreateArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MembersLists.
     *     @param {MembersListCreateManyArgs} args - Arguments to create many MembersLists.
     *     @example
     *     // Create many MembersLists
     *     const membersList = await prisma.membersList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MembersListCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersListCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MembersList.
     * @param {MembersListDeleteArgs} args - Arguments to delete one MembersList.
     * @example
     * // Delete one MembersList
     * const MembersList = await prisma.membersList.delete({
     *   where: {
     *     // ... filter to delete one MembersList
     *   }
     * })
     * 
    **/
    delete<T extends MembersListDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MembersListDeleteArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MembersList.
     * @param {MembersListUpdateArgs} args - Arguments to update one MembersList.
     * @example
     * // Update one MembersList
     * const membersList = await prisma.membersList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MembersListUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MembersListUpdateArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MembersLists.
     * @param {MembersListDeleteManyArgs} args - Arguments to filter MembersLists to delete.
     * @example
     * // Delete a few MembersLists
     * const { count } = await prisma.membersList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MembersListDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersListDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembersLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembersLists
     * const membersList = await prisma.membersList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MembersListUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MembersListUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MembersList.
     * @param {MembersListUpsertArgs} args - Arguments to update or create a MembersList.
     * @example
     * // Update or create a MembersList
     * const membersList = await prisma.membersList.upsert({
     *   create: {
     *     // ... data to create a MembersList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembersList we want to update
     *   }
     * })
    **/
    upsert<T extends MembersListUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MembersListUpsertArgs<ExtArgs>>
    ): Prisma__MembersListClient<$Result.GetResult<Prisma.$MembersListPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MembersLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListCountArgs} args - Arguments to filter MembersLists to count.
     * @example
     * // Count the number of MembersLists
     * const count = await prisma.membersList.count({
     *   where: {
     *     // ... the filter for the MembersLists we want to count
     *   }
     * })
    **/
    count<T extends MembersListCountArgs>(
      args?: Subset<T, MembersListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembersListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembersList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembersListAggregateArgs>(args: Subset<T, MembersListAggregateArgs>): Prisma.PrismaPromise<GetMembersListAggregateType<T>>

    /**
     * Group by MembersList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembersListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembersListGroupByArgs['orderBy'] }
        : { orderBy?: MembersListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembersListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembersListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembersList model
   */
  readonly fields: MembersListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembersList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembersListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MembersList model
   */ 
  interface MembersListFieldRefs {
    readonly id: FieldRef<"MembersList", 'Int'>
    readonly memberId: FieldRef<"MembersList", 'String'>
    readonly memberName: FieldRef<"MembersList", 'String'>
    readonly meetingId: FieldRef<"MembersList", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MembersList findUnique
   */
  export type MembersListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * Filter, which MembersList to fetch.
     */
    where: MembersListWhereUniqueInput
  }


  /**
   * MembersList findUniqueOrThrow
   */
  export type MembersListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * Filter, which MembersList to fetch.
     */
    where: MembersListWhereUniqueInput
  }


  /**
   * MembersList findFirst
   */
  export type MembersListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * Filter, which MembersList to fetch.
     */
    where?: MembersListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersLists to fetch.
     */
    orderBy?: MembersListOrderByWithRelationInput | MembersListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembersLists.
     */
    cursor?: MembersListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembersLists.
     */
    distinct?: MembersListScalarFieldEnum | MembersListScalarFieldEnum[]
  }


  /**
   * MembersList findFirstOrThrow
   */
  export type MembersListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * Filter, which MembersList to fetch.
     */
    where?: MembersListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersLists to fetch.
     */
    orderBy?: MembersListOrderByWithRelationInput | MembersListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembersLists.
     */
    cursor?: MembersListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembersLists.
     */
    distinct?: MembersListScalarFieldEnum | MembersListScalarFieldEnum[]
  }


  /**
   * MembersList findMany
   */
  export type MembersListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * Filter, which MembersLists to fetch.
     */
    where?: MembersListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersLists to fetch.
     */
    orderBy?: MembersListOrderByWithRelationInput | MembersListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembersLists.
     */
    cursor?: MembersListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersLists.
     */
    skip?: number
    distinct?: MembersListScalarFieldEnum | MembersListScalarFieldEnum[]
  }


  /**
   * MembersList create
   */
  export type MembersListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * The data needed to create a MembersList.
     */
    data: XOR<MembersListCreateInput, MembersListUncheckedCreateInput>
  }


  /**
   * MembersList createMany
   */
  export type MembersListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembersLists.
     */
    data: MembersListCreateManyInput | MembersListCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MembersList update
   */
  export type MembersListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * The data needed to update a MembersList.
     */
    data: XOR<MembersListUpdateInput, MembersListUncheckedUpdateInput>
    /**
     * Choose, which MembersList to update.
     */
    where: MembersListWhereUniqueInput
  }


  /**
   * MembersList updateMany
   */
  export type MembersListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembersLists.
     */
    data: XOR<MembersListUpdateManyMutationInput, MembersListUncheckedUpdateManyInput>
    /**
     * Filter which MembersLists to update
     */
    where?: MembersListWhereInput
  }


  /**
   * MembersList upsert
   */
  export type MembersListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * The filter to search for the MembersList to update in case it exists.
     */
    where: MembersListWhereUniqueInput
    /**
     * In case the MembersList found by the `where` argument doesn't exist, create a new MembersList with this data.
     */
    create: XOR<MembersListCreateInput, MembersListUncheckedCreateInput>
    /**
     * In case the MembersList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembersListUpdateInput, MembersListUncheckedUpdateInput>
  }


  /**
   * MembersList delete
   */
  export type MembersListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
    /**
     * Filter which MembersList to delete.
     */
    where: MembersListWhereUniqueInput
  }


  /**
   * MembersList deleteMany
   */
  export type MembersListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembersLists to delete
     */
    where?: MembersListWhereInput
  }


  /**
   * MembersList without action
   */
  export type MembersListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersList
     */
    select?: MembersListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersListInclude<ExtArgs> | null
  }



  /**
   * Model MembersAttended
   */

  export type AggregateMembersAttended = {
    _count: MembersAttendedCountAggregateOutputType | null
    _avg: MembersAttendedAvgAggregateOutputType | null
    _sum: MembersAttendedSumAggregateOutputType | null
    _min: MembersAttendedMinAggregateOutputType | null
    _max: MembersAttendedMaxAggregateOutputType | null
  }

  export type MembersAttendedAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    meetingId: number | null
  }

  export type MembersAttendedSumAggregateOutputType = {
    id: number | null
    memberId: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    meetingId: number | null
  }

  export type MembersAttendedMinAggregateOutputType = {
    id: number | null
    memberId: number | null
    membersName: string | null
    memberInTime: Date | null
    memberOutTime: Date | null
    dateTime: Date | null
    latitude: Decimal | null
    longitude: Decimal | null
    meetingId: number | null
  }

  export type MembersAttendedMaxAggregateOutputType = {
    id: number | null
    memberId: number | null
    membersName: string | null
    memberInTime: Date | null
    memberOutTime: Date | null
    dateTime: Date | null
    latitude: Decimal | null
    longitude: Decimal | null
    meetingId: number | null
  }

  export type MembersAttendedCountAggregateOutputType = {
    id: number
    memberId: number
    membersName: number
    memberInTime: number
    memberOutTime: number
    dateTime: number
    latitude: number
    longitude: number
    meetingId: number
    _all: number
  }


  export type MembersAttendedAvgAggregateInputType = {
    id?: true
    memberId?: true
    latitude?: true
    longitude?: true
    meetingId?: true
  }

  export type MembersAttendedSumAggregateInputType = {
    id?: true
    memberId?: true
    latitude?: true
    longitude?: true
    meetingId?: true
  }

  export type MembersAttendedMinAggregateInputType = {
    id?: true
    memberId?: true
    membersName?: true
    memberInTime?: true
    memberOutTime?: true
    dateTime?: true
    latitude?: true
    longitude?: true
    meetingId?: true
  }

  export type MembersAttendedMaxAggregateInputType = {
    id?: true
    memberId?: true
    membersName?: true
    memberInTime?: true
    memberOutTime?: true
    dateTime?: true
    latitude?: true
    longitude?: true
    meetingId?: true
  }

  export type MembersAttendedCountAggregateInputType = {
    id?: true
    memberId?: true
    membersName?: true
    memberInTime?: true
    memberOutTime?: true
    dateTime?: true
    latitude?: true
    longitude?: true
    meetingId?: true
    _all?: true
  }

  export type MembersAttendedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembersAttended to aggregate.
     */
    where?: MembersAttendedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersAttendeds to fetch.
     */
    orderBy?: MembersAttendedOrderByWithRelationInput | MembersAttendedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembersAttendedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersAttendeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersAttendeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembersAttendeds
    **/
    _count?: true | MembersAttendedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembersAttendedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembersAttendedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembersAttendedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembersAttendedMaxAggregateInputType
  }

  export type GetMembersAttendedAggregateType<T extends MembersAttendedAggregateArgs> = {
        [P in keyof T & keyof AggregateMembersAttended]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembersAttended[P]>
      : GetScalarType<T[P], AggregateMembersAttended[P]>
  }




  export type MembersAttendedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersAttendedWhereInput
    orderBy?: MembersAttendedOrderByWithAggregationInput | MembersAttendedOrderByWithAggregationInput[]
    by: MembersAttendedScalarFieldEnum[] | MembersAttendedScalarFieldEnum
    having?: MembersAttendedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembersAttendedCountAggregateInputType | true
    _avg?: MembersAttendedAvgAggregateInputType
    _sum?: MembersAttendedSumAggregateInputType
    _min?: MembersAttendedMinAggregateInputType
    _max?: MembersAttendedMaxAggregateInputType
  }

  export type MembersAttendedGroupByOutputType = {
    id: number
    memberId: number
    membersName: string
    memberInTime: Date
    memberOutTime: Date
    dateTime: Date
    latitude: Decimal
    longitude: Decimal
    meetingId: number
    _count: MembersAttendedCountAggregateOutputType | null
    _avg: MembersAttendedAvgAggregateOutputType | null
    _sum: MembersAttendedSumAggregateOutputType | null
    _min: MembersAttendedMinAggregateOutputType | null
    _max: MembersAttendedMaxAggregateOutputType | null
  }

  type GetMembersAttendedGroupByPayload<T extends MembersAttendedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembersAttendedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembersAttendedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembersAttendedGroupByOutputType[P]>
            : GetScalarType<T[P], MembersAttendedGroupByOutputType[P]>
        }
      >
    >


  export type MembersAttendedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    membersName?: boolean
    memberInTime?: boolean
    memberOutTime?: boolean
    dateTime?: boolean
    latitude?: boolean
    longitude?: boolean
    meetingId?: boolean
    digitalSignatureFile?: boolean | DigitalSignatureFileDefaultArgs<ExtArgs>
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membersAttended"]>

  export type MembersAttendedSelectScalar = {
    id?: boolean
    memberId?: boolean
    membersName?: boolean
    memberInTime?: boolean
    memberOutTime?: boolean
    dateTime?: boolean
    latitude?: boolean
    longitude?: boolean
    meetingId?: boolean
  }

  export type MembersAttendedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    digitalSignatureFile?: boolean | DigitalSignatureFileDefaultArgs<ExtArgs>
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
  }


  export type $MembersAttendedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembersAttended"
    objects: {
      digitalSignatureFile: Prisma.$DigitalSignatureFilePayload<ExtArgs> | null
      meeting: Prisma.$MeetingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      memberId: number
      membersName: string
      memberInTime: Date
      memberOutTime: Date
      dateTime: Date
      latitude: Prisma.Decimal
      longitude: Prisma.Decimal
      meetingId: number
    }, ExtArgs["result"]["membersAttended"]>
    composites: {}
  }


  type MembersAttendedGetPayload<S extends boolean | null | undefined | MembersAttendedDefaultArgs> = $Result.GetResult<Prisma.$MembersAttendedPayload, S>

  type MembersAttendedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembersAttendedFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MembersAttendedCountAggregateInputType | true
    }

  export interface MembersAttendedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembersAttended'], meta: { name: 'MembersAttended' } }
    /**
     * Find zero or one MembersAttended that matches the filter.
     * @param {MembersAttendedFindUniqueArgs} args - Arguments to find a MembersAttended
     * @example
     * // Get one MembersAttended
     * const membersAttended = await prisma.membersAttended.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MembersAttendedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MembersAttendedFindUniqueArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MembersAttended that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MembersAttendedFindUniqueOrThrowArgs} args - Arguments to find a MembersAttended
     * @example
     * // Get one MembersAttended
     * const membersAttended = await prisma.membersAttended.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MembersAttendedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersAttendedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MembersAttended that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedFindFirstArgs} args - Arguments to find a MembersAttended
     * @example
     * // Get one MembersAttended
     * const membersAttended = await prisma.membersAttended.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MembersAttendedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersAttendedFindFirstArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MembersAttended that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedFindFirstOrThrowArgs} args - Arguments to find a MembersAttended
     * @example
     * // Get one MembersAttended
     * const membersAttended = await prisma.membersAttended.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MembersAttendedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersAttendedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MembersAttendeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembersAttendeds
     * const membersAttendeds = await prisma.membersAttended.findMany()
     * 
     * // Get first 10 MembersAttendeds
     * const membersAttendeds = await prisma.membersAttended.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membersAttendedWithIdOnly = await prisma.membersAttended.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MembersAttendedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersAttendedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MembersAttended.
     * @param {MembersAttendedCreateArgs} args - Arguments to create a MembersAttended.
     * @example
     * // Create one MembersAttended
     * const MembersAttended = await prisma.membersAttended.create({
     *   data: {
     *     // ... data to create a MembersAttended
     *   }
     * })
     * 
    **/
    create<T extends MembersAttendedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MembersAttendedCreateArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MembersAttendeds.
     *     @param {MembersAttendedCreateManyArgs} args - Arguments to create many MembersAttendeds.
     *     @example
     *     // Create many MembersAttendeds
     *     const membersAttended = await prisma.membersAttended.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MembersAttendedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersAttendedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MembersAttended.
     * @param {MembersAttendedDeleteArgs} args - Arguments to delete one MembersAttended.
     * @example
     * // Delete one MembersAttended
     * const MembersAttended = await prisma.membersAttended.delete({
     *   where: {
     *     // ... filter to delete one MembersAttended
     *   }
     * })
     * 
    **/
    delete<T extends MembersAttendedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MembersAttendedDeleteArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MembersAttended.
     * @param {MembersAttendedUpdateArgs} args - Arguments to update one MembersAttended.
     * @example
     * // Update one MembersAttended
     * const membersAttended = await prisma.membersAttended.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MembersAttendedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MembersAttendedUpdateArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MembersAttendeds.
     * @param {MembersAttendedDeleteManyArgs} args - Arguments to filter MembersAttendeds to delete.
     * @example
     * // Delete a few MembersAttendeds
     * const { count } = await prisma.membersAttended.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MembersAttendedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MembersAttendedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembersAttendeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembersAttendeds
     * const membersAttended = await prisma.membersAttended.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MembersAttendedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MembersAttendedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MembersAttended.
     * @param {MembersAttendedUpsertArgs} args - Arguments to update or create a MembersAttended.
     * @example
     * // Update or create a MembersAttended
     * const membersAttended = await prisma.membersAttended.upsert({
     *   create: {
     *     // ... data to create a MembersAttended
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembersAttended we want to update
     *   }
     * })
    **/
    upsert<T extends MembersAttendedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MembersAttendedUpsertArgs<ExtArgs>>
    ): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MembersAttendeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedCountArgs} args - Arguments to filter MembersAttendeds to count.
     * @example
     * // Count the number of MembersAttendeds
     * const count = await prisma.membersAttended.count({
     *   where: {
     *     // ... the filter for the MembersAttendeds we want to count
     *   }
     * })
    **/
    count<T extends MembersAttendedCountArgs>(
      args?: Subset<T, MembersAttendedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembersAttendedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembersAttended.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembersAttendedAggregateArgs>(args: Subset<T, MembersAttendedAggregateArgs>): Prisma.PrismaPromise<GetMembersAttendedAggregateType<T>>

    /**
     * Group by MembersAttended.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAttendedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembersAttendedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembersAttendedGroupByArgs['orderBy'] }
        : { orderBy?: MembersAttendedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembersAttendedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembersAttendedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembersAttended model
   */
  readonly fields: MembersAttendedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembersAttended.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembersAttendedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    digitalSignatureFile<T extends DigitalSignatureFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DigitalSignatureFileDefaultArgs<ExtArgs>>): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MembersAttended model
   */ 
  interface MembersAttendedFieldRefs {
    readonly id: FieldRef<"MembersAttended", 'Int'>
    readonly memberId: FieldRef<"MembersAttended", 'Int'>
    readonly membersName: FieldRef<"MembersAttended", 'String'>
    readonly memberInTime: FieldRef<"MembersAttended", 'DateTime'>
    readonly memberOutTime: FieldRef<"MembersAttended", 'DateTime'>
    readonly dateTime: FieldRef<"MembersAttended", 'DateTime'>
    readonly latitude: FieldRef<"MembersAttended", 'Decimal'>
    readonly longitude: FieldRef<"MembersAttended", 'Decimal'>
    readonly meetingId: FieldRef<"MembersAttended", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MembersAttended findUnique
   */
  export type MembersAttendedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * Filter, which MembersAttended to fetch.
     */
    where: MembersAttendedWhereUniqueInput
  }


  /**
   * MembersAttended findUniqueOrThrow
   */
  export type MembersAttendedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * Filter, which MembersAttended to fetch.
     */
    where: MembersAttendedWhereUniqueInput
  }


  /**
   * MembersAttended findFirst
   */
  export type MembersAttendedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * Filter, which MembersAttended to fetch.
     */
    where?: MembersAttendedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersAttendeds to fetch.
     */
    orderBy?: MembersAttendedOrderByWithRelationInput | MembersAttendedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembersAttendeds.
     */
    cursor?: MembersAttendedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersAttendeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersAttendeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembersAttendeds.
     */
    distinct?: MembersAttendedScalarFieldEnum | MembersAttendedScalarFieldEnum[]
  }


  /**
   * MembersAttended findFirstOrThrow
   */
  export type MembersAttendedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * Filter, which MembersAttended to fetch.
     */
    where?: MembersAttendedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersAttendeds to fetch.
     */
    orderBy?: MembersAttendedOrderByWithRelationInput | MembersAttendedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembersAttendeds.
     */
    cursor?: MembersAttendedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersAttendeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersAttendeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembersAttendeds.
     */
    distinct?: MembersAttendedScalarFieldEnum | MembersAttendedScalarFieldEnum[]
  }


  /**
   * MembersAttended findMany
   */
  export type MembersAttendedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * Filter, which MembersAttendeds to fetch.
     */
    where?: MembersAttendedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembersAttendeds to fetch.
     */
    orderBy?: MembersAttendedOrderByWithRelationInput | MembersAttendedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembersAttendeds.
     */
    cursor?: MembersAttendedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembersAttendeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembersAttendeds.
     */
    skip?: number
    distinct?: MembersAttendedScalarFieldEnum | MembersAttendedScalarFieldEnum[]
  }


  /**
   * MembersAttended create
   */
  export type MembersAttendedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * The data needed to create a MembersAttended.
     */
    data: XOR<MembersAttendedCreateInput, MembersAttendedUncheckedCreateInput>
  }


  /**
   * MembersAttended createMany
   */
  export type MembersAttendedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembersAttendeds.
     */
    data: MembersAttendedCreateManyInput | MembersAttendedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MembersAttended update
   */
  export type MembersAttendedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * The data needed to update a MembersAttended.
     */
    data: XOR<MembersAttendedUpdateInput, MembersAttendedUncheckedUpdateInput>
    /**
     * Choose, which MembersAttended to update.
     */
    where: MembersAttendedWhereUniqueInput
  }


  /**
   * MembersAttended updateMany
   */
  export type MembersAttendedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembersAttendeds.
     */
    data: XOR<MembersAttendedUpdateManyMutationInput, MembersAttendedUncheckedUpdateManyInput>
    /**
     * Filter which MembersAttendeds to update
     */
    where?: MembersAttendedWhereInput
  }


  /**
   * MembersAttended upsert
   */
  export type MembersAttendedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * The filter to search for the MembersAttended to update in case it exists.
     */
    where: MembersAttendedWhereUniqueInput
    /**
     * In case the MembersAttended found by the `where` argument doesn't exist, create a new MembersAttended with this data.
     */
    create: XOR<MembersAttendedCreateInput, MembersAttendedUncheckedCreateInput>
    /**
     * In case the MembersAttended was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembersAttendedUpdateInput, MembersAttendedUncheckedUpdateInput>
  }


  /**
   * MembersAttended delete
   */
  export type MembersAttendedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
    /**
     * Filter which MembersAttended to delete.
     */
    where: MembersAttendedWhereUniqueInput
  }


  /**
   * MembersAttended deleteMany
   */
  export type MembersAttendedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembersAttendeds to delete
     */
    where?: MembersAttendedWhereInput
  }


  /**
   * MembersAttended without action
   */
  export type MembersAttendedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersAttended
     */
    select?: MembersAttendedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MembersAttendedInclude<ExtArgs> | null
  }



  /**
   * Model DigitalSignatureFile
   */

  export type AggregateDigitalSignatureFile = {
    _count: DigitalSignatureFileCountAggregateOutputType | null
    _avg: DigitalSignatureFileAvgAggregateOutputType | null
    _sum: DigitalSignatureFileSumAggregateOutputType | null
    _min: DigitalSignatureFileMinAggregateOutputType | null
    _max: DigitalSignatureFileMaxAggregateOutputType | null
  }

  export type DigitalSignatureFileAvgAggregateOutputType = {
    fileId: number | null
    attendanceId: number | null
  }

  export type DigitalSignatureFileSumAggregateOutputType = {
    fileId: number | null
    attendanceId: number | null
  }

  export type DigitalSignatureFileMinAggregateOutputType = {
    fileId: number | null
    name: string | null
    fileType: string | null
    path: string | null
    attendanceId: number | null
  }

  export type DigitalSignatureFileMaxAggregateOutputType = {
    fileId: number | null
    name: string | null
    fileType: string | null
    path: string | null
    attendanceId: number | null
  }

  export type DigitalSignatureFileCountAggregateOutputType = {
    fileId: number
    name: number
    fileType: number
    path: number
    attendanceId: number
    _all: number
  }


  export type DigitalSignatureFileAvgAggregateInputType = {
    fileId?: true
    attendanceId?: true
  }

  export type DigitalSignatureFileSumAggregateInputType = {
    fileId?: true
    attendanceId?: true
  }

  export type DigitalSignatureFileMinAggregateInputType = {
    fileId?: true
    name?: true
    fileType?: true
    path?: true
    attendanceId?: true
  }

  export type DigitalSignatureFileMaxAggregateInputType = {
    fileId?: true
    name?: true
    fileType?: true
    path?: true
    attendanceId?: true
  }

  export type DigitalSignatureFileCountAggregateInputType = {
    fileId?: true
    name?: true
    fileType?: true
    path?: true
    attendanceId?: true
    _all?: true
  }

  export type DigitalSignatureFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalSignatureFile to aggregate.
     */
    where?: DigitalSignatureFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatureFiles to fetch.
     */
    orderBy?: DigitalSignatureFileOrderByWithRelationInput | DigitalSignatureFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DigitalSignatureFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatureFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatureFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DigitalSignatureFiles
    **/
    _count?: true | DigitalSignatureFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DigitalSignatureFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DigitalSignatureFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DigitalSignatureFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DigitalSignatureFileMaxAggregateInputType
  }

  export type GetDigitalSignatureFileAggregateType<T extends DigitalSignatureFileAggregateArgs> = {
        [P in keyof T & keyof AggregateDigitalSignatureFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDigitalSignatureFile[P]>
      : GetScalarType<T[P], AggregateDigitalSignatureFile[P]>
  }




  export type DigitalSignatureFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigitalSignatureFileWhereInput
    orderBy?: DigitalSignatureFileOrderByWithAggregationInput | DigitalSignatureFileOrderByWithAggregationInput[]
    by: DigitalSignatureFileScalarFieldEnum[] | DigitalSignatureFileScalarFieldEnum
    having?: DigitalSignatureFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DigitalSignatureFileCountAggregateInputType | true
    _avg?: DigitalSignatureFileAvgAggregateInputType
    _sum?: DigitalSignatureFileSumAggregateInputType
    _min?: DigitalSignatureFileMinAggregateInputType
    _max?: DigitalSignatureFileMaxAggregateInputType
  }

  export type DigitalSignatureFileGroupByOutputType = {
    fileId: number
    name: string
    fileType: string
    path: string
    attendanceId: number
    _count: DigitalSignatureFileCountAggregateOutputType | null
    _avg: DigitalSignatureFileAvgAggregateOutputType | null
    _sum: DigitalSignatureFileSumAggregateOutputType | null
    _min: DigitalSignatureFileMinAggregateOutputType | null
    _max: DigitalSignatureFileMaxAggregateOutputType | null
  }

  type GetDigitalSignatureFileGroupByPayload<T extends DigitalSignatureFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DigitalSignatureFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DigitalSignatureFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DigitalSignatureFileGroupByOutputType[P]>
            : GetScalarType<T[P], DigitalSignatureFileGroupByOutputType[P]>
        }
      >
    >


  export type DigitalSignatureFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fileId?: boolean
    name?: boolean
    fileType?: boolean
    path?: boolean
    attendanceId?: boolean
    attendance?: boolean | MembersAttendedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["digitalSignatureFile"]>

  export type DigitalSignatureFileSelectScalar = {
    fileId?: boolean
    name?: boolean
    fileType?: boolean
    path?: boolean
    attendanceId?: boolean
  }

  export type DigitalSignatureFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | MembersAttendedDefaultArgs<ExtArgs>
  }


  export type $DigitalSignatureFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DigitalSignatureFile"
    objects: {
      attendance: Prisma.$MembersAttendedPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      fileId: number
      name: string
      fileType: string
      path: string
      attendanceId: number
    }, ExtArgs["result"]["digitalSignatureFile"]>
    composites: {}
  }


  type DigitalSignatureFileGetPayload<S extends boolean | null | undefined | DigitalSignatureFileDefaultArgs> = $Result.GetResult<Prisma.$DigitalSignatureFilePayload, S>

  type DigitalSignatureFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DigitalSignatureFileFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DigitalSignatureFileCountAggregateInputType | true
    }

  export interface DigitalSignatureFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DigitalSignatureFile'], meta: { name: 'DigitalSignatureFile' } }
    /**
     * Find zero or one DigitalSignatureFile that matches the filter.
     * @param {DigitalSignatureFileFindUniqueArgs} args - Arguments to find a DigitalSignatureFile
     * @example
     * // Get one DigitalSignatureFile
     * const digitalSignatureFile = await prisma.digitalSignatureFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DigitalSignatureFileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DigitalSignatureFileFindUniqueArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DigitalSignatureFile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DigitalSignatureFileFindUniqueOrThrowArgs} args - Arguments to find a DigitalSignatureFile
     * @example
     * // Get one DigitalSignatureFile
     * const digitalSignatureFile = await prisma.digitalSignatureFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DigitalSignatureFileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DigitalSignatureFileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DigitalSignatureFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileFindFirstArgs} args - Arguments to find a DigitalSignatureFile
     * @example
     * // Get one DigitalSignatureFile
     * const digitalSignatureFile = await prisma.digitalSignatureFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DigitalSignatureFileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DigitalSignatureFileFindFirstArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DigitalSignatureFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileFindFirstOrThrowArgs} args - Arguments to find a DigitalSignatureFile
     * @example
     * // Get one DigitalSignatureFile
     * const digitalSignatureFile = await prisma.digitalSignatureFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DigitalSignatureFileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DigitalSignatureFileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DigitalSignatureFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DigitalSignatureFiles
     * const digitalSignatureFiles = await prisma.digitalSignatureFile.findMany()
     * 
     * // Get first 10 DigitalSignatureFiles
     * const digitalSignatureFiles = await prisma.digitalSignatureFile.findMany({ take: 10 })
     * 
     * // Only select the `fileId`
     * const digitalSignatureFileWithFileIdOnly = await prisma.digitalSignatureFile.findMany({ select: { fileId: true } })
     * 
    **/
    findMany<T extends DigitalSignatureFileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DigitalSignatureFileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DigitalSignatureFile.
     * @param {DigitalSignatureFileCreateArgs} args - Arguments to create a DigitalSignatureFile.
     * @example
     * // Create one DigitalSignatureFile
     * const DigitalSignatureFile = await prisma.digitalSignatureFile.create({
     *   data: {
     *     // ... data to create a DigitalSignatureFile
     *   }
     * })
     * 
    **/
    create<T extends DigitalSignatureFileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DigitalSignatureFileCreateArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DigitalSignatureFiles.
     *     @param {DigitalSignatureFileCreateManyArgs} args - Arguments to create many DigitalSignatureFiles.
     *     @example
     *     // Create many DigitalSignatureFiles
     *     const digitalSignatureFile = await prisma.digitalSignatureFile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DigitalSignatureFileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DigitalSignatureFileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DigitalSignatureFile.
     * @param {DigitalSignatureFileDeleteArgs} args - Arguments to delete one DigitalSignatureFile.
     * @example
     * // Delete one DigitalSignatureFile
     * const DigitalSignatureFile = await prisma.digitalSignatureFile.delete({
     *   where: {
     *     // ... filter to delete one DigitalSignatureFile
     *   }
     * })
     * 
    **/
    delete<T extends DigitalSignatureFileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DigitalSignatureFileDeleteArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DigitalSignatureFile.
     * @param {DigitalSignatureFileUpdateArgs} args - Arguments to update one DigitalSignatureFile.
     * @example
     * // Update one DigitalSignatureFile
     * const digitalSignatureFile = await prisma.digitalSignatureFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DigitalSignatureFileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DigitalSignatureFileUpdateArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DigitalSignatureFiles.
     * @param {DigitalSignatureFileDeleteManyArgs} args - Arguments to filter DigitalSignatureFiles to delete.
     * @example
     * // Delete a few DigitalSignatureFiles
     * const { count } = await prisma.digitalSignatureFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DigitalSignatureFileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DigitalSignatureFileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DigitalSignatureFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DigitalSignatureFiles
     * const digitalSignatureFile = await prisma.digitalSignatureFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DigitalSignatureFileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DigitalSignatureFileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DigitalSignatureFile.
     * @param {DigitalSignatureFileUpsertArgs} args - Arguments to update or create a DigitalSignatureFile.
     * @example
     * // Update or create a DigitalSignatureFile
     * const digitalSignatureFile = await prisma.digitalSignatureFile.upsert({
     *   create: {
     *     // ... data to create a DigitalSignatureFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DigitalSignatureFile we want to update
     *   }
     * })
    **/
    upsert<T extends DigitalSignatureFileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DigitalSignatureFileUpsertArgs<ExtArgs>>
    ): Prisma__DigitalSignatureFileClient<$Result.GetResult<Prisma.$DigitalSignatureFilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DigitalSignatureFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileCountArgs} args - Arguments to filter DigitalSignatureFiles to count.
     * @example
     * // Count the number of DigitalSignatureFiles
     * const count = await prisma.digitalSignatureFile.count({
     *   where: {
     *     // ... the filter for the DigitalSignatureFiles we want to count
     *   }
     * })
    **/
    count<T extends DigitalSignatureFileCountArgs>(
      args?: Subset<T, DigitalSignatureFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DigitalSignatureFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DigitalSignatureFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DigitalSignatureFileAggregateArgs>(args: Subset<T, DigitalSignatureFileAggregateArgs>): Prisma.PrismaPromise<GetDigitalSignatureFileAggregateType<T>>

    /**
     * Group by DigitalSignatureFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DigitalSignatureFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DigitalSignatureFileGroupByArgs['orderBy'] }
        : { orderBy?: DigitalSignatureFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DigitalSignatureFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDigitalSignatureFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DigitalSignatureFile model
   */
  readonly fields: DigitalSignatureFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DigitalSignatureFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DigitalSignatureFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    attendance<T extends MembersAttendedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MembersAttendedDefaultArgs<ExtArgs>>): Prisma__MembersAttendedClient<$Result.GetResult<Prisma.$MembersAttendedPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DigitalSignatureFile model
   */ 
  interface DigitalSignatureFileFieldRefs {
    readonly fileId: FieldRef<"DigitalSignatureFile", 'Int'>
    readonly name: FieldRef<"DigitalSignatureFile", 'String'>
    readonly fileType: FieldRef<"DigitalSignatureFile", 'String'>
    readonly path: FieldRef<"DigitalSignatureFile", 'String'>
    readonly attendanceId: FieldRef<"DigitalSignatureFile", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DigitalSignatureFile findUnique
   */
  export type DigitalSignatureFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * Filter, which DigitalSignatureFile to fetch.
     */
    where: DigitalSignatureFileWhereUniqueInput
  }


  /**
   * DigitalSignatureFile findUniqueOrThrow
   */
  export type DigitalSignatureFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * Filter, which DigitalSignatureFile to fetch.
     */
    where: DigitalSignatureFileWhereUniqueInput
  }


  /**
   * DigitalSignatureFile findFirst
   */
  export type DigitalSignatureFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * Filter, which DigitalSignatureFile to fetch.
     */
    where?: DigitalSignatureFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatureFiles to fetch.
     */
    orderBy?: DigitalSignatureFileOrderByWithRelationInput | DigitalSignatureFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalSignatureFiles.
     */
    cursor?: DigitalSignatureFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatureFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatureFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalSignatureFiles.
     */
    distinct?: DigitalSignatureFileScalarFieldEnum | DigitalSignatureFileScalarFieldEnum[]
  }


  /**
   * DigitalSignatureFile findFirstOrThrow
   */
  export type DigitalSignatureFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * Filter, which DigitalSignatureFile to fetch.
     */
    where?: DigitalSignatureFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatureFiles to fetch.
     */
    orderBy?: DigitalSignatureFileOrderByWithRelationInput | DigitalSignatureFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalSignatureFiles.
     */
    cursor?: DigitalSignatureFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatureFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatureFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalSignatureFiles.
     */
    distinct?: DigitalSignatureFileScalarFieldEnum | DigitalSignatureFileScalarFieldEnum[]
  }


  /**
   * DigitalSignatureFile findMany
   */
  export type DigitalSignatureFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * Filter, which DigitalSignatureFiles to fetch.
     */
    where?: DigitalSignatureFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatureFiles to fetch.
     */
    orderBy?: DigitalSignatureFileOrderByWithRelationInput | DigitalSignatureFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DigitalSignatureFiles.
     */
    cursor?: DigitalSignatureFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatureFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatureFiles.
     */
    skip?: number
    distinct?: DigitalSignatureFileScalarFieldEnum | DigitalSignatureFileScalarFieldEnum[]
  }


  /**
   * DigitalSignatureFile create
   */
  export type DigitalSignatureFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * The data needed to create a DigitalSignatureFile.
     */
    data: XOR<DigitalSignatureFileCreateInput, DigitalSignatureFileUncheckedCreateInput>
  }


  /**
   * DigitalSignatureFile createMany
   */
  export type DigitalSignatureFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DigitalSignatureFiles.
     */
    data: DigitalSignatureFileCreateManyInput | DigitalSignatureFileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DigitalSignatureFile update
   */
  export type DigitalSignatureFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * The data needed to update a DigitalSignatureFile.
     */
    data: XOR<DigitalSignatureFileUpdateInput, DigitalSignatureFileUncheckedUpdateInput>
    /**
     * Choose, which DigitalSignatureFile to update.
     */
    where: DigitalSignatureFileWhereUniqueInput
  }


  /**
   * DigitalSignatureFile updateMany
   */
  export type DigitalSignatureFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DigitalSignatureFiles.
     */
    data: XOR<DigitalSignatureFileUpdateManyMutationInput, DigitalSignatureFileUncheckedUpdateManyInput>
    /**
     * Filter which DigitalSignatureFiles to update
     */
    where?: DigitalSignatureFileWhereInput
  }


  /**
   * DigitalSignatureFile upsert
   */
  export type DigitalSignatureFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * The filter to search for the DigitalSignatureFile to update in case it exists.
     */
    where: DigitalSignatureFileWhereUniqueInput
    /**
     * In case the DigitalSignatureFile found by the `where` argument doesn't exist, create a new DigitalSignatureFile with this data.
     */
    create: XOR<DigitalSignatureFileCreateInput, DigitalSignatureFileUncheckedCreateInput>
    /**
     * In case the DigitalSignatureFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DigitalSignatureFileUpdateInput, DigitalSignatureFileUncheckedUpdateInput>
  }


  /**
   * DigitalSignatureFile delete
   */
  export type DigitalSignatureFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
    /**
     * Filter which DigitalSignatureFile to delete.
     */
    where: DigitalSignatureFileWhereUniqueInput
  }


  /**
   * DigitalSignatureFile deleteMany
   */
  export type DigitalSignatureFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalSignatureFiles to delete
     */
    where?: DigitalSignatureFileWhereInput
  }


  /**
   * DigitalSignatureFile without action
   */
  export type DigitalSignatureFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignatureFile
     */
    select?: DigitalSignatureFileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DigitalSignatureFileInclude<ExtArgs> | null
  }



  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormAvgAggregateOutputType = {
    formId: number | null
  }

  export type FormSumAggregateOutputType = {
    formId: number | null
  }

  export type FormMinAggregateOutputType = {
    formId: number | null
    formTitle: string | null
    formResult: string | null
    username: string | null
    userId: string | null
    dateAndTime: string | null
    description: string | null
    status: string | null
    q1: string | null
    q2: string | null
    q3: string | null
    q4: string | null
    q5: string | null
    q6: string | null
    q7: string | null
    q8: string | null
    q9: string | null
    q10: string | null
    q11: string | null
    q12: string | null
    q13: string | null
    q14: string | null
    q15: string | null
    q16: string | null
    q17: string | null
    q18: string | null
    q19: string | null
    q20: string | null
    q21: string | null
    q22: string | null
    q23: string | null
    q24: string | null
    q25: string | null
    q26: string | null
    q27: string | null
    q28: string | null
    q29: string | null
    q30: string | null
    q31: string | null
    q32: string | null
    q33: string | null
    q34: string | null
    q35: string | null
    q36: string | null
    q37: string | null
    q38: string | null
    q39: string | null
    q40: string | null
    q41: string | null
    q42: string | null
    q43: string | null
    q44: string | null
    q45: string | null
    q46: string | null
    q47: string | null
    q48: string | null
    q49: string | null
    q50: string | null
  }

  export type FormMaxAggregateOutputType = {
    formId: number | null
    formTitle: string | null
    formResult: string | null
    username: string | null
    userId: string | null
    dateAndTime: string | null
    description: string | null
    status: string | null
    q1: string | null
    q2: string | null
    q3: string | null
    q4: string | null
    q5: string | null
    q6: string | null
    q7: string | null
    q8: string | null
    q9: string | null
    q10: string | null
    q11: string | null
    q12: string | null
    q13: string | null
    q14: string | null
    q15: string | null
    q16: string | null
    q17: string | null
    q18: string | null
    q19: string | null
    q20: string | null
    q21: string | null
    q22: string | null
    q23: string | null
    q24: string | null
    q25: string | null
    q26: string | null
    q27: string | null
    q28: string | null
    q29: string | null
    q30: string | null
    q31: string | null
    q32: string | null
    q33: string | null
    q34: string | null
    q35: string | null
    q36: string | null
    q37: string | null
    q38: string | null
    q39: string | null
    q40: string | null
    q41: string | null
    q42: string | null
    q43: string | null
    q44: string | null
    q45: string | null
    q46: string | null
    q47: string | null
    q48: string | null
    q49: string | null
    q50: string | null
  }

  export type FormCountAggregateOutputType = {
    formId: number
    formTitle: number
    formResult: number
    username: number
    userId: number
    dateAndTime: number
    description: number
    status: number
    q1: number
    q2: number
    q3: number
    q4: number
    q5: number
    q6: number
    q7: number
    q8: number
    q9: number
    q10: number
    q11: number
    q12: number
    q13: number
    q14: number
    q15: number
    q16: number
    q17: number
    q18: number
    q19: number
    q20: number
    q21: number
    q22: number
    q23: number
    q24: number
    q25: number
    q26: number
    q27: number
    q28: number
    q29: number
    q30: number
    q31: number
    q32: number
    q33: number
    q34: number
    q35: number
    q36: number
    q37: number
    q38: number
    q39: number
    q40: number
    q41: number
    q42: number
    q43: number
    q44: number
    q45: number
    q46: number
    q47: number
    q48: number
    q49: number
    q50: number
    _all: number
  }


  export type FormAvgAggregateInputType = {
    formId?: true
  }

  export type FormSumAggregateInputType = {
    formId?: true
  }

  export type FormMinAggregateInputType = {
    formId?: true
    formTitle?: true
    formResult?: true
    username?: true
    userId?: true
    dateAndTime?: true
    description?: true
    status?: true
    q1?: true
    q2?: true
    q3?: true
    q4?: true
    q5?: true
    q6?: true
    q7?: true
    q8?: true
    q9?: true
    q10?: true
    q11?: true
    q12?: true
    q13?: true
    q14?: true
    q15?: true
    q16?: true
    q17?: true
    q18?: true
    q19?: true
    q20?: true
    q21?: true
    q22?: true
    q23?: true
    q24?: true
    q25?: true
    q26?: true
    q27?: true
    q28?: true
    q29?: true
    q30?: true
    q31?: true
    q32?: true
    q33?: true
    q34?: true
    q35?: true
    q36?: true
    q37?: true
    q38?: true
    q39?: true
    q40?: true
    q41?: true
    q42?: true
    q43?: true
    q44?: true
    q45?: true
    q46?: true
    q47?: true
    q48?: true
    q49?: true
    q50?: true
  }

  export type FormMaxAggregateInputType = {
    formId?: true
    formTitle?: true
    formResult?: true
    username?: true
    userId?: true
    dateAndTime?: true
    description?: true
    status?: true
    q1?: true
    q2?: true
    q3?: true
    q4?: true
    q5?: true
    q6?: true
    q7?: true
    q8?: true
    q9?: true
    q10?: true
    q11?: true
    q12?: true
    q13?: true
    q14?: true
    q15?: true
    q16?: true
    q17?: true
    q18?: true
    q19?: true
    q20?: true
    q21?: true
    q22?: true
    q23?: true
    q24?: true
    q25?: true
    q26?: true
    q27?: true
    q28?: true
    q29?: true
    q30?: true
    q31?: true
    q32?: true
    q33?: true
    q34?: true
    q35?: true
    q36?: true
    q37?: true
    q38?: true
    q39?: true
    q40?: true
    q41?: true
    q42?: true
    q43?: true
    q44?: true
    q45?: true
    q46?: true
    q47?: true
    q48?: true
    q49?: true
    q50?: true
  }

  export type FormCountAggregateInputType = {
    formId?: true
    formTitle?: true
    formResult?: true
    username?: true
    userId?: true
    dateAndTime?: true
    description?: true
    status?: true
    q1?: true
    q2?: true
    q3?: true
    q4?: true
    q5?: true
    q6?: true
    q7?: true
    q8?: true
    q9?: true
    q10?: true
    q11?: true
    q12?: true
    q13?: true
    q14?: true
    q15?: true
    q16?: true
    q17?: true
    q18?: true
    q19?: true
    q20?: true
    q21?: true
    q22?: true
    q23?: true
    q24?: true
    q25?: true
    q26?: true
    q27?: true
    q28?: true
    q29?: true
    q30?: true
    q31?: true
    q32?: true
    q33?: true
    q34?: true
    q35?: true
    q36?: true
    q37?: true
    q38?: true
    q39?: true
    q40?: true
    q41?: true
    q42?: true
    q43?: true
    q44?: true
    q45?: true
    q46?: true
    q47?: true
    q48?: true
    q49?: true
    q50?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _avg?: FormAvgAggregateInputType
    _sum?: FormSumAggregateInputType
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    formId: number
    formTitle: string
    formResult: string
    username: string
    userId: string
    dateAndTime: string
    description: string
    status: string
    q1: string | null
    q2: string | null
    q3: string | null
    q4: string | null
    q5: string | null
    q6: string | null
    q7: string | null
    q8: string | null
    q9: string | null
    q10: string | null
    q11: string | null
    q12: string | null
    q13: string | null
    q14: string | null
    q15: string | null
    q16: string | null
    q17: string | null
    q18: string | null
    q19: string | null
    q20: string | null
    q21: string | null
    q22: string | null
    q23: string | null
    q24: string | null
    q25: string | null
    q26: string | null
    q27: string | null
    q28: string | null
    q29: string | null
    q30: string | null
    q31: string | null
    q32: string | null
    q33: string | null
    q34: string | null
    q35: string | null
    q36: string | null
    q37: string | null
    q38: string | null
    q39: string | null
    q40: string | null
    q41: string | null
    q42: string | null
    q43: string | null
    q44: string | null
    q45: string | null
    q46: string | null
    q47: string | null
    q48: string | null
    q49: string | null
    q50: string | null
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formId?: boolean
    formTitle?: boolean
    formResult?: boolean
    username?: boolean
    userId?: boolean
    dateAndTime?: boolean
    description?: boolean
    status?: boolean
    q1?: boolean
    q2?: boolean
    q3?: boolean
    q4?: boolean
    q5?: boolean
    q6?: boolean
    q7?: boolean
    q8?: boolean
    q9?: boolean
    q10?: boolean
    q11?: boolean
    q12?: boolean
    q13?: boolean
    q14?: boolean
    q15?: boolean
    q16?: boolean
    q17?: boolean
    q18?: boolean
    q19?: boolean
    q20?: boolean
    q21?: boolean
    q22?: boolean
    q23?: boolean
    q24?: boolean
    q25?: boolean
    q26?: boolean
    q27?: boolean
    q28?: boolean
    q29?: boolean
    q30?: boolean
    q31?: boolean
    q32?: boolean
    q33?: boolean
    q34?: boolean
    q35?: boolean
    q36?: boolean
    q37?: boolean
    q38?: boolean
    q39?: boolean
    q40?: boolean
    q41?: boolean
    q42?: boolean
    q43?: boolean
    q44?: boolean
    q45?: boolean
    q46?: boolean
    q47?: boolean
    q48?: boolean
    q49?: boolean
    q50?: boolean
  }, ExtArgs["result"]["form"]>

  export type FormSelectScalar = {
    formId?: boolean
    formTitle?: boolean
    formResult?: boolean
    username?: boolean
    userId?: boolean
    dateAndTime?: boolean
    description?: boolean
    status?: boolean
    q1?: boolean
    q2?: boolean
    q3?: boolean
    q4?: boolean
    q5?: boolean
    q6?: boolean
    q7?: boolean
    q8?: boolean
    q9?: boolean
    q10?: boolean
    q11?: boolean
    q12?: boolean
    q13?: boolean
    q14?: boolean
    q15?: boolean
    q16?: boolean
    q17?: boolean
    q18?: boolean
    q19?: boolean
    q20?: boolean
    q21?: boolean
    q22?: boolean
    q23?: boolean
    q24?: boolean
    q25?: boolean
    q26?: boolean
    q27?: boolean
    q28?: boolean
    q29?: boolean
    q30?: boolean
    q31?: boolean
    q32?: boolean
    q33?: boolean
    q34?: boolean
    q35?: boolean
    q36?: boolean
    q37?: boolean
    q38?: boolean
    q39?: boolean
    q40?: boolean
    q41?: boolean
    q42?: boolean
    q43?: boolean
    q44?: boolean
    q45?: boolean
    q46?: boolean
    q47?: boolean
    q48?: boolean
    q49?: boolean
    q50?: boolean
  }


  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      formId: number
      formTitle: string
      formResult: string
      username: string
      userId: string
      dateAndTime: string
      description: string
      status: string
      q1: string | null
      q2: string | null
      q3: string | null
      q4: string | null
      q5: string | null
      q6: string | null
      q7: string | null
      q8: string | null
      q9: string | null
      q10: string | null
      q11: string | null
      q12: string | null
      q13: string | null
      q14: string | null
      q15: string | null
      q16: string | null
      q17: string | null
      q18: string | null
      q19: string | null
      q20: string | null
      q21: string | null
      q22: string | null
      q23: string | null
      q24: string | null
      q25: string | null
      q26: string | null
      q27: string | null
      q28: string | null
      q29: string | null
      q30: string | null
      q31: string | null
      q32: string | null
      q33: string | null
      q34: string | null
      q35: string | null
      q36: string | null
      q37: string | null
      q38: string | null
      q39: string | null
      q40: string | null
      q41: string | null
      q42: string | null
      q43: string | null
      q44: string | null
      q45: string | null
      q46: string | null
      q47: string | null
      q48: string | null
      q49: string | null
      q50: string | null
    }, ExtArgs["result"]["form"]>
    composites: {}
  }


  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Form that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `formId`
     * const formWithFormIdOnly = await prisma.form.findMany({ select: { formId: true } })
     * 
    **/
    findMany<T extends FormFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
    **/
    create<T extends FormCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormCreateArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Forms.
     *     @param {FormCreateManyArgs} args - Arguments to create many Forms.
     *     @example
     *     // Create many Forms
     *     const form = await prisma.form.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
    **/
    delete<T extends FormDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormDeleteArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormUpdateArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
    **/
    upsert<T extends FormUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormUpsertArgs<ExtArgs>>
    ): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Form model
   */ 
  interface FormFieldRefs {
    readonly formId: FieldRef<"Form", 'Int'>
    readonly formTitle: FieldRef<"Form", 'String'>
    readonly formResult: FieldRef<"Form", 'String'>
    readonly username: FieldRef<"Form", 'String'>
    readonly userId: FieldRef<"Form", 'String'>
    readonly dateAndTime: FieldRef<"Form", 'String'>
    readonly description: FieldRef<"Form", 'String'>
    readonly status: FieldRef<"Form", 'String'>
    readonly q1: FieldRef<"Form", 'String'>
    readonly q2: FieldRef<"Form", 'String'>
    readonly q3: FieldRef<"Form", 'String'>
    readonly q4: FieldRef<"Form", 'String'>
    readonly q5: FieldRef<"Form", 'String'>
    readonly q6: FieldRef<"Form", 'String'>
    readonly q7: FieldRef<"Form", 'String'>
    readonly q8: FieldRef<"Form", 'String'>
    readonly q9: FieldRef<"Form", 'String'>
    readonly q10: FieldRef<"Form", 'String'>
    readonly q11: FieldRef<"Form", 'String'>
    readonly q12: FieldRef<"Form", 'String'>
    readonly q13: FieldRef<"Form", 'String'>
    readonly q14: FieldRef<"Form", 'String'>
    readonly q15: FieldRef<"Form", 'String'>
    readonly q16: FieldRef<"Form", 'String'>
    readonly q17: FieldRef<"Form", 'String'>
    readonly q18: FieldRef<"Form", 'String'>
    readonly q19: FieldRef<"Form", 'String'>
    readonly q20: FieldRef<"Form", 'String'>
    readonly q21: FieldRef<"Form", 'String'>
    readonly q22: FieldRef<"Form", 'String'>
    readonly q23: FieldRef<"Form", 'String'>
    readonly q24: FieldRef<"Form", 'String'>
    readonly q25: FieldRef<"Form", 'String'>
    readonly q26: FieldRef<"Form", 'String'>
    readonly q27: FieldRef<"Form", 'String'>
    readonly q28: FieldRef<"Form", 'String'>
    readonly q29: FieldRef<"Form", 'String'>
    readonly q30: FieldRef<"Form", 'String'>
    readonly q31: FieldRef<"Form", 'String'>
    readonly q32: FieldRef<"Form", 'String'>
    readonly q33: FieldRef<"Form", 'String'>
    readonly q34: FieldRef<"Form", 'String'>
    readonly q35: FieldRef<"Form", 'String'>
    readonly q36: FieldRef<"Form", 'String'>
    readonly q37: FieldRef<"Form", 'String'>
    readonly q38: FieldRef<"Form", 'String'>
    readonly q39: FieldRef<"Form", 'String'>
    readonly q40: FieldRef<"Form", 'String'>
    readonly q41: FieldRef<"Form", 'String'>
    readonly q42: FieldRef<"Form", 'String'>
    readonly q43: FieldRef<"Form", 'String'>
    readonly q44: FieldRef<"Form", 'String'>
    readonly q45: FieldRef<"Form", 'String'>
    readonly q46: FieldRef<"Form", 'String'>
    readonly q47: FieldRef<"Form", 'String'>
    readonly q48: FieldRef<"Form", 'String'>
    readonly q49: FieldRef<"Form", 'String'>
    readonly q50: FieldRef<"Form", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }


  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
  }


  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }


  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }


  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }


  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }


  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
  }


  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
  }


  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }


  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
  }


  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
  }


  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    avatar: 'avatar',
    name: 'name',
    email: 'email',
    phone: 'phone',
    department: 'department',
    employeeNumber: 'employeeNumber',
    password: 'password',
    fcmToken: 'fcmToken',
    type: 'type',
    adminApproved: 'adminApproved',
    resetPasswordToken: 'resetPasswordToken',
    resetPasswordExpire: 'resetPasswordExpire',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    avatar: 'avatar',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    groupId: 'groupId',
    userId: 'userId'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    timer: 'timer',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReadScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    groupId: 'groupId',
    userId: 'userId',
    reply: 'reply',
    mode: 'mode',
    readAt: 'readAt'
  };

  export type ReadScalarFieldEnum = (typeof ReadScalarFieldEnum)[keyof typeof ReadScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileType: 'fileType',
    messageId: 'messageId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const RiskAssessmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    groupId: 'groupId',
    createdAt: 'createdAt'
  };

  export type RiskAssessmentScalarFieldEnum = (typeof RiskAssessmentScalarFieldEnum)[keyof typeof RiskAssessmentScalarFieldEnum]


  export const OtherFileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type OtherFileScalarFieldEnum = (typeof OtherFileScalarFieldEnum)[keyof typeof OtherFileScalarFieldEnum]


  export const UserOrientationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type UserOrientationScalarFieldEnum = (typeof UserOrientationScalarFieldEnum)[keyof typeof UserOrientationScalarFieldEnum]


  export const UserOrientationReadScalarFieldEnum: {
    id: 'id',
    userOrientationId: 'userOrientationId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type UserOrientationReadScalarFieldEnum = (typeof UserOrientationReadScalarFieldEnum)[keyof typeof UserOrientationReadScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    location: 'location',
    organizationName: 'organizationName',
    date: 'date',
    time: 'time',
    feedback: 'feedback',
    source: 'source',
    color: 'color',
    selectedValues: 'selectedValues',
    description: 'description',
    reportedBy: 'reportedBy',
    responsiblePerson: 'responsiblePerson',
    actionTaken: 'actionTaken',
    status: 'status',
    userAcknowledgement: 'userAcknowledgement',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const FeedbackAssignmentScalarFieldEnum: {
    id: 'id',
    assignmentCompleted: 'assignmentCompleted',
    feedbackId: 'feedbackId',
    userId: 'userId'
  };

  export type FeedbackAssignmentScalarFieldEnum = (typeof FeedbackAssignmentScalarFieldEnum)[keyof typeof FeedbackAssignmentScalarFieldEnum]


  export const FeedbackFileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileType: 'fileType',
    feedbackId: 'feedbackId'
  };

  export type FeedbackFileScalarFieldEnum = (typeof FeedbackFileScalarFieldEnum)[keyof typeof FeedbackFileScalarFieldEnum]


  export const FeedbackActionFileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileType: 'fileType',
    feedbackId: 'feedbackId'
  };

  export type FeedbackActionFileScalarFieldEnum = (typeof FeedbackActionFileScalarFieldEnum)[keyof typeof FeedbackActionFileScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    meetingId: 'meetingId',
    meetCreater: 'meetCreater',
    meetDateTime: 'meetDateTime',
    meetTitle: 'meetTitle',
    meetingTime: 'meetingTime',
    department: 'department',
    createrId: 'createrId',
    membersCount: 'membersCount',
    isOnline: 'isOnline',
    attId: 'attId',
    meetEndTime: 'meetEndTime'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const MembersListScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    memberName: 'memberName',
    meetingId: 'meetingId'
  };

  export type MembersListScalarFieldEnum = (typeof MembersListScalarFieldEnum)[keyof typeof MembersListScalarFieldEnum]


  export const MembersAttendedScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    membersName: 'membersName',
    memberInTime: 'memberInTime',
    memberOutTime: 'memberOutTime',
    dateTime: 'dateTime',
    latitude: 'latitude',
    longitude: 'longitude',
    meetingId: 'meetingId'
  };

  export type MembersAttendedScalarFieldEnum = (typeof MembersAttendedScalarFieldEnum)[keyof typeof MembersAttendedScalarFieldEnum]


  export const DigitalSignatureFileScalarFieldEnum: {
    fileId: 'fileId',
    name: 'name',
    fileType: 'fileType',
    path: 'path',
    attendanceId: 'attendanceId'
  };

  export type DigitalSignatureFileScalarFieldEnum = (typeof DigitalSignatureFileScalarFieldEnum)[keyof typeof DigitalSignatureFileScalarFieldEnum]


  export const FormScalarFieldEnum: {
    formId: 'formId',
    formTitle: 'formTitle',
    formResult: 'formResult',
    username: 'username',
    userId: 'userId',
    dateAndTime: 'dateAndTime',
    description: 'description',
    status: 'status',
    q1: 'q1',
    q2: 'q2',
    q3: 'q3',
    q4: 'q4',
    q5: 'q5',
    q6: 'q6',
    q7: 'q7',
    q8: 'q8',
    q9: 'q9',
    q10: 'q10',
    q11: 'q11',
    q12: 'q12',
    q13: 'q13',
    q14: 'q14',
    q15: 'q15',
    q16: 'q16',
    q17: 'q17',
    q18: 'q18',
    q19: 'q19',
    q20: 'q20',
    q21: 'q21',
    q22: 'q22',
    q23: 'q23',
    q24: 'q24',
    q25: 'q25',
    q26: 'q26',
    q27: 'q27',
    q28: 'q28',
    q29: 'q29',
    q30: 'q30',
    q31: 'q31',
    q32: 'q32',
    q33: 'q33',
    q34: 'q34',
    q35: 'q35',
    q36: 'q36',
    q37: 'q37',
    q38: 'q38',
    q39: 'q39',
    q40: 'q40',
    q41: 'q41',
    q42: 'q42',
    q43: 'q43',
    q44: 'q44',
    q45: 'q45',
    q46: 'q46',
    q47: 'q47',
    q48: 'q48',
    q49: 'q49',
    q50: 'q50'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter | number
    avatar?: StringNullableFilter | string | null
    name?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    department?: StringFilter | string
    employeeNumber?: StringFilter | string
    password?: StringFilter | string
    fcmToken?: StringNullableFilter | string | null
    type?: EnumUserTypeFilter | $Enums.UserType
    adminApproved?: EnumAdminApprovedFilter | $Enums.AdminApproved
    resetPasswordToken?: StringNullableFilter | string | null
    resetPasswordExpire?: DateTimeNullableFilter | Date | string | null
    active?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    memberInGroups?: MemberListRelationFilter
    messages?: MessageListRelationFilter
    reads?: ReadListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    feedbackAssignments?: FeedbackAssignmentListRelationFilter
    userOrientationReads?: UserOrientationReadListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    avatar?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    employeeNumber?: SortOrder
    password?: SortOrder
    fcmToken?: SortOrderInput | SortOrder
    type?: SortOrder
    adminApproved?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpire?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    memberInGroups?: MemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    reads?: ReadOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    feedbackAssignments?: FeedbackAssignmentOrderByRelationAggregateInput
    userOrientationReads?: UserOrientationReadOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
    phone?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    avatar?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    employeeNumber?: SortOrder
    password?: SortOrder
    fcmToken?: SortOrderInput | SortOrder
    type?: SortOrder
    adminApproved?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpire?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    avatar?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    department?: StringWithAggregatesFilter | string
    employeeNumber?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    fcmToken?: StringNullableWithAggregatesFilter | string | null
    type?: EnumUserTypeWithAggregatesFilter | $Enums.UserType
    adminApproved?: EnumAdminApprovedWithAggregatesFilter | $Enums.AdminApproved
    resetPasswordToken?: StringNullableWithAggregatesFilter | string | null
    resetPasswordExpire?: DateTimeNullableWithAggregatesFilter | Date | string | null
    active?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter | number
    avatar?: StringNullableFilter | string | null
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    members?: MemberListRelationFilter
    assessments?: RiskAssessmentListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    avatar?: SortOrderInput | SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    members?: MemberOrderByRelationAggregateInput
    assessments?: RiskAssessmentOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = {
    id?: number
  }

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    avatar?: SortOrderInput | SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    avatar?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    groupId?: IntFilter | number
    userId?: IntFilter | number
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    groupId?: SortOrder
    userId?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = {
    groupId_userId?: MemberGroupIdUserIdCompoundUniqueInput
  }

  export type MemberOrderByWithAggregationInput = {
    groupId?: SortOrder
    userId?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    groupId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    timer?: IntFilter | number
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    read?: ReadListRelationFilter
    files?: FileListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    groups?: GroupListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    read?: ReadOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    groups?: GroupOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = {
    id?: number
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    timer?: IntWithAggregatesFilter | number
    createdById?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReadWhereInput = {
    AND?: ReadWhereInput | ReadWhereInput[]
    OR?: ReadWhereInput[]
    NOT?: ReadWhereInput | ReadWhereInput[]
    id?: IntFilter | number
    messageId?: IntFilter | number
    groupId?: IntFilter | number
    userId?: IntFilter | number
    reply?: StringNullableFilter | string | null
    mode?: StringNullableFilter | string | null
    readAt?: DateTimeFilter | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReadOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    reply?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    readAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReadWhereUniqueInput = {
    id?: number
  }

  export type ReadOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    reply?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    readAt?: SortOrder
    _count?: ReadCountOrderByAggregateInput
    _avg?: ReadAvgOrderByAggregateInput
    _max?: ReadMaxOrderByAggregateInput
    _min?: ReadMinOrderByAggregateInput
    _sum?: ReadSumOrderByAggregateInput
  }

  export type ReadScalarWhereWithAggregatesInput = {
    AND?: ReadScalarWhereWithAggregatesInput | ReadScalarWhereWithAggregatesInput[]
    OR?: ReadScalarWhereWithAggregatesInput[]
    NOT?: ReadScalarWhereWithAggregatesInput | ReadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    messageId?: IntWithAggregatesFilter | number
    groupId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    reply?: StringNullableWithAggregatesFilter | string | null
    mode?: StringNullableWithAggregatesFilter | string | null
    readAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    messageId?: IntFilter | number
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    messageId?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = {
    id?: number
  }

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    messageId?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    messageId?: IntWithAggregatesFilter | number
  }

  export type RiskAssessmentWhereInput = {
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    groupId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
  }

  export type RiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type RiskAssessmentWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type RiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    _count?: RiskAssessmentCountOrderByAggregateInput
    _avg?: RiskAssessmentAvgOrderByAggregateInput
    _max?: RiskAssessmentMaxOrderByAggregateInput
    _min?: RiskAssessmentMinOrderByAggregateInput
    _sum?: RiskAssessmentSumOrderByAggregateInput
  }

  export type RiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: RiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    groupId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OtherFileWhereInput = {
    AND?: OtherFileWhereInput | OtherFileWhereInput[]
    OR?: OtherFileWhereInput[]
    NOT?: OtherFileWhereInput | OtherFileWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type OtherFileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type OtherFileWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type OtherFileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: OtherFileCountOrderByAggregateInput
    _avg?: OtherFileAvgOrderByAggregateInput
    _max?: OtherFileMaxOrderByAggregateInput
    _min?: OtherFileMinOrderByAggregateInput
    _sum?: OtherFileSumOrderByAggregateInput
  }

  export type OtherFileScalarWhereWithAggregatesInput = {
    AND?: OtherFileScalarWhereWithAggregatesInput | OtherFileScalarWhereWithAggregatesInput[]
    OR?: OtherFileScalarWhereWithAggregatesInput[]
    NOT?: OtherFileScalarWhereWithAggregatesInput | OtherFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserOrientationWhereInput = {
    AND?: UserOrientationWhereInput | UserOrientationWhereInput[]
    OR?: UserOrientationWhereInput[]
    NOT?: UserOrientationWhereInput | UserOrientationWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userOrientationReads?: UserOrientationReadListRelationFilter
  }

  export type UserOrientationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    userOrientationReads?: UserOrientationReadOrderByRelationAggregateInput
  }

  export type UserOrientationWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type UserOrientationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: UserOrientationCountOrderByAggregateInput
    _avg?: UserOrientationAvgOrderByAggregateInput
    _max?: UserOrientationMaxOrderByAggregateInput
    _min?: UserOrientationMinOrderByAggregateInput
    _sum?: UserOrientationSumOrderByAggregateInput
  }

  export type UserOrientationScalarWhereWithAggregatesInput = {
    AND?: UserOrientationScalarWhereWithAggregatesInput | UserOrientationScalarWhereWithAggregatesInput[]
    OR?: UserOrientationScalarWhereWithAggregatesInput[]
    NOT?: UserOrientationScalarWhereWithAggregatesInput | UserOrientationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserOrientationReadWhereInput = {
    AND?: UserOrientationReadWhereInput | UserOrientationReadWhereInput[]
    OR?: UserOrientationReadWhereInput[]
    NOT?: UserOrientationReadWhereInput | UserOrientationReadWhereInput[]
    id?: IntFilter | number
    userOrientationId?: IntFilter | number
    userId?: IntFilter | number
    readAt?: DateTimeFilter | Date | string
    userOrientation?: XOR<UserOrientationRelationFilter, UserOrientationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserOrientationReadOrderByWithRelationInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    userOrientation?: UserOrientationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserOrientationReadWhereUniqueInput = {
    id?: number
  }

  export type UserOrientationReadOrderByWithAggregationInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: UserOrientationReadCountOrderByAggregateInput
    _avg?: UserOrientationReadAvgOrderByAggregateInput
    _max?: UserOrientationReadMaxOrderByAggregateInput
    _min?: UserOrientationReadMinOrderByAggregateInput
    _sum?: UserOrientationReadSumOrderByAggregateInput
  }

  export type UserOrientationReadScalarWhereWithAggregatesInput = {
    AND?: UserOrientationReadScalarWhereWithAggregatesInput | UserOrientationReadScalarWhereWithAggregatesInput[]
    OR?: UserOrientationReadScalarWhereWithAggregatesInput[]
    NOT?: UserOrientationReadScalarWhereWithAggregatesInput | UserOrientationReadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    userOrientationId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    readAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter | number
    location?: StringFilter | string
    organizationName?: StringFilter | string
    date?: StringFilter | string
    time?: StringFilter | string
    feedback?: StringFilter | string
    source?: StringFilter | string
    color?: EnumFeedbackColorFilter | $Enums.FeedbackColor
    selectedValues?: StringFilter | string
    description?: StringFilter | string
    reportedBy?: StringFilter | string
    responsiblePerson?: StringNullableFilter | string | null
    actionTaken?: StringNullableFilter | string | null
    status?: EnumStatusNullableFilter | $Enums.Status | null
    userAcknowledgement?: StringNullableFilter | string | null
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    files?: FeedbackFileListRelationFilter
    actionFiles?: FeedbackActionFileListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    feedbackAssignments?: FeedbackAssignmentListRelationFilter
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    organizationName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    feedback?: SortOrder
    source?: SortOrder
    color?: SortOrder
    selectedValues?: SortOrder
    description?: SortOrder
    reportedBy?: SortOrder
    responsiblePerson?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    userAcknowledgement?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    files?: FeedbackFileOrderByRelationAggregateInput
    actionFiles?: FeedbackActionFileOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    feedbackAssignments?: FeedbackAssignmentOrderByRelationAggregateInput
  }

  export type FeedbackWhereUniqueInput = {
    id?: number
  }

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    organizationName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    feedback?: SortOrder
    source?: SortOrder
    color?: SortOrder
    selectedValues?: SortOrder
    description?: SortOrder
    reportedBy?: SortOrder
    responsiblePerson?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    userAcknowledgement?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    location?: StringWithAggregatesFilter | string
    organizationName?: StringWithAggregatesFilter | string
    date?: StringWithAggregatesFilter | string
    time?: StringWithAggregatesFilter | string
    feedback?: StringWithAggregatesFilter | string
    source?: StringWithAggregatesFilter | string
    color?: EnumFeedbackColorWithAggregatesFilter | $Enums.FeedbackColor
    selectedValues?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    reportedBy?: StringWithAggregatesFilter | string
    responsiblePerson?: StringNullableWithAggregatesFilter | string | null
    actionTaken?: StringNullableWithAggregatesFilter | string | null
    status?: EnumStatusNullableWithAggregatesFilter | $Enums.Status | null
    userAcknowledgement?: StringNullableWithAggregatesFilter | string | null
    createdById?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FeedbackAssignmentWhereInput = {
    AND?: FeedbackAssignmentWhereInput | FeedbackAssignmentWhereInput[]
    OR?: FeedbackAssignmentWhereInput[]
    NOT?: FeedbackAssignmentWhereInput | FeedbackAssignmentWhereInput[]
    id?: IntFilter | number
    assignmentCompleted?: BoolFilter | boolean
    feedbackId?: IntFilter | number
    userId?: IntFilter | number
    feedback?: XOR<FeedbackRelationFilter, FeedbackWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FeedbackAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    assignmentCompleted?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
    feedback?: FeedbackOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FeedbackAssignmentWhereUniqueInput = {
    id?: number
  }

  export type FeedbackAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentCompleted?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
    _count?: FeedbackAssignmentCountOrderByAggregateInput
    _avg?: FeedbackAssignmentAvgOrderByAggregateInput
    _max?: FeedbackAssignmentMaxOrderByAggregateInput
    _min?: FeedbackAssignmentMinOrderByAggregateInput
    _sum?: FeedbackAssignmentSumOrderByAggregateInput
  }

  export type FeedbackAssignmentScalarWhereWithAggregatesInput = {
    AND?: FeedbackAssignmentScalarWhereWithAggregatesInput | FeedbackAssignmentScalarWhereWithAggregatesInput[]
    OR?: FeedbackAssignmentScalarWhereWithAggregatesInput[]
    NOT?: FeedbackAssignmentScalarWhereWithAggregatesInput | FeedbackAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    assignmentCompleted?: BoolWithAggregatesFilter | boolean
    feedbackId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type FeedbackFileWhereInput = {
    AND?: FeedbackFileWhereInput | FeedbackFileWhereInput[]
    OR?: FeedbackFileWhereInput[]
    NOT?: FeedbackFileWhereInput | FeedbackFileWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    feedbackId?: IntFilter | number
    feedback?: XOR<FeedbackRelationFilter, FeedbackWhereInput>
  }

  export type FeedbackFileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
    feedback?: FeedbackOrderByWithRelationInput
  }

  export type FeedbackFileWhereUniqueInput = {
    id?: number
  }

  export type FeedbackFileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
    _count?: FeedbackFileCountOrderByAggregateInput
    _avg?: FeedbackFileAvgOrderByAggregateInput
    _max?: FeedbackFileMaxOrderByAggregateInput
    _min?: FeedbackFileMinOrderByAggregateInput
    _sum?: FeedbackFileSumOrderByAggregateInput
  }

  export type FeedbackFileScalarWhereWithAggregatesInput = {
    AND?: FeedbackFileScalarWhereWithAggregatesInput | FeedbackFileScalarWhereWithAggregatesInput[]
    OR?: FeedbackFileScalarWhereWithAggregatesInput[]
    NOT?: FeedbackFileScalarWhereWithAggregatesInput | FeedbackFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    feedbackId?: IntWithAggregatesFilter | number
  }

  export type FeedbackActionFileWhereInput = {
    AND?: FeedbackActionFileWhereInput | FeedbackActionFileWhereInput[]
    OR?: FeedbackActionFileWhereInput[]
    NOT?: FeedbackActionFileWhereInput | FeedbackActionFileWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    feedbackId?: IntFilter | number
    feedback?: XOR<FeedbackRelationFilter, FeedbackWhereInput>
  }

  export type FeedbackActionFileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
    feedback?: FeedbackOrderByWithRelationInput
  }

  export type FeedbackActionFileWhereUniqueInput = {
    id?: number
  }

  export type FeedbackActionFileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
    _count?: FeedbackActionFileCountOrderByAggregateInput
    _avg?: FeedbackActionFileAvgOrderByAggregateInput
    _max?: FeedbackActionFileMaxOrderByAggregateInput
    _min?: FeedbackActionFileMinOrderByAggregateInput
    _sum?: FeedbackActionFileSumOrderByAggregateInput
  }

  export type FeedbackActionFileScalarWhereWithAggregatesInput = {
    AND?: FeedbackActionFileScalarWhereWithAggregatesInput | FeedbackActionFileScalarWhereWithAggregatesInput[]
    OR?: FeedbackActionFileScalarWhereWithAggregatesInput[]
    NOT?: FeedbackActionFileScalarWhereWithAggregatesInput | FeedbackActionFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    feedbackId?: IntWithAggregatesFilter | number
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    meetingId?: IntFilter | number
    meetCreater?: StringFilter | string
    meetDateTime?: DateTimeFilter | Date | string
    meetTitle?: StringFilter | string
    meetingTime?: IntFilter | number
    department?: StringFilter | string
    createrId?: IntFilter | number
    membersCount?: IntFilter | number
    isOnline?: BoolFilter | boolean
    attId?: IntNullableFilter | number | null
    meetEndTime?: DateTimeFilter | Date | string
    membersList?: MembersListListRelationFilter
    membersAttended?: MembersAttendedListRelationFilter
  }

  export type MeetingOrderByWithRelationInput = {
    meetingId?: SortOrder
    meetCreater?: SortOrder
    meetDateTime?: SortOrder
    meetTitle?: SortOrder
    meetingTime?: SortOrder
    department?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    isOnline?: SortOrder
    attId?: SortOrderInput | SortOrder
    meetEndTime?: SortOrder
    membersList?: MembersListOrderByRelationAggregateInput
    membersAttended?: MembersAttendedOrderByRelationAggregateInput
  }

  export type MeetingWhereUniqueInput = {
    meetingId?: number
  }

  export type MeetingOrderByWithAggregationInput = {
    meetingId?: SortOrder
    meetCreater?: SortOrder
    meetDateTime?: SortOrder
    meetTitle?: SortOrder
    meetingTime?: SortOrder
    department?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    isOnline?: SortOrder
    attId?: SortOrderInput | SortOrder
    meetEndTime?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    meetingId?: IntWithAggregatesFilter | number
    meetCreater?: StringWithAggregatesFilter | string
    meetDateTime?: DateTimeWithAggregatesFilter | Date | string
    meetTitle?: StringWithAggregatesFilter | string
    meetingTime?: IntWithAggregatesFilter | number
    department?: StringWithAggregatesFilter | string
    createrId?: IntWithAggregatesFilter | number
    membersCount?: IntWithAggregatesFilter | number
    isOnline?: BoolWithAggregatesFilter | boolean
    attId?: IntNullableWithAggregatesFilter | number | null
    meetEndTime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MembersListWhereInput = {
    AND?: MembersListWhereInput | MembersListWhereInput[]
    OR?: MembersListWhereInput[]
    NOT?: MembersListWhereInput | MembersListWhereInput[]
    id?: IntFilter | number
    memberId?: StringFilter | string
    memberName?: StringFilter | string
    meetingId?: IntFilter | number
    meeting?: XOR<MeetingRelationFilter, MeetingWhereInput>
  }

  export type MembersListOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    memberName?: SortOrder
    meetingId?: SortOrder
    meeting?: MeetingOrderByWithRelationInput
  }

  export type MembersListWhereUniqueInput = {
    id?: number
  }

  export type MembersListOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    memberName?: SortOrder
    meetingId?: SortOrder
    _count?: MembersListCountOrderByAggregateInput
    _avg?: MembersListAvgOrderByAggregateInput
    _max?: MembersListMaxOrderByAggregateInput
    _min?: MembersListMinOrderByAggregateInput
    _sum?: MembersListSumOrderByAggregateInput
  }

  export type MembersListScalarWhereWithAggregatesInput = {
    AND?: MembersListScalarWhereWithAggregatesInput | MembersListScalarWhereWithAggregatesInput[]
    OR?: MembersListScalarWhereWithAggregatesInput[]
    NOT?: MembersListScalarWhereWithAggregatesInput | MembersListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    memberId?: StringWithAggregatesFilter | string
    memberName?: StringWithAggregatesFilter | string
    meetingId?: IntWithAggregatesFilter | number
  }

  export type MembersAttendedWhereInput = {
    AND?: MembersAttendedWhereInput | MembersAttendedWhereInput[]
    OR?: MembersAttendedWhereInput[]
    NOT?: MembersAttendedWhereInput | MembersAttendedWhereInput[]
    id?: IntFilter | number
    memberId?: IntFilter | number
    membersName?: StringFilter | string
    memberInTime?: DateTimeFilter | Date | string
    memberOutTime?: DateTimeFilter | Date | string
    dateTime?: DateTimeFilter | Date | string
    latitude?: DecimalFilter | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter | Decimal | DecimalJsLike | number | string
    meetingId?: IntFilter | number
    digitalSignatureFile?: XOR<DigitalSignatureFileRelationFilter, DigitalSignatureFileWhereInput> | null
    meeting?: XOR<MeetingRelationFilter, MeetingWhereInput>
  }

  export type MembersAttendedOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    membersName?: SortOrder
    memberInTime?: SortOrder
    memberOutTime?: SortOrder
    dateTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
    digitalSignatureFile?: DigitalSignatureFileOrderByWithRelationInput
    meeting?: MeetingOrderByWithRelationInput
  }

  export type MembersAttendedWhereUniqueInput = {
    id?: number
  }

  export type MembersAttendedOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    membersName?: SortOrder
    memberInTime?: SortOrder
    memberOutTime?: SortOrder
    dateTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
    _count?: MembersAttendedCountOrderByAggregateInput
    _avg?: MembersAttendedAvgOrderByAggregateInput
    _max?: MembersAttendedMaxOrderByAggregateInput
    _min?: MembersAttendedMinOrderByAggregateInput
    _sum?: MembersAttendedSumOrderByAggregateInput
  }

  export type MembersAttendedScalarWhereWithAggregatesInput = {
    AND?: MembersAttendedScalarWhereWithAggregatesInput | MembersAttendedScalarWhereWithAggregatesInput[]
    OR?: MembersAttendedScalarWhereWithAggregatesInput[]
    NOT?: MembersAttendedScalarWhereWithAggregatesInput | MembersAttendedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    memberId?: IntWithAggregatesFilter | number
    membersName?: StringWithAggregatesFilter | string
    memberInTime?: DateTimeWithAggregatesFilter | Date | string
    memberOutTime?: DateTimeWithAggregatesFilter | Date | string
    dateTime?: DateTimeWithAggregatesFilter | Date | string
    latitude?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    longitude?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    meetingId?: IntWithAggregatesFilter | number
  }

  export type DigitalSignatureFileWhereInput = {
    AND?: DigitalSignatureFileWhereInput | DigitalSignatureFileWhereInput[]
    OR?: DigitalSignatureFileWhereInput[]
    NOT?: DigitalSignatureFileWhereInput | DigitalSignatureFileWhereInput[]
    fileId?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    path?: StringFilter | string
    attendanceId?: IntFilter | number
    attendance?: XOR<MembersAttendedRelationFilter, MembersAttendedWhereInput>
  }

  export type DigitalSignatureFileOrderByWithRelationInput = {
    fileId?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    attendanceId?: SortOrder
    attendance?: MembersAttendedOrderByWithRelationInput
  }

  export type DigitalSignatureFileWhereUniqueInput = {
    fileId?: number
    attendanceId?: number
  }

  export type DigitalSignatureFileOrderByWithAggregationInput = {
    fileId?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    attendanceId?: SortOrder
    _count?: DigitalSignatureFileCountOrderByAggregateInput
    _avg?: DigitalSignatureFileAvgOrderByAggregateInput
    _max?: DigitalSignatureFileMaxOrderByAggregateInput
    _min?: DigitalSignatureFileMinOrderByAggregateInput
    _sum?: DigitalSignatureFileSumOrderByAggregateInput
  }

  export type DigitalSignatureFileScalarWhereWithAggregatesInput = {
    AND?: DigitalSignatureFileScalarWhereWithAggregatesInput | DigitalSignatureFileScalarWhereWithAggregatesInput[]
    OR?: DigitalSignatureFileScalarWhereWithAggregatesInput[]
    NOT?: DigitalSignatureFileScalarWhereWithAggregatesInput | DigitalSignatureFileScalarWhereWithAggregatesInput[]
    fileId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    path?: StringWithAggregatesFilter | string
    attendanceId?: IntWithAggregatesFilter | number
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    formId?: IntFilter | number
    formTitle?: StringFilter | string
    formResult?: StringFilter | string
    username?: StringFilter | string
    userId?: StringFilter | string
    dateAndTime?: StringFilter | string
    description?: StringFilter | string
    status?: StringFilter | string
    q1?: StringNullableFilter | string | null
    q2?: StringNullableFilter | string | null
    q3?: StringNullableFilter | string | null
    q4?: StringNullableFilter | string | null
    q5?: StringNullableFilter | string | null
    q6?: StringNullableFilter | string | null
    q7?: StringNullableFilter | string | null
    q8?: StringNullableFilter | string | null
    q9?: StringNullableFilter | string | null
    q10?: StringNullableFilter | string | null
    q11?: StringNullableFilter | string | null
    q12?: StringNullableFilter | string | null
    q13?: StringNullableFilter | string | null
    q14?: StringNullableFilter | string | null
    q15?: StringNullableFilter | string | null
    q16?: StringNullableFilter | string | null
    q17?: StringNullableFilter | string | null
    q18?: StringNullableFilter | string | null
    q19?: StringNullableFilter | string | null
    q20?: StringNullableFilter | string | null
    q21?: StringNullableFilter | string | null
    q22?: StringNullableFilter | string | null
    q23?: StringNullableFilter | string | null
    q24?: StringNullableFilter | string | null
    q25?: StringNullableFilter | string | null
    q26?: StringNullableFilter | string | null
    q27?: StringNullableFilter | string | null
    q28?: StringNullableFilter | string | null
    q29?: StringNullableFilter | string | null
    q30?: StringNullableFilter | string | null
    q31?: StringNullableFilter | string | null
    q32?: StringNullableFilter | string | null
    q33?: StringNullableFilter | string | null
    q34?: StringNullableFilter | string | null
    q35?: StringNullableFilter | string | null
    q36?: StringNullableFilter | string | null
    q37?: StringNullableFilter | string | null
    q38?: StringNullableFilter | string | null
    q39?: StringNullableFilter | string | null
    q40?: StringNullableFilter | string | null
    q41?: StringNullableFilter | string | null
    q42?: StringNullableFilter | string | null
    q43?: StringNullableFilter | string | null
    q44?: StringNullableFilter | string | null
    q45?: StringNullableFilter | string | null
    q46?: StringNullableFilter | string | null
    q47?: StringNullableFilter | string | null
    q48?: StringNullableFilter | string | null
    q49?: StringNullableFilter | string | null
    q50?: StringNullableFilter | string | null
  }

  export type FormOrderByWithRelationInput = {
    formId?: SortOrder
    formTitle?: SortOrder
    formResult?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    dateAndTime?: SortOrder
    description?: SortOrder
    status?: SortOrder
    q1?: SortOrderInput | SortOrder
    q2?: SortOrderInput | SortOrder
    q3?: SortOrderInput | SortOrder
    q4?: SortOrderInput | SortOrder
    q5?: SortOrderInput | SortOrder
    q6?: SortOrderInput | SortOrder
    q7?: SortOrderInput | SortOrder
    q8?: SortOrderInput | SortOrder
    q9?: SortOrderInput | SortOrder
    q10?: SortOrderInput | SortOrder
    q11?: SortOrderInput | SortOrder
    q12?: SortOrderInput | SortOrder
    q13?: SortOrderInput | SortOrder
    q14?: SortOrderInput | SortOrder
    q15?: SortOrderInput | SortOrder
    q16?: SortOrderInput | SortOrder
    q17?: SortOrderInput | SortOrder
    q18?: SortOrderInput | SortOrder
    q19?: SortOrderInput | SortOrder
    q20?: SortOrderInput | SortOrder
    q21?: SortOrderInput | SortOrder
    q22?: SortOrderInput | SortOrder
    q23?: SortOrderInput | SortOrder
    q24?: SortOrderInput | SortOrder
    q25?: SortOrderInput | SortOrder
    q26?: SortOrderInput | SortOrder
    q27?: SortOrderInput | SortOrder
    q28?: SortOrderInput | SortOrder
    q29?: SortOrderInput | SortOrder
    q30?: SortOrderInput | SortOrder
    q31?: SortOrderInput | SortOrder
    q32?: SortOrderInput | SortOrder
    q33?: SortOrderInput | SortOrder
    q34?: SortOrderInput | SortOrder
    q35?: SortOrderInput | SortOrder
    q36?: SortOrderInput | SortOrder
    q37?: SortOrderInput | SortOrder
    q38?: SortOrderInput | SortOrder
    q39?: SortOrderInput | SortOrder
    q40?: SortOrderInput | SortOrder
    q41?: SortOrderInput | SortOrder
    q42?: SortOrderInput | SortOrder
    q43?: SortOrderInput | SortOrder
    q44?: SortOrderInput | SortOrder
    q45?: SortOrderInput | SortOrder
    q46?: SortOrderInput | SortOrder
    q47?: SortOrderInput | SortOrder
    q48?: SortOrderInput | SortOrder
    q49?: SortOrderInput | SortOrder
    q50?: SortOrderInput | SortOrder
  }

  export type FormWhereUniqueInput = {
    formId?: number
  }

  export type FormOrderByWithAggregationInput = {
    formId?: SortOrder
    formTitle?: SortOrder
    formResult?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    dateAndTime?: SortOrder
    description?: SortOrder
    status?: SortOrder
    q1?: SortOrderInput | SortOrder
    q2?: SortOrderInput | SortOrder
    q3?: SortOrderInput | SortOrder
    q4?: SortOrderInput | SortOrder
    q5?: SortOrderInput | SortOrder
    q6?: SortOrderInput | SortOrder
    q7?: SortOrderInput | SortOrder
    q8?: SortOrderInput | SortOrder
    q9?: SortOrderInput | SortOrder
    q10?: SortOrderInput | SortOrder
    q11?: SortOrderInput | SortOrder
    q12?: SortOrderInput | SortOrder
    q13?: SortOrderInput | SortOrder
    q14?: SortOrderInput | SortOrder
    q15?: SortOrderInput | SortOrder
    q16?: SortOrderInput | SortOrder
    q17?: SortOrderInput | SortOrder
    q18?: SortOrderInput | SortOrder
    q19?: SortOrderInput | SortOrder
    q20?: SortOrderInput | SortOrder
    q21?: SortOrderInput | SortOrder
    q22?: SortOrderInput | SortOrder
    q23?: SortOrderInput | SortOrder
    q24?: SortOrderInput | SortOrder
    q25?: SortOrderInput | SortOrder
    q26?: SortOrderInput | SortOrder
    q27?: SortOrderInput | SortOrder
    q28?: SortOrderInput | SortOrder
    q29?: SortOrderInput | SortOrder
    q30?: SortOrderInput | SortOrder
    q31?: SortOrderInput | SortOrder
    q32?: SortOrderInput | SortOrder
    q33?: SortOrderInput | SortOrder
    q34?: SortOrderInput | SortOrder
    q35?: SortOrderInput | SortOrder
    q36?: SortOrderInput | SortOrder
    q37?: SortOrderInput | SortOrder
    q38?: SortOrderInput | SortOrder
    q39?: SortOrderInput | SortOrder
    q40?: SortOrderInput | SortOrder
    q41?: SortOrderInput | SortOrder
    q42?: SortOrderInput | SortOrder
    q43?: SortOrderInput | SortOrder
    q44?: SortOrderInput | SortOrder
    q45?: SortOrderInput | SortOrder
    q46?: SortOrderInput | SortOrder
    q47?: SortOrderInput | SortOrder
    q48?: SortOrderInput | SortOrder
    q49?: SortOrderInput | SortOrder
    q50?: SortOrderInput | SortOrder
    _count?: FormCountOrderByAggregateInput
    _avg?: FormAvgOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
    _sum?: FormSumOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    formId?: IntWithAggregatesFilter | number
    formTitle?: StringWithAggregatesFilter | string
    formResult?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    dateAndTime?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    q1?: StringNullableWithAggregatesFilter | string | null
    q2?: StringNullableWithAggregatesFilter | string | null
    q3?: StringNullableWithAggregatesFilter | string | null
    q4?: StringNullableWithAggregatesFilter | string | null
    q5?: StringNullableWithAggregatesFilter | string | null
    q6?: StringNullableWithAggregatesFilter | string | null
    q7?: StringNullableWithAggregatesFilter | string | null
    q8?: StringNullableWithAggregatesFilter | string | null
    q9?: StringNullableWithAggregatesFilter | string | null
    q10?: StringNullableWithAggregatesFilter | string | null
    q11?: StringNullableWithAggregatesFilter | string | null
    q12?: StringNullableWithAggregatesFilter | string | null
    q13?: StringNullableWithAggregatesFilter | string | null
    q14?: StringNullableWithAggregatesFilter | string | null
    q15?: StringNullableWithAggregatesFilter | string | null
    q16?: StringNullableWithAggregatesFilter | string | null
    q17?: StringNullableWithAggregatesFilter | string | null
    q18?: StringNullableWithAggregatesFilter | string | null
    q19?: StringNullableWithAggregatesFilter | string | null
    q20?: StringNullableWithAggregatesFilter | string | null
    q21?: StringNullableWithAggregatesFilter | string | null
    q22?: StringNullableWithAggregatesFilter | string | null
    q23?: StringNullableWithAggregatesFilter | string | null
    q24?: StringNullableWithAggregatesFilter | string | null
    q25?: StringNullableWithAggregatesFilter | string | null
    q26?: StringNullableWithAggregatesFilter | string | null
    q27?: StringNullableWithAggregatesFilter | string | null
    q28?: StringNullableWithAggregatesFilter | string | null
    q29?: StringNullableWithAggregatesFilter | string | null
    q30?: StringNullableWithAggregatesFilter | string | null
    q31?: StringNullableWithAggregatesFilter | string | null
    q32?: StringNullableWithAggregatesFilter | string | null
    q33?: StringNullableWithAggregatesFilter | string | null
    q34?: StringNullableWithAggregatesFilter | string | null
    q35?: StringNullableWithAggregatesFilter | string | null
    q36?: StringNullableWithAggregatesFilter | string | null
    q37?: StringNullableWithAggregatesFilter | string | null
    q38?: StringNullableWithAggregatesFilter | string | null
    q39?: StringNullableWithAggregatesFilter | string | null
    q40?: StringNullableWithAggregatesFilter | string | null
    q41?: StringNullableWithAggregatesFilter | string | null
    q42?: StringNullableWithAggregatesFilter | string | null
    q43?: StringNullableWithAggregatesFilter | string | null
    q44?: StringNullableWithAggregatesFilter | string | null
    q45?: StringNullableWithAggregatesFilter | string | null
    q46?: StringNullableWithAggregatesFilter | string | null
    q47?: StringNullableWithAggregatesFilter | string | null
    q48?: StringNullableWithAggregatesFilter | string | null
    q49?: StringNullableWithAggregatesFilter | string | null
    q50?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserCreateInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutCreatedByInput
    reads?: ReadCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    reads?: ReadUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    avatar?: string | null
    name: string
    createdAt?: Date | string
    members?: MemberCreateNestedManyWithoutGroupInput
    assessments?: RiskAssessmentCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    avatar?: string | null
    name: string
    createdAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutGroupInput
    assessments?: RiskAssessmentUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupUpdateInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutGroupNestedInput
    assessments?: RiskAssessmentUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutGroupNestedInput
    assessments?: RiskAssessmentUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    avatar?: string | null
    name: string
    createdAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateInput = {
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMemberInGroupsInput
  }

  export type MemberUncheckedCreateInput = {
    groupId: number
    userId: number
  }

  export type MemberUpdateInput = {
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMemberInGroupsNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MemberCreateManyInput = {
    groupId: number
    userId: number
  }

  export type MemberUpdateManyMutationInput = {

  }

  export type MemberUncheckedUpdateManyInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageCreateInput = {
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
    read?: ReadCreateNestedManyWithoutMessageInput
    files?: FileCreateNestedManyWithoutMessageInput
    createdBy: UserCreateNestedOneWithoutMessagesInput
    groups?: GroupCreateNestedManyWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdById: number
    createdAt?: Date | string
    read?: ReadUncheckedCreateNestedManyWithoutMessageInput
    files?: FileUncheckedCreateNestedManyWithoutMessageInput
    groups?: GroupUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessageUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUpdateManyWithoutMessageNestedInput
    files?: FileUpdateManyWithoutMessageNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMessagesNestedInput
    groups?: GroupUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUncheckedUpdateManyWithoutMessageNestedInput
    files?: FileUncheckedUpdateManyWithoutMessageNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessageCreateManyInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdById: number
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadCreateInput = {
    groupId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadInput
    user: UserCreateNestedOneWithoutReadsInput
  }

  export type ReadUncheckedCreateInput = {
    id?: number
    messageId: number
    groupId: number
    userId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
  }

  export type ReadUpdateInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadNestedInput
    user?: UserUpdateOneRequiredWithoutReadsNestedInput
  }

  export type ReadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadCreateManyInput = {
    id?: number
    messageId: number
    groupId: number
    userId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
  }

  export type ReadUpdateManyMutationInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    name: string
    fileType: string
    message: MessageCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: number
    name: string
    fileType: string
    messageId: number
  }

  export type FileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    message?: MessageUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
  }

  export type FileCreateManyInput = {
    id?: number
    name: string
    fileType: string
    messageId: number
  }

  export type FileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    messageId?: IntFieldUpdateOperationsInput | number
  }

  export type RiskAssessmentCreateInput = {
    name: string
    createdAt?: Date | string
    group: GroupCreateNestedOneWithoutAssessmentsInput
  }

  export type RiskAssessmentUncheckedCreateInput = {
    id?: number
    name: string
    groupId: number
    createdAt?: Date | string
  }

  export type RiskAssessmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type RiskAssessmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateManyInput = {
    id?: number
    name: string
    groupId: number
    createdAt?: Date | string
  }

  export type RiskAssessmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtherFileCreateInput = {
    name: string
    createdAt?: Date | string
  }

  export type OtherFileUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type OtherFileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtherFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtherFileCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type OtherFileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtherFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationCreateInput = {
    name: string
    createdAt?: Date | string
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserOrientationInput
  }

  export type UserOrientationUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserOrientationInput
  }

  export type UserOrientationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserOrientationNestedInput
  }

  export type UserOrientationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserOrientationNestedInput
  }

  export type UserOrientationCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type UserOrientationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationReadCreateInput = {
    readAt?: Date | string
    userOrientation: UserOrientationCreateNestedOneWithoutUserOrientationReadsInput
    user: UserCreateNestedOneWithoutUserOrientationReadsInput
  }

  export type UserOrientationReadUncheckedCreateInput = {
    id?: number
    userOrientationId: number
    userId: number
    readAt?: Date | string
  }

  export type UserOrientationReadUpdateInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userOrientation?: UserOrientationUpdateOneRequiredWithoutUserOrientationReadsNestedInput
    user?: UserUpdateOneRequiredWithoutUserOrientationReadsNestedInput
  }

  export type UserOrientationReadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOrientationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationReadCreateManyInput = {
    id?: number
    userOrientationId: number
    userId: number
    readAt?: Date | string
  }

  export type UserOrientationReadUpdateManyMutationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationReadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOrientationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
    files?: FeedbackFileCreateNestedManyWithoutFeedbackInput
    actionFiles?: FeedbackActionFileCreateNestedManyWithoutFeedbackInput
    createdBy: UserCreateNestedOneWithoutFeedbacksInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdById: number
    createdAt?: Date | string
    files?: FeedbackFileUncheckedCreateNestedManyWithoutFeedbackInput
    actionFiles?: FeedbackActionFileUncheckedCreateNestedManyWithoutFeedbackInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUpdateInput = {
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUpdateManyWithoutFeedbackNestedInput
    actionFiles?: FeedbackActionFileUpdateManyWithoutFeedbackNestedInput
    createdBy?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUncheckedUpdateManyWithoutFeedbackNestedInput
    actionFiles?: FeedbackActionFileUncheckedUpdateManyWithoutFeedbackNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackCreateManyInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdById: number
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackAssignmentCreateInput = {
    assignmentCompleted: boolean
    feedback: FeedbackCreateNestedOneWithoutFeedbackAssignmentsInput
    user: UserCreateNestedOneWithoutFeedbackAssignmentsInput
  }

  export type FeedbackAssignmentUncheckedCreateInput = {
    id?: number
    assignmentCompleted: boolean
    feedbackId: number
    userId: number
  }

  export type FeedbackAssignmentUpdateInput = {
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedback?: FeedbackUpdateOneRequiredWithoutFeedbackAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutFeedbackAssignmentsNestedInput
  }

  export type FeedbackAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedbackId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackAssignmentCreateManyInput = {
    id?: number
    assignmentCompleted: boolean
    feedbackId: number
    userId: number
  }

  export type FeedbackAssignmentUpdateManyMutationInput = {
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeedbackAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedbackId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackFileCreateInput = {
    name: string
    fileType: string
    feedback: FeedbackCreateNestedOneWithoutFilesInput
  }

  export type FeedbackFileUncheckedCreateInput = {
    id?: number
    name: string
    fileType: string
    feedbackId: number
  }

  export type FeedbackFileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    feedback?: FeedbackUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FeedbackFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackFileCreateManyInput = {
    id?: number
    name: string
    fileType: string
    feedbackId: number
  }

  export type FeedbackFileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackActionFileCreateInput = {
    name: string
    fileType: string
    feedback: FeedbackCreateNestedOneWithoutActionFilesInput
  }

  export type FeedbackActionFileUncheckedCreateInput = {
    id?: number
    name: string
    fileType: string
    feedbackId: number
  }

  export type FeedbackActionFileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    feedback?: FeedbackUpdateOneRequiredWithoutActionFilesNestedInput
  }

  export type FeedbackActionFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackActionFileCreateManyInput = {
    id?: number
    name: string
    fileType: string
    feedbackId: number
  }

  export type FeedbackActionFileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackActionFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type MeetingCreateInput = {
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
    membersList?: MembersListCreateNestedManyWithoutMeetingInput
    membersAttended?: MembersAttendedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateInput = {
    meetingId?: number
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
    membersList?: MembersListUncheckedCreateNestedManyWithoutMeetingInput
    membersAttended?: MembersAttendedUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUpdateInput = {
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    membersList?: MembersListUpdateManyWithoutMeetingNestedInput
    membersAttended?: MembersAttendedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    meetingId?: IntFieldUpdateOperationsInput | number
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    membersList?: MembersListUncheckedUpdateManyWithoutMeetingNestedInput
    membersAttended?: MembersAttendedUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingCreateManyInput = {
    meetingId?: number
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
  }

  export type MeetingUpdateManyMutationInput = {
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    meetingId?: IntFieldUpdateOperationsInput | number
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembersListCreateInput = {
    memberId: string
    memberName: string
    meeting: MeetingCreateNestedOneWithoutMembersListInput
  }

  export type MembersListUncheckedCreateInput = {
    id?: number
    memberId: string
    memberName: string
    meetingId: number
  }

  export type MembersListUpdateInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    meeting?: MeetingUpdateOneRequiredWithoutMembersListNestedInput
  }

  export type MembersListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    meetingId?: IntFieldUpdateOperationsInput | number
  }

  export type MembersListCreateManyInput = {
    id?: number
    memberId: string
    memberName: string
    meetingId: number
  }

  export type MembersListUpdateManyMutationInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
  }

  export type MembersListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    meetingId?: IntFieldUpdateOperationsInput | number
  }

  export type MembersAttendedCreateInput = {
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    digitalSignatureFile?: DigitalSignatureFileCreateNestedOneWithoutAttendanceInput
    meeting: MeetingCreateNestedOneWithoutMembersAttendedInput
  }

  export type MembersAttendedUncheckedCreateInput = {
    id?: number
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    meetingId: number
    digitalSignatureFile?: DigitalSignatureFileUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type MembersAttendedUpdateInput = {
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    digitalSignatureFile?: DigitalSignatureFileUpdateOneWithoutAttendanceNestedInput
    meeting?: MeetingUpdateOneRequiredWithoutMembersAttendedNestedInput
  }

  export type MembersAttendedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingId?: IntFieldUpdateOperationsInput | number
    digitalSignatureFile?: DigitalSignatureFileUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type MembersAttendedCreateManyInput = {
    id?: number
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    meetingId: number
  }

  export type MembersAttendedUpdateManyMutationInput = {
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MembersAttendedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingId?: IntFieldUpdateOperationsInput | number
  }

  export type DigitalSignatureFileCreateInput = {
    name: string
    fileType: string
    path: string
    attendance: MembersAttendedCreateNestedOneWithoutDigitalSignatureFileInput
  }

  export type DigitalSignatureFileUncheckedCreateInput = {
    fileId?: number
    name: string
    fileType: string
    path: string
    attendanceId: number
  }

  export type DigitalSignatureFileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    attendance?: MembersAttendedUpdateOneRequiredWithoutDigitalSignatureFileNestedInput
  }

  export type DigitalSignatureFileUncheckedUpdateInput = {
    fileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    attendanceId?: IntFieldUpdateOperationsInput | number
  }

  export type DigitalSignatureFileCreateManyInput = {
    fileId?: number
    name: string
    fileType: string
    path: string
    attendanceId: number
  }

  export type DigitalSignatureFileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type DigitalSignatureFileUncheckedUpdateManyInput = {
    fileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    attendanceId?: IntFieldUpdateOperationsInput | number
  }

  export type FormCreateInput = {
    formTitle: string
    formResult: string
    username: string
    userId: string
    dateAndTime: string
    description: string
    status: string
    q1?: string | null
    q2?: string | null
    q3?: string | null
    q4?: string | null
    q5?: string | null
    q6?: string | null
    q7?: string | null
    q8?: string | null
    q9?: string | null
    q10?: string | null
    q11?: string | null
    q12?: string | null
    q13?: string | null
    q14?: string | null
    q15?: string | null
    q16?: string | null
    q17?: string | null
    q18?: string | null
    q19?: string | null
    q20?: string | null
    q21?: string | null
    q22?: string | null
    q23?: string | null
    q24?: string | null
    q25?: string | null
    q26?: string | null
    q27?: string | null
    q28?: string | null
    q29?: string | null
    q30?: string | null
    q31?: string | null
    q32?: string | null
    q33?: string | null
    q34?: string | null
    q35?: string | null
    q36?: string | null
    q37?: string | null
    q38?: string | null
    q39?: string | null
    q40?: string | null
    q41?: string | null
    q42?: string | null
    q43?: string | null
    q44?: string | null
    q45?: string | null
    q46?: string | null
    q47?: string | null
    q48?: string | null
    q49?: string | null
    q50?: string | null
  }

  export type FormUncheckedCreateInput = {
    formId?: number
    formTitle: string
    formResult: string
    username: string
    userId: string
    dateAndTime: string
    description: string
    status: string
    q1?: string | null
    q2?: string | null
    q3?: string | null
    q4?: string | null
    q5?: string | null
    q6?: string | null
    q7?: string | null
    q8?: string | null
    q9?: string | null
    q10?: string | null
    q11?: string | null
    q12?: string | null
    q13?: string | null
    q14?: string | null
    q15?: string | null
    q16?: string | null
    q17?: string | null
    q18?: string | null
    q19?: string | null
    q20?: string | null
    q21?: string | null
    q22?: string | null
    q23?: string | null
    q24?: string | null
    q25?: string | null
    q26?: string | null
    q27?: string | null
    q28?: string | null
    q29?: string | null
    q30?: string | null
    q31?: string | null
    q32?: string | null
    q33?: string | null
    q34?: string | null
    q35?: string | null
    q36?: string | null
    q37?: string | null
    q38?: string | null
    q39?: string | null
    q40?: string | null
    q41?: string | null
    q42?: string | null
    q43?: string | null
    q44?: string | null
    q45?: string | null
    q46?: string | null
    q47?: string | null
    q48?: string | null
    q49?: string | null
    q50?: string | null
  }

  export type FormUpdateInput = {
    formTitle?: StringFieldUpdateOperationsInput | string
    formResult?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAndTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    q1?: NullableStringFieldUpdateOperationsInput | string | null
    q2?: NullableStringFieldUpdateOperationsInput | string | null
    q3?: NullableStringFieldUpdateOperationsInput | string | null
    q4?: NullableStringFieldUpdateOperationsInput | string | null
    q5?: NullableStringFieldUpdateOperationsInput | string | null
    q6?: NullableStringFieldUpdateOperationsInput | string | null
    q7?: NullableStringFieldUpdateOperationsInput | string | null
    q8?: NullableStringFieldUpdateOperationsInput | string | null
    q9?: NullableStringFieldUpdateOperationsInput | string | null
    q10?: NullableStringFieldUpdateOperationsInput | string | null
    q11?: NullableStringFieldUpdateOperationsInput | string | null
    q12?: NullableStringFieldUpdateOperationsInput | string | null
    q13?: NullableStringFieldUpdateOperationsInput | string | null
    q14?: NullableStringFieldUpdateOperationsInput | string | null
    q15?: NullableStringFieldUpdateOperationsInput | string | null
    q16?: NullableStringFieldUpdateOperationsInput | string | null
    q17?: NullableStringFieldUpdateOperationsInput | string | null
    q18?: NullableStringFieldUpdateOperationsInput | string | null
    q19?: NullableStringFieldUpdateOperationsInput | string | null
    q20?: NullableStringFieldUpdateOperationsInput | string | null
    q21?: NullableStringFieldUpdateOperationsInput | string | null
    q22?: NullableStringFieldUpdateOperationsInput | string | null
    q23?: NullableStringFieldUpdateOperationsInput | string | null
    q24?: NullableStringFieldUpdateOperationsInput | string | null
    q25?: NullableStringFieldUpdateOperationsInput | string | null
    q26?: NullableStringFieldUpdateOperationsInput | string | null
    q27?: NullableStringFieldUpdateOperationsInput | string | null
    q28?: NullableStringFieldUpdateOperationsInput | string | null
    q29?: NullableStringFieldUpdateOperationsInput | string | null
    q30?: NullableStringFieldUpdateOperationsInput | string | null
    q31?: NullableStringFieldUpdateOperationsInput | string | null
    q32?: NullableStringFieldUpdateOperationsInput | string | null
    q33?: NullableStringFieldUpdateOperationsInput | string | null
    q34?: NullableStringFieldUpdateOperationsInput | string | null
    q35?: NullableStringFieldUpdateOperationsInput | string | null
    q36?: NullableStringFieldUpdateOperationsInput | string | null
    q37?: NullableStringFieldUpdateOperationsInput | string | null
    q38?: NullableStringFieldUpdateOperationsInput | string | null
    q39?: NullableStringFieldUpdateOperationsInput | string | null
    q40?: NullableStringFieldUpdateOperationsInput | string | null
    q41?: NullableStringFieldUpdateOperationsInput | string | null
    q42?: NullableStringFieldUpdateOperationsInput | string | null
    q43?: NullableStringFieldUpdateOperationsInput | string | null
    q44?: NullableStringFieldUpdateOperationsInput | string | null
    q45?: NullableStringFieldUpdateOperationsInput | string | null
    q46?: NullableStringFieldUpdateOperationsInput | string | null
    q47?: NullableStringFieldUpdateOperationsInput | string | null
    q48?: NullableStringFieldUpdateOperationsInput | string | null
    q49?: NullableStringFieldUpdateOperationsInput | string | null
    q50?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormUncheckedUpdateInput = {
    formId?: IntFieldUpdateOperationsInput | number
    formTitle?: StringFieldUpdateOperationsInput | string
    formResult?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAndTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    q1?: NullableStringFieldUpdateOperationsInput | string | null
    q2?: NullableStringFieldUpdateOperationsInput | string | null
    q3?: NullableStringFieldUpdateOperationsInput | string | null
    q4?: NullableStringFieldUpdateOperationsInput | string | null
    q5?: NullableStringFieldUpdateOperationsInput | string | null
    q6?: NullableStringFieldUpdateOperationsInput | string | null
    q7?: NullableStringFieldUpdateOperationsInput | string | null
    q8?: NullableStringFieldUpdateOperationsInput | string | null
    q9?: NullableStringFieldUpdateOperationsInput | string | null
    q10?: NullableStringFieldUpdateOperationsInput | string | null
    q11?: NullableStringFieldUpdateOperationsInput | string | null
    q12?: NullableStringFieldUpdateOperationsInput | string | null
    q13?: NullableStringFieldUpdateOperationsInput | string | null
    q14?: NullableStringFieldUpdateOperationsInput | string | null
    q15?: NullableStringFieldUpdateOperationsInput | string | null
    q16?: NullableStringFieldUpdateOperationsInput | string | null
    q17?: NullableStringFieldUpdateOperationsInput | string | null
    q18?: NullableStringFieldUpdateOperationsInput | string | null
    q19?: NullableStringFieldUpdateOperationsInput | string | null
    q20?: NullableStringFieldUpdateOperationsInput | string | null
    q21?: NullableStringFieldUpdateOperationsInput | string | null
    q22?: NullableStringFieldUpdateOperationsInput | string | null
    q23?: NullableStringFieldUpdateOperationsInput | string | null
    q24?: NullableStringFieldUpdateOperationsInput | string | null
    q25?: NullableStringFieldUpdateOperationsInput | string | null
    q26?: NullableStringFieldUpdateOperationsInput | string | null
    q27?: NullableStringFieldUpdateOperationsInput | string | null
    q28?: NullableStringFieldUpdateOperationsInput | string | null
    q29?: NullableStringFieldUpdateOperationsInput | string | null
    q30?: NullableStringFieldUpdateOperationsInput | string | null
    q31?: NullableStringFieldUpdateOperationsInput | string | null
    q32?: NullableStringFieldUpdateOperationsInput | string | null
    q33?: NullableStringFieldUpdateOperationsInput | string | null
    q34?: NullableStringFieldUpdateOperationsInput | string | null
    q35?: NullableStringFieldUpdateOperationsInput | string | null
    q36?: NullableStringFieldUpdateOperationsInput | string | null
    q37?: NullableStringFieldUpdateOperationsInput | string | null
    q38?: NullableStringFieldUpdateOperationsInput | string | null
    q39?: NullableStringFieldUpdateOperationsInput | string | null
    q40?: NullableStringFieldUpdateOperationsInput | string | null
    q41?: NullableStringFieldUpdateOperationsInput | string | null
    q42?: NullableStringFieldUpdateOperationsInput | string | null
    q43?: NullableStringFieldUpdateOperationsInput | string | null
    q44?: NullableStringFieldUpdateOperationsInput | string | null
    q45?: NullableStringFieldUpdateOperationsInput | string | null
    q46?: NullableStringFieldUpdateOperationsInput | string | null
    q47?: NullableStringFieldUpdateOperationsInput | string | null
    q48?: NullableStringFieldUpdateOperationsInput | string | null
    q49?: NullableStringFieldUpdateOperationsInput | string | null
    q50?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormCreateManyInput = {
    formId?: number
    formTitle: string
    formResult: string
    username: string
    userId: string
    dateAndTime: string
    description: string
    status: string
    q1?: string | null
    q2?: string | null
    q3?: string | null
    q4?: string | null
    q5?: string | null
    q6?: string | null
    q7?: string | null
    q8?: string | null
    q9?: string | null
    q10?: string | null
    q11?: string | null
    q12?: string | null
    q13?: string | null
    q14?: string | null
    q15?: string | null
    q16?: string | null
    q17?: string | null
    q18?: string | null
    q19?: string | null
    q20?: string | null
    q21?: string | null
    q22?: string | null
    q23?: string | null
    q24?: string | null
    q25?: string | null
    q26?: string | null
    q27?: string | null
    q28?: string | null
    q29?: string | null
    q30?: string | null
    q31?: string | null
    q32?: string | null
    q33?: string | null
    q34?: string | null
    q35?: string | null
    q36?: string | null
    q37?: string | null
    q38?: string | null
    q39?: string | null
    q40?: string | null
    q41?: string | null
    q42?: string | null
    q43?: string | null
    q44?: string | null
    q45?: string | null
    q46?: string | null
    q47?: string | null
    q48?: string | null
    q49?: string | null
    q50?: string | null
  }

  export type FormUpdateManyMutationInput = {
    formTitle?: StringFieldUpdateOperationsInput | string
    formResult?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAndTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    q1?: NullableStringFieldUpdateOperationsInput | string | null
    q2?: NullableStringFieldUpdateOperationsInput | string | null
    q3?: NullableStringFieldUpdateOperationsInput | string | null
    q4?: NullableStringFieldUpdateOperationsInput | string | null
    q5?: NullableStringFieldUpdateOperationsInput | string | null
    q6?: NullableStringFieldUpdateOperationsInput | string | null
    q7?: NullableStringFieldUpdateOperationsInput | string | null
    q8?: NullableStringFieldUpdateOperationsInput | string | null
    q9?: NullableStringFieldUpdateOperationsInput | string | null
    q10?: NullableStringFieldUpdateOperationsInput | string | null
    q11?: NullableStringFieldUpdateOperationsInput | string | null
    q12?: NullableStringFieldUpdateOperationsInput | string | null
    q13?: NullableStringFieldUpdateOperationsInput | string | null
    q14?: NullableStringFieldUpdateOperationsInput | string | null
    q15?: NullableStringFieldUpdateOperationsInput | string | null
    q16?: NullableStringFieldUpdateOperationsInput | string | null
    q17?: NullableStringFieldUpdateOperationsInput | string | null
    q18?: NullableStringFieldUpdateOperationsInput | string | null
    q19?: NullableStringFieldUpdateOperationsInput | string | null
    q20?: NullableStringFieldUpdateOperationsInput | string | null
    q21?: NullableStringFieldUpdateOperationsInput | string | null
    q22?: NullableStringFieldUpdateOperationsInput | string | null
    q23?: NullableStringFieldUpdateOperationsInput | string | null
    q24?: NullableStringFieldUpdateOperationsInput | string | null
    q25?: NullableStringFieldUpdateOperationsInput | string | null
    q26?: NullableStringFieldUpdateOperationsInput | string | null
    q27?: NullableStringFieldUpdateOperationsInput | string | null
    q28?: NullableStringFieldUpdateOperationsInput | string | null
    q29?: NullableStringFieldUpdateOperationsInput | string | null
    q30?: NullableStringFieldUpdateOperationsInput | string | null
    q31?: NullableStringFieldUpdateOperationsInput | string | null
    q32?: NullableStringFieldUpdateOperationsInput | string | null
    q33?: NullableStringFieldUpdateOperationsInput | string | null
    q34?: NullableStringFieldUpdateOperationsInput | string | null
    q35?: NullableStringFieldUpdateOperationsInput | string | null
    q36?: NullableStringFieldUpdateOperationsInput | string | null
    q37?: NullableStringFieldUpdateOperationsInput | string | null
    q38?: NullableStringFieldUpdateOperationsInput | string | null
    q39?: NullableStringFieldUpdateOperationsInput | string | null
    q40?: NullableStringFieldUpdateOperationsInput | string | null
    q41?: NullableStringFieldUpdateOperationsInput | string | null
    q42?: NullableStringFieldUpdateOperationsInput | string | null
    q43?: NullableStringFieldUpdateOperationsInput | string | null
    q44?: NullableStringFieldUpdateOperationsInput | string | null
    q45?: NullableStringFieldUpdateOperationsInput | string | null
    q46?: NullableStringFieldUpdateOperationsInput | string | null
    q47?: NullableStringFieldUpdateOperationsInput | string | null
    q48?: NullableStringFieldUpdateOperationsInput | string | null
    q49?: NullableStringFieldUpdateOperationsInput | string | null
    q50?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormUncheckedUpdateManyInput = {
    formId?: IntFieldUpdateOperationsInput | number
    formTitle?: StringFieldUpdateOperationsInput | string
    formResult?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dateAndTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    q1?: NullableStringFieldUpdateOperationsInput | string | null
    q2?: NullableStringFieldUpdateOperationsInput | string | null
    q3?: NullableStringFieldUpdateOperationsInput | string | null
    q4?: NullableStringFieldUpdateOperationsInput | string | null
    q5?: NullableStringFieldUpdateOperationsInput | string | null
    q6?: NullableStringFieldUpdateOperationsInput | string | null
    q7?: NullableStringFieldUpdateOperationsInput | string | null
    q8?: NullableStringFieldUpdateOperationsInput | string | null
    q9?: NullableStringFieldUpdateOperationsInput | string | null
    q10?: NullableStringFieldUpdateOperationsInput | string | null
    q11?: NullableStringFieldUpdateOperationsInput | string | null
    q12?: NullableStringFieldUpdateOperationsInput | string | null
    q13?: NullableStringFieldUpdateOperationsInput | string | null
    q14?: NullableStringFieldUpdateOperationsInput | string | null
    q15?: NullableStringFieldUpdateOperationsInput | string | null
    q16?: NullableStringFieldUpdateOperationsInput | string | null
    q17?: NullableStringFieldUpdateOperationsInput | string | null
    q18?: NullableStringFieldUpdateOperationsInput | string | null
    q19?: NullableStringFieldUpdateOperationsInput | string | null
    q20?: NullableStringFieldUpdateOperationsInput | string | null
    q21?: NullableStringFieldUpdateOperationsInput | string | null
    q22?: NullableStringFieldUpdateOperationsInput | string | null
    q23?: NullableStringFieldUpdateOperationsInput | string | null
    q24?: NullableStringFieldUpdateOperationsInput | string | null
    q25?: NullableStringFieldUpdateOperationsInput | string | null
    q26?: NullableStringFieldUpdateOperationsInput | string | null
    q27?: NullableStringFieldUpdateOperationsInput | string | null
    q28?: NullableStringFieldUpdateOperationsInput | string | null
    q29?: NullableStringFieldUpdateOperationsInput | string | null
    q30?: NullableStringFieldUpdateOperationsInput | string | null
    q31?: NullableStringFieldUpdateOperationsInput | string | null
    q32?: NullableStringFieldUpdateOperationsInput | string | null
    q33?: NullableStringFieldUpdateOperationsInput | string | null
    q34?: NullableStringFieldUpdateOperationsInput | string | null
    q35?: NullableStringFieldUpdateOperationsInput | string | null
    q36?: NullableStringFieldUpdateOperationsInput | string | null
    q37?: NullableStringFieldUpdateOperationsInput | string | null
    q38?: NullableStringFieldUpdateOperationsInput | string | null
    q39?: NullableStringFieldUpdateOperationsInput | string | null
    q40?: NullableStringFieldUpdateOperationsInput | string | null
    q41?: NullableStringFieldUpdateOperationsInput | string | null
    q42?: NullableStringFieldUpdateOperationsInput | string | null
    q43?: NullableStringFieldUpdateOperationsInput | string | null
    q44?: NullableStringFieldUpdateOperationsInput | string | null
    q45?: NullableStringFieldUpdateOperationsInput | string | null
    q46?: NullableStringFieldUpdateOperationsInput | string | null
    q47?: NullableStringFieldUpdateOperationsInput | string | null
    q48?: NullableStringFieldUpdateOperationsInput | string | null
    q49?: NullableStringFieldUpdateOperationsInput | string | null
    q50?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type EnumUserTypeFilter = {
    equals?: $Enums.UserType
    in?: $Enums.UserType[] | $Enums.UserType
    notIn?: $Enums.UserType[] | $Enums.UserType
    not?: NestedEnumUserTypeFilter | $Enums.UserType
  }

  export type EnumAdminApprovedFilter = {
    equals?: $Enums.AdminApproved
    in?: $Enums.AdminApproved[] | $Enums.AdminApproved
    notIn?: $Enums.AdminApproved[] | $Enums.AdminApproved
    not?: NestedEnumAdminApprovedFilter | $Enums.AdminApproved
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ReadListRelationFilter = {
    every?: ReadWhereInput
    some?: ReadWhereInput
    none?: ReadWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type FeedbackAssignmentListRelationFilter = {
    every?: FeedbackAssignmentWhereInput
    some?: FeedbackAssignmentWhereInput
    none?: FeedbackAssignmentWhereInput
  }

  export type UserOrientationReadListRelationFilter = {
    every?: UserOrientationReadWhereInput
    some?: UserOrientationReadWhereInput
    none?: UserOrientationReadWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrientationReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    avatar?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    employeeNumber?: SortOrder
    password?: SortOrder
    fcmToken?: SortOrder
    type?: SortOrder
    adminApproved?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpire?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    avatar?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    employeeNumber?: SortOrder
    password?: SortOrder
    fcmToken?: SortOrder
    type?: SortOrder
    adminApproved?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpire?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    avatar?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    department?: SortOrder
    employeeNumber?: SortOrder
    password?: SortOrder
    fcmToken?: SortOrder
    type?: SortOrder
    adminApproved?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpire?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumUserTypeWithAggregatesFilter = {
    equals?: $Enums.UserType
    in?: $Enums.UserType[] | $Enums.UserType
    notIn?: $Enums.UserType[] | $Enums.UserType
    not?: NestedEnumUserTypeWithAggregatesFilter | $Enums.UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type EnumAdminApprovedWithAggregatesFilter = {
    equals?: $Enums.AdminApproved
    in?: $Enums.AdminApproved[] | $Enums.AdminApproved
    notIn?: $Enums.AdminApproved[] | $Enums.AdminApproved
    not?: NestedEnumAdminApprovedWithAggregatesFilter | $Enums.AdminApproved
    _count?: NestedIntFilter
    _min?: NestedEnumAdminApprovedFilter
    _max?: NestedEnumAdminApprovedFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type RiskAssessmentListRelationFilter = {
    every?: RiskAssessmentWhereInput
    some?: RiskAssessmentWhereInput
    none?: RiskAssessmentWhereInput
  }

  export type RiskAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    avatar?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    avatar?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    avatar?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MemberGroupIdUserIdCompoundUniqueInput = {
    groupId: number
    userId: number
  }

  export type MemberCountOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    timer?: SortOrder
    createdById?: SortOrder
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type ReadCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    reply?: SortOrder
    mode?: SortOrder
    readAt?: SortOrder
  }

  export type ReadAvgOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type ReadMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    reply?: SortOrder
    mode?: SortOrder
    readAt?: SortOrder
  }

  export type ReadMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    reply?: SortOrder
    mode?: SortOrder
    readAt?: SortOrder
  }

  export type ReadSumOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    messageId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    messageId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    messageId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
  }

  export type RiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type RiskAssessmentAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
  }

  export type RiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type RiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type RiskAssessmentSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
  }

  export type OtherFileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type OtherFileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OtherFileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type OtherFileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type OtherFileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserOrientationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserOrientationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserOrientationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserOrientationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserOrientationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserOrientationRelationFilter = {
    is?: UserOrientationWhereInput | null
    isNot?: UserOrientationWhereInput | null
  }

  export type UserOrientationReadCountOrderByAggregateInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type UserOrientationReadAvgOrderByAggregateInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
  }

  export type UserOrientationReadMaxOrderByAggregateInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type UserOrientationReadMinOrderByAggregateInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type UserOrientationReadSumOrderByAggregateInput = {
    id?: SortOrder
    userOrientationId?: SortOrder
    userId?: SortOrder
  }

  export type EnumFeedbackColorFilter = {
    equals?: $Enums.FeedbackColor
    in?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    notIn?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    not?: NestedEnumFeedbackColorFilter | $Enums.FeedbackColor
  }

  export type EnumStatusNullableFilter = {
    equals?: $Enums.Status | null
    in?: $Enums.Status[] | $Enums.Status | null
    notIn?: $Enums.Status[] | $Enums.Status | null
    not?: NestedEnumStatusNullableFilter | $Enums.Status | null
  }

  export type FeedbackFileListRelationFilter = {
    every?: FeedbackFileWhereInput
    some?: FeedbackFileWhereInput
    none?: FeedbackFileWhereInput
  }

  export type FeedbackActionFileListRelationFilter = {
    every?: FeedbackActionFileWhereInput
    some?: FeedbackActionFileWhereInput
    none?: FeedbackActionFileWhereInput
  }

  export type FeedbackFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackActionFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    organizationName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    feedback?: SortOrder
    source?: SortOrder
    color?: SortOrder
    selectedValues?: SortOrder
    description?: SortOrder
    reportedBy?: SortOrder
    responsiblePerson?: SortOrder
    actionTaken?: SortOrder
    status?: SortOrder
    userAcknowledgement?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    organizationName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    feedback?: SortOrder
    source?: SortOrder
    color?: SortOrder
    selectedValues?: SortOrder
    description?: SortOrder
    reportedBy?: SortOrder
    responsiblePerson?: SortOrder
    actionTaken?: SortOrder
    status?: SortOrder
    userAcknowledgement?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    organizationName?: SortOrder
    date?: SortOrder
    time?: SortOrder
    feedback?: SortOrder
    source?: SortOrder
    color?: SortOrder
    selectedValues?: SortOrder
    description?: SortOrder
    reportedBy?: SortOrder
    responsiblePerson?: SortOrder
    actionTaken?: SortOrder
    status?: SortOrder
    userAcknowledgement?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type EnumFeedbackColorWithAggregatesFilter = {
    equals?: $Enums.FeedbackColor
    in?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    notIn?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    not?: NestedEnumFeedbackColorWithAggregatesFilter | $Enums.FeedbackColor
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackColorFilter
    _max?: NestedEnumFeedbackColorFilter
  }

  export type EnumStatusNullableWithAggregatesFilter = {
    equals?: $Enums.Status | null
    in?: $Enums.Status[] | $Enums.Status | null
    notIn?: $Enums.Status[] | $Enums.Status | null
    not?: NestedEnumStatusNullableWithAggregatesFilter | $Enums.Status | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumStatusNullableFilter
    _max?: NestedEnumStatusNullableFilter
  }

  export type FeedbackRelationFilter = {
    is?: FeedbackWhereInput | null
    isNot?: FeedbackWhereInput | null
  }

  export type FeedbackAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentCompleted?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentCompleted?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentCompleted?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
    userId?: SortOrder
  }

  export type FeedbackFileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackFileAvgOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackFileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackFileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackFileSumOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackActionFileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackActionFileAvgOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackActionFileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackActionFileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    feedbackId?: SortOrder
  }

  export type FeedbackActionFileSumOrderByAggregateInput = {
    id?: SortOrder
    feedbackId?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type MembersListListRelationFilter = {
    every?: MembersListWhereInput
    some?: MembersListWhereInput
    none?: MembersListWhereInput
  }

  export type MembersAttendedListRelationFilter = {
    every?: MembersAttendedWhereInput
    some?: MembersAttendedWhereInput
    none?: MembersAttendedWhereInput
  }

  export type MembersListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembersAttendedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingCountOrderByAggregateInput = {
    meetingId?: SortOrder
    meetCreater?: SortOrder
    meetDateTime?: SortOrder
    meetTitle?: SortOrder
    meetingTime?: SortOrder
    department?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    isOnline?: SortOrder
    attId?: SortOrder
    meetEndTime?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    meetingId?: SortOrder
    meetingTime?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    attId?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    meetingId?: SortOrder
    meetCreater?: SortOrder
    meetDateTime?: SortOrder
    meetTitle?: SortOrder
    meetingTime?: SortOrder
    department?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    isOnline?: SortOrder
    attId?: SortOrder
    meetEndTime?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    meetingId?: SortOrder
    meetCreater?: SortOrder
    meetDateTime?: SortOrder
    meetTitle?: SortOrder
    meetingTime?: SortOrder
    department?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    isOnline?: SortOrder
    attId?: SortOrder
    meetEndTime?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    meetingId?: SortOrder
    meetingTime?: SortOrder
    createrId?: SortOrder
    membersCount?: SortOrder
    attId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type MeetingRelationFilter = {
    is?: MeetingWhereInput | null
    isNot?: MeetingWhereInput | null
  }

  export type MembersListCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    memberName?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersListAvgOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersListMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    memberName?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersListMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    memberName?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersListSumOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type DigitalSignatureFileRelationFilter = {
    is?: DigitalSignatureFileWhereInput | null
    isNot?: DigitalSignatureFileWhereInput | null
  }

  export type MembersAttendedCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    membersName?: SortOrder
    memberInTime?: SortOrder
    memberOutTime?: SortOrder
    dateTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersAttendedAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersAttendedMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    membersName?: SortOrder
    memberInTime?: SortOrder
    memberOutTime?: SortOrder
    dateTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersAttendedMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    membersName?: SortOrder
    memberInTime?: SortOrder
    memberOutTime?: SortOrder
    dateTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
  }

  export type MembersAttendedSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    meetingId?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type MembersAttendedRelationFilter = {
    is?: MembersAttendedWhereInput | null
    isNot?: MembersAttendedWhereInput | null
  }

  export type DigitalSignatureFileCountOrderByAggregateInput = {
    fileId?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    attendanceId?: SortOrder
  }

  export type DigitalSignatureFileAvgOrderByAggregateInput = {
    fileId?: SortOrder
    attendanceId?: SortOrder
  }

  export type DigitalSignatureFileMaxOrderByAggregateInput = {
    fileId?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    attendanceId?: SortOrder
  }

  export type DigitalSignatureFileMinOrderByAggregateInput = {
    fileId?: SortOrder
    name?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    attendanceId?: SortOrder
  }

  export type DigitalSignatureFileSumOrderByAggregateInput = {
    fileId?: SortOrder
    attendanceId?: SortOrder
  }

  export type FormCountOrderByAggregateInput = {
    formId?: SortOrder
    formTitle?: SortOrder
    formResult?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    dateAndTime?: SortOrder
    description?: SortOrder
    status?: SortOrder
    q1?: SortOrder
    q2?: SortOrder
    q3?: SortOrder
    q4?: SortOrder
    q5?: SortOrder
    q6?: SortOrder
    q7?: SortOrder
    q8?: SortOrder
    q9?: SortOrder
    q10?: SortOrder
    q11?: SortOrder
    q12?: SortOrder
    q13?: SortOrder
    q14?: SortOrder
    q15?: SortOrder
    q16?: SortOrder
    q17?: SortOrder
    q18?: SortOrder
    q19?: SortOrder
    q20?: SortOrder
    q21?: SortOrder
    q22?: SortOrder
    q23?: SortOrder
    q24?: SortOrder
    q25?: SortOrder
    q26?: SortOrder
    q27?: SortOrder
    q28?: SortOrder
    q29?: SortOrder
    q30?: SortOrder
    q31?: SortOrder
    q32?: SortOrder
    q33?: SortOrder
    q34?: SortOrder
    q35?: SortOrder
    q36?: SortOrder
    q37?: SortOrder
    q38?: SortOrder
    q39?: SortOrder
    q40?: SortOrder
    q41?: SortOrder
    q42?: SortOrder
    q43?: SortOrder
    q44?: SortOrder
    q45?: SortOrder
    q46?: SortOrder
    q47?: SortOrder
    q48?: SortOrder
    q49?: SortOrder
    q50?: SortOrder
  }

  export type FormAvgOrderByAggregateInput = {
    formId?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    formId?: SortOrder
    formTitle?: SortOrder
    formResult?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    dateAndTime?: SortOrder
    description?: SortOrder
    status?: SortOrder
    q1?: SortOrder
    q2?: SortOrder
    q3?: SortOrder
    q4?: SortOrder
    q5?: SortOrder
    q6?: SortOrder
    q7?: SortOrder
    q8?: SortOrder
    q9?: SortOrder
    q10?: SortOrder
    q11?: SortOrder
    q12?: SortOrder
    q13?: SortOrder
    q14?: SortOrder
    q15?: SortOrder
    q16?: SortOrder
    q17?: SortOrder
    q18?: SortOrder
    q19?: SortOrder
    q20?: SortOrder
    q21?: SortOrder
    q22?: SortOrder
    q23?: SortOrder
    q24?: SortOrder
    q25?: SortOrder
    q26?: SortOrder
    q27?: SortOrder
    q28?: SortOrder
    q29?: SortOrder
    q30?: SortOrder
    q31?: SortOrder
    q32?: SortOrder
    q33?: SortOrder
    q34?: SortOrder
    q35?: SortOrder
    q36?: SortOrder
    q37?: SortOrder
    q38?: SortOrder
    q39?: SortOrder
    q40?: SortOrder
    q41?: SortOrder
    q42?: SortOrder
    q43?: SortOrder
    q44?: SortOrder
    q45?: SortOrder
    q46?: SortOrder
    q47?: SortOrder
    q48?: SortOrder
    q49?: SortOrder
    q50?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    formId?: SortOrder
    formTitle?: SortOrder
    formResult?: SortOrder
    username?: SortOrder
    userId?: SortOrder
    dateAndTime?: SortOrder
    description?: SortOrder
    status?: SortOrder
    q1?: SortOrder
    q2?: SortOrder
    q3?: SortOrder
    q4?: SortOrder
    q5?: SortOrder
    q6?: SortOrder
    q7?: SortOrder
    q8?: SortOrder
    q9?: SortOrder
    q10?: SortOrder
    q11?: SortOrder
    q12?: SortOrder
    q13?: SortOrder
    q14?: SortOrder
    q15?: SortOrder
    q16?: SortOrder
    q17?: SortOrder
    q18?: SortOrder
    q19?: SortOrder
    q20?: SortOrder
    q21?: SortOrder
    q22?: SortOrder
    q23?: SortOrder
    q24?: SortOrder
    q25?: SortOrder
    q26?: SortOrder
    q27?: SortOrder
    q28?: SortOrder
    q29?: SortOrder
    q30?: SortOrder
    q31?: SortOrder
    q32?: SortOrder
    q33?: SortOrder
    q34?: SortOrder
    q35?: SortOrder
    q36?: SortOrder
    q37?: SortOrder
    q38?: SortOrder
    q39?: SortOrder
    q40?: SortOrder
    q41?: SortOrder
    q42?: SortOrder
    q43?: SortOrder
    q44?: SortOrder
    q45?: SortOrder
    q46?: SortOrder
    q47?: SortOrder
    q48?: SortOrder
    q49?: SortOrder
    q50?: SortOrder
  }

  export type FormSumOrderByAggregateInput = {
    formId?: SortOrder
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReadCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadCreateWithoutUserInput, ReadUncheckedCreateWithoutUserInput> | ReadCreateWithoutUserInput[] | ReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutUserInput | ReadCreateOrConnectWithoutUserInput[]
    createMany?: ReadCreateManyUserInputEnvelope
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<FeedbackCreateWithoutCreatedByInput, FeedbackUncheckedCreateWithoutCreatedByInput> | FeedbackCreateWithoutCreatedByInput[] | FeedbackUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutCreatedByInput | FeedbackCreateOrConnectWithoutCreatedByInput[]
    createMany?: FeedbackCreateManyCreatedByInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutUserInput, FeedbackAssignmentUncheckedCreateWithoutUserInput> | FeedbackAssignmentCreateWithoutUserInput[] | FeedbackAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutUserInput | FeedbackAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackAssignmentCreateManyUserInputEnvelope
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
  }

  export type UserOrientationReadCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserInput, UserOrientationReadUncheckedCreateWithoutUserInput> | UserOrientationReadCreateWithoutUserInput[] | UserOrientationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserInput | UserOrientationReadCreateOrConnectWithoutUserInput[]
    createMany?: UserOrientationReadCreateManyUserInputEnvelope
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadCreateWithoutUserInput, ReadUncheckedCreateWithoutUserInput> | ReadCreateWithoutUserInput[] | ReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutUserInput | ReadCreateOrConnectWithoutUserInput[]
    createMany?: ReadCreateManyUserInputEnvelope
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<FeedbackCreateWithoutCreatedByInput, FeedbackUncheckedCreateWithoutCreatedByInput> | FeedbackCreateWithoutCreatedByInput[] | FeedbackUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutCreatedByInput | FeedbackCreateOrConnectWithoutCreatedByInput[]
    createMany?: FeedbackCreateManyCreatedByInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutUserInput, FeedbackAssignmentUncheckedCreateWithoutUserInput> | FeedbackAssignmentCreateWithoutUserInput[] | FeedbackAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutUserInput | FeedbackAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackAssignmentCreateManyUserInputEnvelope
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
  }

  export type UserOrientationReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserInput, UserOrientationReadUncheckedCreateWithoutUserInput> | UserOrientationReadCreateWithoutUserInput[] | UserOrientationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserInput | UserOrientationReadCreateOrConnectWithoutUserInput[]
    createMany?: UserOrientationReadCreateManyUserInputEnvelope
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type EnumAdminApprovedFieldUpdateOperationsInput = {
    set?: $Enums.AdminApproved
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCreatedByInput | MessageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCreatedByInput | MessageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCreatedByInput | MessageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadCreateWithoutUserInput, ReadUncheckedCreateWithoutUserInput> | ReadCreateWithoutUserInput[] | ReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutUserInput | ReadCreateOrConnectWithoutUserInput[]
    upsert?: ReadUpsertWithWhereUniqueWithoutUserInput | ReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadCreateManyUserInputEnvelope
    set?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    disconnect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    delete?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    update?: ReadUpdateWithWhereUniqueWithoutUserInput | ReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadUpdateManyWithWhereWithoutUserInput | ReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadScalarWhereInput | ReadScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<FeedbackCreateWithoutCreatedByInput, FeedbackUncheckedCreateWithoutCreatedByInput> | FeedbackCreateWithoutCreatedByInput[] | FeedbackUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutCreatedByInput | FeedbackCreateOrConnectWithoutCreatedByInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutCreatedByInput | FeedbackUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: FeedbackCreateManyCreatedByInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutCreatedByInput | FeedbackUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutCreatedByInput | FeedbackUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutUserInput, FeedbackAssignmentUncheckedCreateWithoutUserInput> | FeedbackAssignmentCreateWithoutUserInput[] | FeedbackAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutUserInput | FeedbackAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackAssignmentUpsertWithWhereUniqueWithoutUserInput | FeedbackAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackAssignmentCreateManyUserInputEnvelope
    set?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    disconnect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    delete?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    update?: FeedbackAssignmentUpdateWithWhereUniqueWithoutUserInput | FeedbackAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackAssignmentUpdateManyWithWhereWithoutUserInput | FeedbackAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackAssignmentScalarWhereInput | FeedbackAssignmentScalarWhereInput[]
  }

  export type UserOrientationReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserInput, UserOrientationReadUncheckedCreateWithoutUserInput> | UserOrientationReadCreateWithoutUserInput[] | UserOrientationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserInput | UserOrientationReadCreateOrConnectWithoutUserInput[]
    upsert?: UserOrientationReadUpsertWithWhereUniqueWithoutUserInput | UserOrientationReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOrientationReadCreateManyUserInputEnvelope
    set?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    disconnect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    delete?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    update?: UserOrientationReadUpdateWithWhereUniqueWithoutUserInput | UserOrientationReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOrientationReadUpdateManyWithWhereWithoutUserInput | UserOrientationReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOrientationReadScalarWhereInput | UserOrientationReadScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput> | MessageCreateWithoutCreatedByInput[] | MessageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCreatedByInput | MessageCreateOrConnectWithoutCreatedByInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCreatedByInput | MessageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MessageCreateManyCreatedByInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCreatedByInput | MessageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCreatedByInput | MessageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadCreateWithoutUserInput, ReadUncheckedCreateWithoutUserInput> | ReadCreateWithoutUserInput[] | ReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutUserInput | ReadCreateOrConnectWithoutUserInput[]
    upsert?: ReadUpsertWithWhereUniqueWithoutUserInput | ReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadCreateManyUserInputEnvelope
    set?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    disconnect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    delete?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    update?: ReadUpdateWithWhereUniqueWithoutUserInput | ReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadUpdateManyWithWhereWithoutUserInput | ReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadScalarWhereInput | ReadScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<FeedbackCreateWithoutCreatedByInput, FeedbackUncheckedCreateWithoutCreatedByInput> | FeedbackCreateWithoutCreatedByInput[] | FeedbackUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutCreatedByInput | FeedbackCreateOrConnectWithoutCreatedByInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutCreatedByInput | FeedbackUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: FeedbackCreateManyCreatedByInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutCreatedByInput | FeedbackUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutCreatedByInput | FeedbackUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutUserInput, FeedbackAssignmentUncheckedCreateWithoutUserInput> | FeedbackAssignmentCreateWithoutUserInput[] | FeedbackAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutUserInput | FeedbackAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackAssignmentUpsertWithWhereUniqueWithoutUserInput | FeedbackAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackAssignmentCreateManyUserInputEnvelope
    set?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    disconnect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    delete?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    update?: FeedbackAssignmentUpdateWithWhereUniqueWithoutUserInput | FeedbackAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackAssignmentUpdateManyWithWhereWithoutUserInput | FeedbackAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackAssignmentScalarWhereInput | FeedbackAssignmentScalarWhereInput[]
  }

  export type UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserInput, UserOrientationReadUncheckedCreateWithoutUserInput> | UserOrientationReadCreateWithoutUserInput[] | UserOrientationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserInput | UserOrientationReadCreateOrConnectWithoutUserInput[]
    upsert?: UserOrientationReadUpsertWithWhereUniqueWithoutUserInput | UserOrientationReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOrientationReadCreateManyUserInputEnvelope
    set?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    disconnect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    delete?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    update?: UserOrientationReadUpdateWithWhereUniqueWithoutUserInput | UserOrientationReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOrientationReadUpdateManyWithWhereWithoutUserInput | UserOrientationReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOrientationReadScalarWhereInput | UserOrientationReadScalarWhereInput[]
  }

  export type MemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<MemberCreateWithoutGroupInput, MemberUncheckedCreateWithoutGroupInput> | MemberCreateWithoutGroupInput[] | MemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutGroupInput | MemberCreateOrConnectWithoutGroupInput[]
    createMany?: MemberCreateManyGroupInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type RiskAssessmentCreateNestedManyWithoutGroupInput = {
    create?: XOR<RiskAssessmentCreateWithoutGroupInput, RiskAssessmentUncheckedCreateWithoutGroupInput> | RiskAssessmentCreateWithoutGroupInput[] | RiskAssessmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutGroupInput | RiskAssessmentCreateOrConnectWithoutGroupInput[]
    createMany?: RiskAssessmentCreateManyGroupInputEnvelope
    connect?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutGroupsInput = {
    create?: XOR<MessageCreateWithoutGroupsInput, MessageUncheckedCreateWithoutGroupsInput> | MessageCreateWithoutGroupsInput[] | MessageUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupsInput | MessageCreateOrConnectWithoutGroupsInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<MemberCreateWithoutGroupInput, MemberUncheckedCreateWithoutGroupInput> | MemberCreateWithoutGroupInput[] | MemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutGroupInput | MemberCreateOrConnectWithoutGroupInput[]
    createMany?: MemberCreateManyGroupInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type RiskAssessmentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<RiskAssessmentCreateWithoutGroupInput, RiskAssessmentUncheckedCreateWithoutGroupInput> | RiskAssessmentCreateWithoutGroupInput[] | RiskAssessmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutGroupInput | RiskAssessmentCreateOrConnectWithoutGroupInput[]
    createMany?: RiskAssessmentCreateManyGroupInputEnvelope
    connect?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<MessageCreateWithoutGroupsInput, MessageUncheckedCreateWithoutGroupsInput> | MessageCreateWithoutGroupsInput[] | MessageUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupsInput | MessageCreateOrConnectWithoutGroupsInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MemberCreateWithoutGroupInput, MemberUncheckedCreateWithoutGroupInput> | MemberCreateWithoutGroupInput[] | MemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutGroupInput | MemberCreateOrConnectWithoutGroupInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutGroupInput | MemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MemberCreateManyGroupInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutGroupInput | MemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutGroupInput | MemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type RiskAssessmentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutGroupInput, RiskAssessmentUncheckedCreateWithoutGroupInput> | RiskAssessmentCreateWithoutGroupInput[] | RiskAssessmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutGroupInput | RiskAssessmentCreateOrConnectWithoutGroupInput[]
    upsert?: RiskAssessmentUpsertWithWhereUniqueWithoutGroupInput | RiskAssessmentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RiskAssessmentCreateManyGroupInputEnvelope
    set?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    disconnect?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    delete?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    connect?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    update?: RiskAssessmentUpdateWithWhereUniqueWithoutGroupInput | RiskAssessmentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RiskAssessmentUpdateManyWithWhereWithoutGroupInput | RiskAssessmentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RiskAssessmentScalarWhereInput | RiskAssessmentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<MessageCreateWithoutGroupsInput, MessageUncheckedCreateWithoutGroupsInput> | MessageCreateWithoutGroupsInput[] | MessageUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupsInput | MessageCreateOrConnectWithoutGroupsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupsInput | MessageUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupsInput | MessageUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupsInput | MessageUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MemberCreateWithoutGroupInput, MemberUncheckedCreateWithoutGroupInput> | MemberCreateWithoutGroupInput[] | MemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutGroupInput | MemberCreateOrConnectWithoutGroupInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutGroupInput | MemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MemberCreateManyGroupInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutGroupInput | MemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutGroupInput | MemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type RiskAssessmentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutGroupInput, RiskAssessmentUncheckedCreateWithoutGroupInput> | RiskAssessmentCreateWithoutGroupInput[] | RiskAssessmentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutGroupInput | RiskAssessmentCreateOrConnectWithoutGroupInput[]
    upsert?: RiskAssessmentUpsertWithWhereUniqueWithoutGroupInput | RiskAssessmentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: RiskAssessmentCreateManyGroupInputEnvelope
    set?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    disconnect?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    delete?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    connect?: RiskAssessmentWhereUniqueInput | RiskAssessmentWhereUniqueInput[]
    update?: RiskAssessmentUpdateWithWhereUniqueWithoutGroupInput | RiskAssessmentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: RiskAssessmentUpdateManyWithWhereWithoutGroupInput | RiskAssessmentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: RiskAssessmentScalarWhereInput | RiskAssessmentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<MessageCreateWithoutGroupsInput, MessageUncheckedCreateWithoutGroupsInput> | MessageCreateWithoutGroupsInput[] | MessageUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutGroupsInput | MessageCreateOrConnectWithoutGroupsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutGroupsInput | MessageUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutGroupsInput | MessageUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutGroupsInput | MessageUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMemberInGroupsInput = {
    create?: XOR<UserCreateWithoutMemberInGroupsInput, UserUncheckedCreateWithoutMemberInGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMemberInGroupsNestedInput = {
    create?: XOR<UserCreateWithoutMemberInGroupsInput, UserUncheckedCreateWithoutMemberInGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInGroupsInput
    upsert?: UserUpsertWithoutMemberInGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMemberInGroupsInput, UserUncheckedUpdateWithoutMemberInGroupsInput>
  }

  export type ReadCreateNestedManyWithoutMessageInput = {
    create?: XOR<ReadCreateWithoutMessageInput, ReadUncheckedCreateWithoutMessageInput> | ReadCreateWithoutMessageInput[] | ReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutMessageInput | ReadCreateOrConnectWithoutMessageInput[]
    createMany?: ReadCreateManyMessageInputEnvelope
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutMessageInput = {
    create?: XOR<FileCreateWithoutMessageInput, FileUncheckedCreateWithoutMessageInput> | FileCreateWithoutMessageInput[] | FileUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMessageInput | FileCreateOrConnectWithoutMessageInput[]
    createMany?: FileCreateManyMessageInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedManyWithoutMessagesInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput> | GroupCreateWithoutMessagesInput[] | GroupUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput | GroupCreateOrConnectWithoutMessagesInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ReadUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ReadCreateWithoutMessageInput, ReadUncheckedCreateWithoutMessageInput> | ReadCreateWithoutMessageInput[] | ReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutMessageInput | ReadCreateOrConnectWithoutMessageInput[]
    createMany?: ReadCreateManyMessageInputEnvelope
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<FileCreateWithoutMessageInput, FileUncheckedCreateWithoutMessageInput> | FileCreateWithoutMessageInput[] | FileUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMessageInput | FileCreateOrConnectWithoutMessageInput[]
    createMany?: FileCreateManyMessageInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput> | GroupCreateWithoutMessagesInput[] | GroupUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput | GroupCreateOrConnectWithoutMessagesInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ReadUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ReadCreateWithoutMessageInput, ReadUncheckedCreateWithoutMessageInput> | ReadCreateWithoutMessageInput[] | ReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutMessageInput | ReadCreateOrConnectWithoutMessageInput[]
    upsert?: ReadUpsertWithWhereUniqueWithoutMessageInput | ReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ReadCreateManyMessageInputEnvelope
    set?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    disconnect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    delete?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    update?: ReadUpdateWithWhereUniqueWithoutMessageInput | ReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ReadUpdateManyWithWhereWithoutMessageInput | ReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ReadScalarWhereInput | ReadScalarWhereInput[]
  }

  export type FileUpdateManyWithoutMessageNestedInput = {
    create?: XOR<FileCreateWithoutMessageInput, FileUncheckedCreateWithoutMessageInput> | FileCreateWithoutMessageInput[] | FileUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMessageInput | FileCreateOrConnectWithoutMessageInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMessageInput | FileUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: FileCreateManyMessageInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMessageInput | FileUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMessageInput | FileUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type GroupUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput> | GroupCreateWithoutMessagesInput[] | GroupUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput | GroupCreateOrConnectWithoutMessagesInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutMessagesInput | GroupUpsertWithWhereUniqueWithoutMessagesInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutMessagesInput | GroupUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutMessagesInput | GroupUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ReadUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ReadCreateWithoutMessageInput, ReadUncheckedCreateWithoutMessageInput> | ReadCreateWithoutMessageInput[] | ReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReadCreateOrConnectWithoutMessageInput | ReadCreateOrConnectWithoutMessageInput[]
    upsert?: ReadUpsertWithWhereUniqueWithoutMessageInput | ReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ReadCreateManyMessageInputEnvelope
    set?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    disconnect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    delete?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    connect?: ReadWhereUniqueInput | ReadWhereUniqueInput[]
    update?: ReadUpdateWithWhereUniqueWithoutMessageInput | ReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ReadUpdateManyWithWhereWithoutMessageInput | ReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ReadScalarWhereInput | ReadScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<FileCreateWithoutMessageInput, FileUncheckedCreateWithoutMessageInput> | FileCreateWithoutMessageInput[] | FileUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMessageInput | FileCreateOrConnectWithoutMessageInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMessageInput | FileUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: FileCreateManyMessageInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMessageInput | FileUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMessageInput | FileUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput> | GroupCreateWithoutMessagesInput[] | GroupUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMessagesInput | GroupCreateOrConnectWithoutMessagesInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutMessagesInput | GroupUpsertWithWhereUniqueWithoutMessagesInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutMessagesInput | GroupUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutMessagesInput | GroupUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutReadInput = {
    create?: XOR<MessageCreateWithoutReadInput, MessageUncheckedCreateWithoutReadInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReadsInput = {
    create?: XOR<UserCreateWithoutReadsInput, UserUncheckedCreateWithoutReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReadNestedInput = {
    create?: XOR<MessageCreateWithoutReadInput, MessageUncheckedCreateWithoutReadInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadInput
    upsert?: MessageUpsertWithoutReadInput
    connect?: MessageWhereUniqueInput
    update?: XOR<MessageUpdateWithoutReadInput, MessageUncheckedUpdateWithoutReadInput>
  }

  export type UserUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<UserCreateWithoutReadsInput, UserUncheckedCreateWithoutReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadsInput
    upsert?: UserUpsertWithoutReadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReadsInput, UserUncheckedUpdateWithoutReadsInput>
  }

  export type MessageCreateNestedOneWithoutFilesInput = {
    create?: XOR<MessageCreateWithoutFilesInput, MessageUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutFilesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<MessageCreateWithoutFilesInput, MessageUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutFilesInput
    upsert?: MessageUpsertWithoutFilesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<MessageUpdateWithoutFilesInput, MessageUncheckedUpdateWithoutFilesInput>
  }

  export type GroupCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<GroupCreateWithoutAssessmentsInput, GroupUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutAssessmentsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<GroupCreateWithoutAssessmentsInput, GroupUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutAssessmentsInput
    upsert?: GroupUpsertWithoutAssessmentsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<GroupUpdateWithoutAssessmentsInput, GroupUncheckedUpdateWithoutAssessmentsInput>
  }

  export type UserOrientationReadCreateNestedManyWithoutUserOrientationInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserOrientationInput, UserOrientationReadUncheckedCreateWithoutUserOrientationInput> | UserOrientationReadCreateWithoutUserOrientationInput[] | UserOrientationReadUncheckedCreateWithoutUserOrientationInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserOrientationInput | UserOrientationReadCreateOrConnectWithoutUserOrientationInput[]
    createMany?: UserOrientationReadCreateManyUserOrientationInputEnvelope
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
  }

  export type UserOrientationReadUncheckedCreateNestedManyWithoutUserOrientationInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserOrientationInput, UserOrientationReadUncheckedCreateWithoutUserOrientationInput> | UserOrientationReadCreateWithoutUserOrientationInput[] | UserOrientationReadUncheckedCreateWithoutUserOrientationInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserOrientationInput | UserOrientationReadCreateOrConnectWithoutUserOrientationInput[]
    createMany?: UserOrientationReadCreateManyUserOrientationInputEnvelope
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
  }

  export type UserOrientationReadUpdateManyWithoutUserOrientationNestedInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserOrientationInput, UserOrientationReadUncheckedCreateWithoutUserOrientationInput> | UserOrientationReadCreateWithoutUserOrientationInput[] | UserOrientationReadUncheckedCreateWithoutUserOrientationInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserOrientationInput | UserOrientationReadCreateOrConnectWithoutUserOrientationInput[]
    upsert?: UserOrientationReadUpsertWithWhereUniqueWithoutUserOrientationInput | UserOrientationReadUpsertWithWhereUniqueWithoutUserOrientationInput[]
    createMany?: UserOrientationReadCreateManyUserOrientationInputEnvelope
    set?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    disconnect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    delete?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    update?: UserOrientationReadUpdateWithWhereUniqueWithoutUserOrientationInput | UserOrientationReadUpdateWithWhereUniqueWithoutUserOrientationInput[]
    updateMany?: UserOrientationReadUpdateManyWithWhereWithoutUserOrientationInput | UserOrientationReadUpdateManyWithWhereWithoutUserOrientationInput[]
    deleteMany?: UserOrientationReadScalarWhereInput | UserOrientationReadScalarWhereInput[]
  }

  export type UserOrientationReadUncheckedUpdateManyWithoutUserOrientationNestedInput = {
    create?: XOR<UserOrientationReadCreateWithoutUserOrientationInput, UserOrientationReadUncheckedCreateWithoutUserOrientationInput> | UserOrientationReadCreateWithoutUserOrientationInput[] | UserOrientationReadUncheckedCreateWithoutUserOrientationInput[]
    connectOrCreate?: UserOrientationReadCreateOrConnectWithoutUserOrientationInput | UserOrientationReadCreateOrConnectWithoutUserOrientationInput[]
    upsert?: UserOrientationReadUpsertWithWhereUniqueWithoutUserOrientationInput | UserOrientationReadUpsertWithWhereUniqueWithoutUserOrientationInput[]
    createMany?: UserOrientationReadCreateManyUserOrientationInputEnvelope
    set?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    disconnect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    delete?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    connect?: UserOrientationReadWhereUniqueInput | UserOrientationReadWhereUniqueInput[]
    update?: UserOrientationReadUpdateWithWhereUniqueWithoutUserOrientationInput | UserOrientationReadUpdateWithWhereUniqueWithoutUserOrientationInput[]
    updateMany?: UserOrientationReadUpdateManyWithWhereWithoutUserOrientationInput | UserOrientationReadUpdateManyWithWhereWithoutUserOrientationInput[]
    deleteMany?: UserOrientationReadScalarWhereInput | UserOrientationReadScalarWhereInput[]
  }

  export type UserOrientationCreateNestedOneWithoutUserOrientationReadsInput = {
    create?: XOR<UserOrientationCreateWithoutUserOrientationReadsInput, UserOrientationUncheckedCreateWithoutUserOrientationReadsInput>
    connectOrCreate?: UserOrientationCreateOrConnectWithoutUserOrientationReadsInput
    connect?: UserOrientationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserOrientationReadsInput = {
    create?: XOR<UserCreateWithoutUserOrientationReadsInput, UserUncheckedCreateWithoutUserOrientationReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserOrientationReadsInput
    connect?: UserWhereUniqueInput
  }

  export type UserOrientationUpdateOneRequiredWithoutUserOrientationReadsNestedInput = {
    create?: XOR<UserOrientationCreateWithoutUserOrientationReadsInput, UserOrientationUncheckedCreateWithoutUserOrientationReadsInput>
    connectOrCreate?: UserOrientationCreateOrConnectWithoutUserOrientationReadsInput
    upsert?: UserOrientationUpsertWithoutUserOrientationReadsInput
    connect?: UserOrientationWhereUniqueInput
    update?: XOR<UserOrientationUpdateWithoutUserOrientationReadsInput, UserOrientationUncheckedUpdateWithoutUserOrientationReadsInput>
  }

  export type UserUpdateOneRequiredWithoutUserOrientationReadsNestedInput = {
    create?: XOR<UserCreateWithoutUserOrientationReadsInput, UserUncheckedCreateWithoutUserOrientationReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserOrientationReadsInput
    upsert?: UserUpsertWithoutUserOrientationReadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserOrientationReadsInput, UserUncheckedUpdateWithoutUserOrientationReadsInput>
  }

  export type FeedbackFileCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackFileCreateWithoutFeedbackInput, FeedbackFileUncheckedCreateWithoutFeedbackInput> | FeedbackFileCreateWithoutFeedbackInput[] | FeedbackFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackFileCreateOrConnectWithoutFeedbackInput | FeedbackFileCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackFileCreateManyFeedbackInputEnvelope
    connect?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
  }

  export type FeedbackActionFileCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackActionFileCreateWithoutFeedbackInput, FeedbackActionFileUncheckedCreateWithoutFeedbackInput> | FeedbackActionFileCreateWithoutFeedbackInput[] | FeedbackActionFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackActionFileCreateOrConnectWithoutFeedbackInput | FeedbackActionFileCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackActionFileCreateManyFeedbackInputEnvelope
    connect?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type FeedbackAssignmentCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutFeedbackInput, FeedbackAssignmentUncheckedCreateWithoutFeedbackInput> | FeedbackAssignmentCreateWithoutFeedbackInput[] | FeedbackAssignmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutFeedbackInput | FeedbackAssignmentCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackAssignmentCreateManyFeedbackInputEnvelope
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
  }

  export type FeedbackFileUncheckedCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackFileCreateWithoutFeedbackInput, FeedbackFileUncheckedCreateWithoutFeedbackInput> | FeedbackFileCreateWithoutFeedbackInput[] | FeedbackFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackFileCreateOrConnectWithoutFeedbackInput | FeedbackFileCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackFileCreateManyFeedbackInputEnvelope
    connect?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
  }

  export type FeedbackActionFileUncheckedCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackActionFileCreateWithoutFeedbackInput, FeedbackActionFileUncheckedCreateWithoutFeedbackInput> | FeedbackActionFileCreateWithoutFeedbackInput[] | FeedbackActionFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackActionFileCreateOrConnectWithoutFeedbackInput | FeedbackActionFileCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackActionFileCreateManyFeedbackInputEnvelope
    connect?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
  }

  export type FeedbackAssignmentUncheckedCreateNestedManyWithoutFeedbackInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutFeedbackInput, FeedbackAssignmentUncheckedCreateWithoutFeedbackInput> | FeedbackAssignmentCreateWithoutFeedbackInput[] | FeedbackAssignmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutFeedbackInput | FeedbackAssignmentCreateOrConnectWithoutFeedbackInput[]
    createMany?: FeedbackAssignmentCreateManyFeedbackInputEnvelope
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
  }

  export type EnumFeedbackColorFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackColor
  }

  export type NullableEnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status | null
  }

  export type FeedbackFileUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackFileCreateWithoutFeedbackInput, FeedbackFileUncheckedCreateWithoutFeedbackInput> | FeedbackFileCreateWithoutFeedbackInput[] | FeedbackFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackFileCreateOrConnectWithoutFeedbackInput | FeedbackFileCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackFileUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackFileUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackFileCreateManyFeedbackInputEnvelope
    set?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    disconnect?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    delete?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    connect?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    update?: FeedbackFileUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackFileUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackFileUpdateManyWithWhereWithoutFeedbackInput | FeedbackFileUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackFileScalarWhereInput | FeedbackFileScalarWhereInput[]
  }

  export type FeedbackActionFileUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackActionFileCreateWithoutFeedbackInput, FeedbackActionFileUncheckedCreateWithoutFeedbackInput> | FeedbackActionFileCreateWithoutFeedbackInput[] | FeedbackActionFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackActionFileCreateOrConnectWithoutFeedbackInput | FeedbackActionFileCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackActionFileUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackActionFileUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackActionFileCreateManyFeedbackInputEnvelope
    set?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    disconnect?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    delete?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    connect?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    update?: FeedbackActionFileUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackActionFileUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackActionFileUpdateManyWithWhereWithoutFeedbackInput | FeedbackActionFileUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackActionFileScalarWhereInput | FeedbackActionFileScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type FeedbackAssignmentUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutFeedbackInput, FeedbackAssignmentUncheckedCreateWithoutFeedbackInput> | FeedbackAssignmentCreateWithoutFeedbackInput[] | FeedbackAssignmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutFeedbackInput | FeedbackAssignmentCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackAssignmentUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackAssignmentUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackAssignmentCreateManyFeedbackInputEnvelope
    set?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    disconnect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    delete?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    update?: FeedbackAssignmentUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackAssignmentUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackAssignmentUpdateManyWithWhereWithoutFeedbackInput | FeedbackAssignmentUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackAssignmentScalarWhereInput | FeedbackAssignmentScalarWhereInput[]
  }

  export type FeedbackFileUncheckedUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackFileCreateWithoutFeedbackInput, FeedbackFileUncheckedCreateWithoutFeedbackInput> | FeedbackFileCreateWithoutFeedbackInput[] | FeedbackFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackFileCreateOrConnectWithoutFeedbackInput | FeedbackFileCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackFileUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackFileUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackFileCreateManyFeedbackInputEnvelope
    set?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    disconnect?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    delete?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    connect?: FeedbackFileWhereUniqueInput | FeedbackFileWhereUniqueInput[]
    update?: FeedbackFileUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackFileUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackFileUpdateManyWithWhereWithoutFeedbackInput | FeedbackFileUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackFileScalarWhereInput | FeedbackFileScalarWhereInput[]
  }

  export type FeedbackActionFileUncheckedUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackActionFileCreateWithoutFeedbackInput, FeedbackActionFileUncheckedCreateWithoutFeedbackInput> | FeedbackActionFileCreateWithoutFeedbackInput[] | FeedbackActionFileUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackActionFileCreateOrConnectWithoutFeedbackInput | FeedbackActionFileCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackActionFileUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackActionFileUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackActionFileCreateManyFeedbackInputEnvelope
    set?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    disconnect?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    delete?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    connect?: FeedbackActionFileWhereUniqueInput | FeedbackActionFileWhereUniqueInput[]
    update?: FeedbackActionFileUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackActionFileUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackActionFileUpdateManyWithWhereWithoutFeedbackInput | FeedbackActionFileUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackActionFileScalarWhereInput | FeedbackActionFileScalarWhereInput[]
  }

  export type FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackNestedInput = {
    create?: XOR<FeedbackAssignmentCreateWithoutFeedbackInput, FeedbackAssignmentUncheckedCreateWithoutFeedbackInput> | FeedbackAssignmentCreateWithoutFeedbackInput[] | FeedbackAssignmentUncheckedCreateWithoutFeedbackInput[]
    connectOrCreate?: FeedbackAssignmentCreateOrConnectWithoutFeedbackInput | FeedbackAssignmentCreateOrConnectWithoutFeedbackInput[]
    upsert?: FeedbackAssignmentUpsertWithWhereUniqueWithoutFeedbackInput | FeedbackAssignmentUpsertWithWhereUniqueWithoutFeedbackInput[]
    createMany?: FeedbackAssignmentCreateManyFeedbackInputEnvelope
    set?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    disconnect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    delete?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    connect?: FeedbackAssignmentWhereUniqueInput | FeedbackAssignmentWhereUniqueInput[]
    update?: FeedbackAssignmentUpdateWithWhereUniqueWithoutFeedbackInput | FeedbackAssignmentUpdateWithWhereUniqueWithoutFeedbackInput[]
    updateMany?: FeedbackAssignmentUpdateManyWithWhereWithoutFeedbackInput | FeedbackAssignmentUpdateManyWithWhereWithoutFeedbackInput[]
    deleteMany?: FeedbackAssignmentScalarWhereInput | FeedbackAssignmentScalarWhereInput[]
  }

  export type FeedbackCreateNestedOneWithoutFeedbackAssignmentsInput = {
    create?: XOR<FeedbackCreateWithoutFeedbackAssignmentsInput, FeedbackUncheckedCreateWithoutFeedbackAssignmentsInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutFeedbackAssignmentsInput
    connect?: FeedbackWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbackAssignmentsInput = {
    create?: XOR<UserCreateWithoutFeedbackAssignmentsInput, UserUncheckedCreateWithoutFeedbackAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type FeedbackUpdateOneRequiredWithoutFeedbackAssignmentsNestedInput = {
    create?: XOR<FeedbackCreateWithoutFeedbackAssignmentsInput, FeedbackUncheckedCreateWithoutFeedbackAssignmentsInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutFeedbackAssignmentsInput
    upsert?: FeedbackUpsertWithoutFeedbackAssignmentsInput
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutFeedbackAssignmentsInput, FeedbackUncheckedUpdateWithoutFeedbackAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbackAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackAssignmentsInput, UserUncheckedCreateWithoutFeedbackAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackAssignmentsInput
    upsert?: UserUpsertWithoutFeedbackAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeedbackAssignmentsInput, UserUncheckedUpdateWithoutFeedbackAssignmentsInput>
  }

  export type FeedbackCreateNestedOneWithoutFilesInput = {
    create?: XOR<FeedbackCreateWithoutFilesInput, FeedbackUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutFilesInput
    connect?: FeedbackWhereUniqueInput
  }

  export type FeedbackUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<FeedbackCreateWithoutFilesInput, FeedbackUncheckedCreateWithoutFilesInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutFilesInput
    upsert?: FeedbackUpsertWithoutFilesInput
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutFilesInput, FeedbackUncheckedUpdateWithoutFilesInput>
  }

  export type FeedbackCreateNestedOneWithoutActionFilesInput = {
    create?: XOR<FeedbackCreateWithoutActionFilesInput, FeedbackUncheckedCreateWithoutActionFilesInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutActionFilesInput
    connect?: FeedbackWhereUniqueInput
  }

  export type FeedbackUpdateOneRequiredWithoutActionFilesNestedInput = {
    create?: XOR<FeedbackCreateWithoutActionFilesInput, FeedbackUncheckedCreateWithoutActionFilesInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutActionFilesInput
    upsert?: FeedbackUpsertWithoutActionFilesInput
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutActionFilesInput, FeedbackUncheckedUpdateWithoutActionFilesInput>
  }

  export type MembersListCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MembersListCreateWithoutMeetingInput, MembersListUncheckedCreateWithoutMeetingInput> | MembersListCreateWithoutMeetingInput[] | MembersListUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersListCreateOrConnectWithoutMeetingInput | MembersListCreateOrConnectWithoutMeetingInput[]
    createMany?: MembersListCreateManyMeetingInputEnvelope
    connect?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
  }

  export type MembersAttendedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MembersAttendedCreateWithoutMeetingInput, MembersAttendedUncheckedCreateWithoutMeetingInput> | MembersAttendedCreateWithoutMeetingInput[] | MembersAttendedUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersAttendedCreateOrConnectWithoutMeetingInput | MembersAttendedCreateOrConnectWithoutMeetingInput[]
    createMany?: MembersAttendedCreateManyMeetingInputEnvelope
    connect?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
  }

  export type MembersListUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MembersListCreateWithoutMeetingInput, MembersListUncheckedCreateWithoutMeetingInput> | MembersListCreateWithoutMeetingInput[] | MembersListUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersListCreateOrConnectWithoutMeetingInput | MembersListCreateOrConnectWithoutMeetingInput[]
    createMany?: MembersListCreateManyMeetingInputEnvelope
    connect?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
  }

  export type MembersAttendedUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MembersAttendedCreateWithoutMeetingInput, MembersAttendedUncheckedCreateWithoutMeetingInput> | MembersAttendedCreateWithoutMeetingInput[] | MembersAttendedUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersAttendedCreateOrConnectWithoutMeetingInput | MembersAttendedCreateOrConnectWithoutMeetingInput[]
    createMany?: MembersAttendedCreateManyMeetingInputEnvelope
    connect?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MembersListUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MembersListCreateWithoutMeetingInput, MembersListUncheckedCreateWithoutMeetingInput> | MembersListCreateWithoutMeetingInput[] | MembersListUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersListCreateOrConnectWithoutMeetingInput | MembersListCreateOrConnectWithoutMeetingInput[]
    upsert?: MembersListUpsertWithWhereUniqueWithoutMeetingInput | MembersListUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MembersListCreateManyMeetingInputEnvelope
    set?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    disconnect?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    delete?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    connect?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    update?: MembersListUpdateWithWhereUniqueWithoutMeetingInput | MembersListUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MembersListUpdateManyWithWhereWithoutMeetingInput | MembersListUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MembersListScalarWhereInput | MembersListScalarWhereInput[]
  }

  export type MembersAttendedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MembersAttendedCreateWithoutMeetingInput, MembersAttendedUncheckedCreateWithoutMeetingInput> | MembersAttendedCreateWithoutMeetingInput[] | MembersAttendedUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersAttendedCreateOrConnectWithoutMeetingInput | MembersAttendedCreateOrConnectWithoutMeetingInput[]
    upsert?: MembersAttendedUpsertWithWhereUniqueWithoutMeetingInput | MembersAttendedUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MembersAttendedCreateManyMeetingInputEnvelope
    set?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    disconnect?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    delete?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    connect?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    update?: MembersAttendedUpdateWithWhereUniqueWithoutMeetingInput | MembersAttendedUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MembersAttendedUpdateManyWithWhereWithoutMeetingInput | MembersAttendedUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MembersAttendedScalarWhereInput | MembersAttendedScalarWhereInput[]
  }

  export type MembersListUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MembersListCreateWithoutMeetingInput, MembersListUncheckedCreateWithoutMeetingInput> | MembersListCreateWithoutMeetingInput[] | MembersListUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersListCreateOrConnectWithoutMeetingInput | MembersListCreateOrConnectWithoutMeetingInput[]
    upsert?: MembersListUpsertWithWhereUniqueWithoutMeetingInput | MembersListUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MembersListCreateManyMeetingInputEnvelope
    set?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    disconnect?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    delete?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    connect?: MembersListWhereUniqueInput | MembersListWhereUniqueInput[]
    update?: MembersListUpdateWithWhereUniqueWithoutMeetingInput | MembersListUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MembersListUpdateManyWithWhereWithoutMeetingInput | MembersListUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MembersListScalarWhereInput | MembersListScalarWhereInput[]
  }

  export type MembersAttendedUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MembersAttendedCreateWithoutMeetingInput, MembersAttendedUncheckedCreateWithoutMeetingInput> | MembersAttendedCreateWithoutMeetingInput[] | MembersAttendedUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MembersAttendedCreateOrConnectWithoutMeetingInput | MembersAttendedCreateOrConnectWithoutMeetingInput[]
    upsert?: MembersAttendedUpsertWithWhereUniqueWithoutMeetingInput | MembersAttendedUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MembersAttendedCreateManyMeetingInputEnvelope
    set?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    disconnect?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    delete?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    connect?: MembersAttendedWhereUniqueInput | MembersAttendedWhereUniqueInput[]
    update?: MembersAttendedUpdateWithWhereUniqueWithoutMeetingInput | MembersAttendedUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MembersAttendedUpdateManyWithWhereWithoutMeetingInput | MembersAttendedUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MembersAttendedScalarWhereInput | MembersAttendedScalarWhereInput[]
  }

  export type MeetingCreateNestedOneWithoutMembersListInput = {
    create?: XOR<MeetingCreateWithoutMembersListInput, MeetingUncheckedCreateWithoutMembersListInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutMembersListInput
    connect?: MeetingWhereUniqueInput
  }

  export type MeetingUpdateOneRequiredWithoutMembersListNestedInput = {
    create?: XOR<MeetingCreateWithoutMembersListInput, MeetingUncheckedCreateWithoutMembersListInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutMembersListInput
    upsert?: MeetingUpsertWithoutMembersListInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<MeetingUpdateWithoutMembersListInput, MeetingUncheckedUpdateWithoutMembersListInput>
  }

  export type DigitalSignatureFileCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<DigitalSignatureFileCreateWithoutAttendanceInput, DigitalSignatureFileUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: DigitalSignatureFileCreateOrConnectWithoutAttendanceInput
    connect?: DigitalSignatureFileWhereUniqueInput
  }

  export type MeetingCreateNestedOneWithoutMembersAttendedInput = {
    create?: XOR<MeetingCreateWithoutMembersAttendedInput, MeetingUncheckedCreateWithoutMembersAttendedInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutMembersAttendedInput
    connect?: MeetingWhereUniqueInput
  }

  export type DigitalSignatureFileUncheckedCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<DigitalSignatureFileCreateWithoutAttendanceInput, DigitalSignatureFileUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: DigitalSignatureFileCreateOrConnectWithoutAttendanceInput
    connect?: DigitalSignatureFileWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DigitalSignatureFileUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<DigitalSignatureFileCreateWithoutAttendanceInput, DigitalSignatureFileUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: DigitalSignatureFileCreateOrConnectWithoutAttendanceInput
    upsert?: DigitalSignatureFileUpsertWithoutAttendanceInput
    disconnect?: boolean
    delete?: boolean
    connect?: DigitalSignatureFileWhereUniqueInput
    update?: XOR<DigitalSignatureFileUpdateWithoutAttendanceInput, DigitalSignatureFileUncheckedUpdateWithoutAttendanceInput>
  }

  export type MeetingUpdateOneRequiredWithoutMembersAttendedNestedInput = {
    create?: XOR<MeetingCreateWithoutMembersAttendedInput, MeetingUncheckedCreateWithoutMembersAttendedInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutMembersAttendedInput
    upsert?: MeetingUpsertWithoutMembersAttendedInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<MeetingUpdateWithoutMembersAttendedInput, MeetingUncheckedUpdateWithoutMembersAttendedInput>
  }

  export type DigitalSignatureFileUncheckedUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<DigitalSignatureFileCreateWithoutAttendanceInput, DigitalSignatureFileUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: DigitalSignatureFileCreateOrConnectWithoutAttendanceInput
    upsert?: DigitalSignatureFileUpsertWithoutAttendanceInput
    disconnect?: boolean
    delete?: boolean
    connect?: DigitalSignatureFileWhereUniqueInput
    update?: XOR<DigitalSignatureFileUpdateWithoutAttendanceInput, DigitalSignatureFileUncheckedUpdateWithoutAttendanceInput>
  }

  export type MembersAttendedCreateNestedOneWithoutDigitalSignatureFileInput = {
    create?: XOR<MembersAttendedCreateWithoutDigitalSignatureFileInput, MembersAttendedUncheckedCreateWithoutDigitalSignatureFileInput>
    connectOrCreate?: MembersAttendedCreateOrConnectWithoutDigitalSignatureFileInput
    connect?: MembersAttendedWhereUniqueInput
  }

  export type MembersAttendedUpdateOneRequiredWithoutDigitalSignatureFileNestedInput = {
    create?: XOR<MembersAttendedCreateWithoutDigitalSignatureFileInput, MembersAttendedUncheckedCreateWithoutDigitalSignatureFileInput>
    connectOrCreate?: MembersAttendedCreateOrConnectWithoutDigitalSignatureFileInput
    upsert?: MembersAttendedUpsertWithoutDigitalSignatureFileInput
    connect?: MembersAttendedWhereUniqueInput
    update?: XOR<MembersAttendedUpdateWithoutDigitalSignatureFileInput, MembersAttendedUncheckedUpdateWithoutDigitalSignatureFileInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumUserTypeFilter = {
    equals?: $Enums.UserType
    in?: $Enums.UserType[] | $Enums.UserType
    notIn?: $Enums.UserType[] | $Enums.UserType
    not?: NestedEnumUserTypeFilter | $Enums.UserType
  }

  export type NestedEnumAdminApprovedFilter = {
    equals?: $Enums.AdminApproved
    in?: $Enums.AdminApproved[] | $Enums.AdminApproved
    notIn?: $Enums.AdminApproved[] | $Enums.AdminApproved
    not?: NestedEnumAdminApprovedFilter | $Enums.AdminApproved
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumUserTypeWithAggregatesFilter = {
    equals?: $Enums.UserType
    in?: $Enums.UserType[] | $Enums.UserType
    notIn?: $Enums.UserType[] | $Enums.UserType
    not?: NestedEnumUserTypeWithAggregatesFilter | $Enums.UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type NestedEnumAdminApprovedWithAggregatesFilter = {
    equals?: $Enums.AdminApproved
    in?: $Enums.AdminApproved[] | $Enums.AdminApproved
    notIn?: $Enums.AdminApproved[] | $Enums.AdminApproved
    not?: NestedEnumAdminApprovedWithAggregatesFilter | $Enums.AdminApproved
    _count?: NestedIntFilter
    _min?: NestedEnumAdminApprovedFilter
    _max?: NestedEnumAdminApprovedFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumFeedbackColorFilter = {
    equals?: $Enums.FeedbackColor
    in?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    notIn?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    not?: NestedEnumFeedbackColorFilter | $Enums.FeedbackColor
  }

  export type NestedEnumStatusNullableFilter = {
    equals?: $Enums.Status | null
    in?: $Enums.Status[] | $Enums.Status | null
    notIn?: $Enums.Status[] | $Enums.Status | null
    not?: NestedEnumStatusNullableFilter | $Enums.Status | null
  }

  export type NestedEnumFeedbackColorWithAggregatesFilter = {
    equals?: $Enums.FeedbackColor
    in?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    notIn?: $Enums.FeedbackColor[] | $Enums.FeedbackColor
    not?: NestedEnumFeedbackColorWithAggregatesFilter | $Enums.FeedbackColor
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackColorFilter
    _max?: NestedEnumFeedbackColorFilter
  }

  export type NestedEnumStatusNullableWithAggregatesFilter = {
    equals?: $Enums.Status | null
    in?: $Enums.Status[] | $Enums.Status | null
    notIn?: $Enums.Status[] | $Enums.Status | null
    not?: NestedEnumStatusNullableWithAggregatesFilter | $Enums.Status | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumStatusNullableFilter
    _max?: NestedEnumStatusNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type MemberCreateWithoutUserInput = {
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    groupId: number
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutCreatedByInput = {
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
    read?: ReadCreateNestedManyWithoutMessageInput
    files?: FileCreateNestedManyWithoutMessageInput
    groups?: GroupCreateNestedManyWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
    read?: ReadUncheckedCreateNestedManyWithoutMessageInput
    files?: FileUncheckedCreateNestedManyWithoutMessageInput
    groups?: GroupUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessageCreateOrConnectWithoutCreatedByInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput>
  }

  export type MessageCreateManyCreatedByInputEnvelope = {
    data: MessageCreateManyCreatedByInput | MessageCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReadCreateWithoutUserInput = {
    groupId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadInput
  }

  export type ReadUncheckedCreateWithoutUserInput = {
    id?: number
    messageId: number
    groupId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
  }

  export type ReadCreateOrConnectWithoutUserInput = {
    where: ReadWhereUniqueInput
    create: XOR<ReadCreateWithoutUserInput, ReadUncheckedCreateWithoutUserInput>
  }

  export type ReadCreateManyUserInputEnvelope = {
    data: ReadCreateManyUserInput | ReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutCreatedByInput = {
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
    files?: FeedbackFileCreateNestedManyWithoutFeedbackInput
    actionFiles?: FeedbackActionFileCreateNestedManyWithoutFeedbackInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutCreatedByInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
    files?: FeedbackFileUncheckedCreateNestedManyWithoutFeedbackInput
    actionFiles?: FeedbackActionFileUncheckedCreateNestedManyWithoutFeedbackInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackCreateOrConnectWithoutCreatedByInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutCreatedByInput, FeedbackUncheckedCreateWithoutCreatedByInput>
  }

  export type FeedbackCreateManyCreatedByInputEnvelope = {
    data: FeedbackCreateManyCreatedByInput | FeedbackCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackAssignmentCreateWithoutUserInput = {
    assignmentCompleted: boolean
    feedback: FeedbackCreateNestedOneWithoutFeedbackAssignmentsInput
  }

  export type FeedbackAssignmentUncheckedCreateWithoutUserInput = {
    id?: number
    assignmentCompleted: boolean
    feedbackId: number
  }

  export type FeedbackAssignmentCreateOrConnectWithoutUserInput = {
    where: FeedbackAssignmentWhereUniqueInput
    create: XOR<FeedbackAssignmentCreateWithoutUserInput, FeedbackAssignmentUncheckedCreateWithoutUserInput>
  }

  export type FeedbackAssignmentCreateManyUserInputEnvelope = {
    data: FeedbackAssignmentCreateManyUserInput | FeedbackAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserOrientationReadCreateWithoutUserInput = {
    readAt?: Date | string
    userOrientation: UserOrientationCreateNestedOneWithoutUserOrientationReadsInput
  }

  export type UserOrientationReadUncheckedCreateWithoutUserInput = {
    id?: number
    userOrientationId: number
    readAt?: Date | string
  }

  export type UserOrientationReadCreateOrConnectWithoutUserInput = {
    where: UserOrientationReadWhereUniqueInput
    create: XOR<UserOrientationReadCreateWithoutUserInput, UserOrientationReadUncheckedCreateWithoutUserInput>
  }

  export type UserOrientationReadCreateManyUserInputEnvelope = {
    data: UserOrientationReadCreateManyUserInput | UserOrientationReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMemberInGroupsInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    groupId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type MessageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutCreatedByInput, MessageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<MessageCreateWithoutCreatedByInput, MessageUncheckedCreateWithoutCreatedByInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutCreatedByInput, MessageUncheckedUpdateWithoutCreatedByInput>
  }

  export type MessageUpdateManyWithWhereWithoutCreatedByInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    timer?: IntFilter | number
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type ReadUpsertWithWhereUniqueWithoutUserInput = {
    where: ReadWhereUniqueInput
    update: XOR<ReadUpdateWithoutUserInput, ReadUncheckedUpdateWithoutUserInput>
    create: XOR<ReadCreateWithoutUserInput, ReadUncheckedCreateWithoutUserInput>
  }

  export type ReadUpdateWithWhereUniqueWithoutUserInput = {
    where: ReadWhereUniqueInput
    data: XOR<ReadUpdateWithoutUserInput, ReadUncheckedUpdateWithoutUserInput>
  }

  export type ReadUpdateManyWithWhereWithoutUserInput = {
    where: ReadScalarWhereInput
    data: XOR<ReadUpdateManyMutationInput, ReadUncheckedUpdateManyWithoutReadsInput>
  }

  export type ReadScalarWhereInput = {
    AND?: ReadScalarWhereInput | ReadScalarWhereInput[]
    OR?: ReadScalarWhereInput[]
    NOT?: ReadScalarWhereInput | ReadScalarWhereInput[]
    id?: IntFilter | number
    messageId?: IntFilter | number
    groupId?: IntFilter | number
    userId?: IntFilter | number
    reply?: StringNullableFilter | string | null
    mode?: StringNullableFilter | string | null
    readAt?: DateTimeFilter | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutCreatedByInput, FeedbackUncheckedUpdateWithoutCreatedByInput>
    create: XOR<FeedbackCreateWithoutCreatedByInput, FeedbackUncheckedCreateWithoutCreatedByInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutCreatedByInput, FeedbackUncheckedUpdateWithoutCreatedByInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutCreatedByInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbacksInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter | number
    location?: StringFilter | string
    organizationName?: StringFilter | string
    date?: StringFilter | string
    time?: StringFilter | string
    feedback?: StringFilter | string
    source?: StringFilter | string
    color?: EnumFeedbackColorFilter | $Enums.FeedbackColor
    selectedValues?: StringFilter | string
    description?: StringFilter | string
    reportedBy?: StringFilter | string
    responsiblePerson?: StringNullableFilter | string | null
    actionTaken?: StringNullableFilter | string | null
    status?: EnumStatusNullableFilter | $Enums.Status | null
    userAcknowledgement?: StringNullableFilter | string | null
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type FeedbackAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackAssignmentWhereUniqueInput
    update: XOR<FeedbackAssignmentUpdateWithoutUserInput, FeedbackAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackAssignmentCreateWithoutUserInput, FeedbackAssignmentUncheckedCreateWithoutUserInput>
  }

  export type FeedbackAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackAssignmentWhereUniqueInput
    data: XOR<FeedbackAssignmentUpdateWithoutUserInput, FeedbackAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackAssignmentScalarWhereInput
    data: XOR<FeedbackAssignmentUpdateManyMutationInput, FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackAssignmentsInput>
  }

  export type FeedbackAssignmentScalarWhereInput = {
    AND?: FeedbackAssignmentScalarWhereInput | FeedbackAssignmentScalarWhereInput[]
    OR?: FeedbackAssignmentScalarWhereInput[]
    NOT?: FeedbackAssignmentScalarWhereInput | FeedbackAssignmentScalarWhereInput[]
    id?: IntFilter | number
    assignmentCompleted?: BoolFilter | boolean
    feedbackId?: IntFilter | number
    userId?: IntFilter | number
  }

  export type UserOrientationReadUpsertWithWhereUniqueWithoutUserInput = {
    where: UserOrientationReadWhereUniqueInput
    update: XOR<UserOrientationReadUpdateWithoutUserInput, UserOrientationReadUncheckedUpdateWithoutUserInput>
    create: XOR<UserOrientationReadCreateWithoutUserInput, UserOrientationReadUncheckedCreateWithoutUserInput>
  }

  export type UserOrientationReadUpdateWithWhereUniqueWithoutUserInput = {
    where: UserOrientationReadWhereUniqueInput
    data: XOR<UserOrientationReadUpdateWithoutUserInput, UserOrientationReadUncheckedUpdateWithoutUserInput>
  }

  export type UserOrientationReadUpdateManyWithWhereWithoutUserInput = {
    where: UserOrientationReadScalarWhereInput
    data: XOR<UserOrientationReadUpdateManyMutationInput, UserOrientationReadUncheckedUpdateManyWithoutUserOrientationReadsInput>
  }

  export type UserOrientationReadScalarWhereInput = {
    AND?: UserOrientationReadScalarWhereInput | UserOrientationReadScalarWhereInput[]
    OR?: UserOrientationReadScalarWhereInput[]
    NOT?: UserOrientationReadScalarWhereInput | UserOrientationReadScalarWhereInput[]
    id?: IntFilter | number
    userOrientationId?: IntFilter | number
    userId?: IntFilter | number
    readAt?: DateTimeFilter | Date | string
  }

  export type MemberCreateWithoutGroupInput = {
    user: UserCreateNestedOneWithoutMemberInGroupsInput
  }

  export type MemberUncheckedCreateWithoutGroupInput = {
    userId: number
  }

  export type MemberCreateOrConnectWithoutGroupInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutGroupInput, MemberUncheckedCreateWithoutGroupInput>
  }

  export type MemberCreateManyGroupInputEnvelope = {
    data: MemberCreateManyGroupInput | MemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type RiskAssessmentCreateWithoutGroupInput = {
    name: string
    createdAt?: Date | string
  }

  export type RiskAssessmentUncheckedCreateWithoutGroupInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type RiskAssessmentCreateOrConnectWithoutGroupInput = {
    where: RiskAssessmentWhereUniqueInput
    create: XOR<RiskAssessmentCreateWithoutGroupInput, RiskAssessmentUncheckedCreateWithoutGroupInput>
  }

  export type RiskAssessmentCreateManyGroupInputEnvelope = {
    data: RiskAssessmentCreateManyGroupInput | RiskAssessmentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutGroupsInput = {
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
    read?: ReadCreateNestedManyWithoutMessageInput
    files?: FileCreateNestedManyWithoutMessageInput
    createdBy: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutGroupsInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdById: number
    createdAt?: Date | string
    read?: ReadUncheckedCreateNestedManyWithoutMessageInput
    files?: FileUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutGroupsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutGroupsInput, MessageUncheckedCreateWithoutGroupsInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutGroupInput, MemberUncheckedUpdateWithoutGroupInput>
    create: XOR<MemberCreateWithoutGroupInput, MemberUncheckedCreateWithoutGroupInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutGroupInput, MemberUncheckedUpdateWithoutGroupInput>
  }

  export type MemberUpdateManyWithWhereWithoutGroupInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMembersInput>
  }

  export type RiskAssessmentUpsertWithWhereUniqueWithoutGroupInput = {
    where: RiskAssessmentWhereUniqueInput
    update: XOR<RiskAssessmentUpdateWithoutGroupInput, RiskAssessmentUncheckedUpdateWithoutGroupInput>
    create: XOR<RiskAssessmentCreateWithoutGroupInput, RiskAssessmentUncheckedCreateWithoutGroupInput>
  }

  export type RiskAssessmentUpdateWithWhereUniqueWithoutGroupInput = {
    where: RiskAssessmentWhereUniqueInput
    data: XOR<RiskAssessmentUpdateWithoutGroupInput, RiskAssessmentUncheckedUpdateWithoutGroupInput>
  }

  export type RiskAssessmentUpdateManyWithWhereWithoutGroupInput = {
    where: RiskAssessmentScalarWhereInput
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyWithoutAssessmentsInput>
  }

  export type RiskAssessmentScalarWhereInput = {
    AND?: RiskAssessmentScalarWhereInput | RiskAssessmentScalarWhereInput[]
    OR?: RiskAssessmentScalarWhereInput[]
    NOT?: RiskAssessmentScalarWhereInput | RiskAssessmentScalarWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    groupId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutGroupsInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutGroupsInput, MessageUncheckedUpdateWithoutGroupsInput>
    create: XOR<MessageCreateWithoutGroupsInput, MessageUncheckedCreateWithoutGroupsInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutGroupsInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutGroupsInput, MessageUncheckedUpdateWithoutGroupsInput>
  }

  export type MessageUpdateManyWithWhereWithoutGroupsInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type GroupCreateWithoutMembersInput = {
    avatar?: string | null
    name: string
    createdAt?: Date | string
    assessments?: RiskAssessmentCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: number
    avatar?: string | null
    name: string
    createdAt?: Date | string
    assessments?: RiskAssessmentUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMemberInGroupsInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    messages?: MessageCreateNestedManyWithoutCreatedByInput
    reads?: ReadCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMemberInGroupsInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    reads?: ReadUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMemberInGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberInGroupsInput, UserUncheckedCreateWithoutMemberInGroupsInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessments?: RiskAssessmentUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessments?: RiskAssessmentUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type UserUpsertWithoutMemberInGroupsInput = {
    update: XOR<UserUpdateWithoutMemberInGroupsInput, UserUncheckedUpdateWithoutMemberInGroupsInput>
    create: XOR<UserCreateWithoutMemberInGroupsInput, UserUncheckedCreateWithoutMemberInGroupsInput>
  }

  export type UserUpdateWithoutMemberInGroupsInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberInGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReadCreateWithoutMessageInput = {
    groupId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
    user: UserCreateNestedOneWithoutReadsInput
  }

  export type ReadUncheckedCreateWithoutMessageInput = {
    id?: number
    groupId: number
    userId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
  }

  export type ReadCreateOrConnectWithoutMessageInput = {
    where: ReadWhereUniqueInput
    create: XOR<ReadCreateWithoutMessageInput, ReadUncheckedCreateWithoutMessageInput>
  }

  export type ReadCreateManyMessageInputEnvelope = {
    data: ReadCreateManyMessageInput | ReadCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutMessageInput = {
    name: string
    fileType: string
  }

  export type FileUncheckedCreateWithoutMessageInput = {
    id?: number
    name: string
    fileType: string
  }

  export type FileCreateOrConnectWithoutMessageInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutMessageInput, FileUncheckedCreateWithoutMessageInput>
  }

  export type FileCreateManyMessageInputEnvelope = {
    data: FileCreateManyMessageInput | FileCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMessagesInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberCreateNestedManyWithoutUserInput
    reads?: ReadCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberUncheckedCreateNestedManyWithoutUserInput
    reads?: ReadUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type GroupCreateWithoutMessagesInput = {
    avatar?: string | null
    name: string
    createdAt?: Date | string
    members?: MemberCreateNestedManyWithoutGroupInput
    assessments?: RiskAssessmentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMessagesInput = {
    id?: number
    avatar?: string | null
    name: string
    createdAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutGroupInput
    assessments?: RiskAssessmentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMessagesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
  }

  export type ReadUpsertWithWhereUniqueWithoutMessageInput = {
    where: ReadWhereUniqueInput
    update: XOR<ReadUpdateWithoutMessageInput, ReadUncheckedUpdateWithoutMessageInput>
    create: XOR<ReadCreateWithoutMessageInput, ReadUncheckedCreateWithoutMessageInput>
  }

  export type ReadUpdateWithWhereUniqueWithoutMessageInput = {
    where: ReadWhereUniqueInput
    data: XOR<ReadUpdateWithoutMessageInput, ReadUncheckedUpdateWithoutMessageInput>
  }

  export type ReadUpdateManyWithWhereWithoutMessageInput = {
    where: ReadScalarWhereInput
    data: XOR<ReadUpdateManyMutationInput, ReadUncheckedUpdateManyWithoutReadInput>
  }

  export type FileUpsertWithWhereUniqueWithoutMessageInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutMessageInput, FileUncheckedUpdateWithoutMessageInput>
    create: XOR<FileCreateWithoutMessageInput, FileUncheckedCreateWithoutMessageInput>
  }

  export type FileUpdateWithWhereUniqueWithoutMessageInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutMessageInput, FileUncheckedUpdateWithoutMessageInput>
  }

  export type FileUpdateManyWithWhereWithoutMessageInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFilesInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    messageId?: IntFilter | number
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUpdateManyWithoutUserNestedInput
    reads?: ReadUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUncheckedUpdateManyWithoutUserNestedInput
    reads?: ReadUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithWhereUniqueWithoutMessagesInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
    create: XOR<GroupCreateWithoutMessagesInput, GroupUncheckedCreateWithoutMessagesInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutMessagesInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutMessagesInput, GroupUncheckedUpdateWithoutMessagesInput>
  }

  export type GroupUpdateManyWithWhereWithoutMessagesInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutGroupsInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: IntFilter | number
    avatar?: StringNullableFilter | string | null
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type MessageCreateWithoutReadInput = {
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
    files?: FileCreateNestedManyWithoutMessageInput
    createdBy: UserCreateNestedOneWithoutMessagesInput
    groups?: GroupCreateNestedManyWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutReadInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdById: number
    createdAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutMessageInput
    groups?: GroupUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessageCreateOrConnectWithoutReadInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReadInput, MessageUncheckedCreateWithoutReadInput>
  }

  export type UserCreateWithoutReadsInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutCreatedByInput
    feedbacks?: FeedbackCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReadsInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReadsInput, UserUncheckedCreateWithoutReadsInput>
  }

  export type MessageUpsertWithoutReadInput = {
    update: XOR<MessageUpdateWithoutReadInput, MessageUncheckedUpdateWithoutReadInput>
    create: XOR<MessageCreateWithoutReadInput, MessageUncheckedCreateWithoutReadInput>
  }

  export type MessageUpdateWithoutReadInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUpdateManyWithoutMessageNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMessagesNestedInput
    groups?: GroupUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReadInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutMessageNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type UserUpsertWithoutReadsInput = {
    update: XOR<UserUpdateWithoutReadsInput, UserUncheckedUpdateWithoutReadsInput>
    create: XOR<UserCreateWithoutReadsInput, UserUncheckedCreateWithoutReadsInput>
  }

  export type UserUpdateWithoutReadsInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutCreatedByNestedInput
    feedbacks?: FeedbackUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutFilesInput = {
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
    read?: ReadCreateNestedManyWithoutMessageInput
    createdBy: UserCreateNestedOneWithoutMessagesInput
    groups?: GroupCreateNestedManyWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutFilesInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdById: number
    createdAt?: Date | string
    read?: ReadUncheckedCreateNestedManyWithoutMessageInput
    groups?: GroupUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessageCreateOrConnectWithoutFilesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutFilesInput, MessageUncheckedCreateWithoutFilesInput>
  }

  export type MessageUpsertWithoutFilesInput = {
    update: XOR<MessageUpdateWithoutFilesInput, MessageUncheckedUpdateWithoutFilesInput>
    create: XOR<MessageCreateWithoutFilesInput, MessageUncheckedCreateWithoutFilesInput>
  }

  export type MessageUpdateWithoutFilesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUpdateManyWithoutMessageNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMessagesNestedInput
    groups?: GroupUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUncheckedUpdateManyWithoutMessageNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type GroupCreateWithoutAssessmentsInput = {
    avatar?: string | null
    name: string
    createdAt?: Date | string
    members?: MemberCreateNestedManyWithoutGroupInput
    messages?: MessageCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutAssessmentsInput = {
    id?: number
    avatar?: string | null
    name: string
    createdAt?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutGroupInput
    messages?: MessageUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutAssessmentsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutAssessmentsInput, GroupUncheckedCreateWithoutAssessmentsInput>
  }

  export type GroupUpsertWithoutAssessmentsInput = {
    update: XOR<GroupUpdateWithoutAssessmentsInput, GroupUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<GroupCreateWithoutAssessmentsInput, GroupUncheckedCreateWithoutAssessmentsInput>
  }

  export type GroupUpdateWithoutAssessmentsInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutGroupNestedInput
    messages?: MessageUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutAssessmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutGroupNestedInput
    messages?: MessageUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type UserOrientationReadCreateWithoutUserOrientationInput = {
    readAt?: Date | string
    user: UserCreateNestedOneWithoutUserOrientationReadsInput
  }

  export type UserOrientationReadUncheckedCreateWithoutUserOrientationInput = {
    id?: number
    userId: number
    readAt?: Date | string
  }

  export type UserOrientationReadCreateOrConnectWithoutUserOrientationInput = {
    where: UserOrientationReadWhereUniqueInput
    create: XOR<UserOrientationReadCreateWithoutUserOrientationInput, UserOrientationReadUncheckedCreateWithoutUserOrientationInput>
  }

  export type UserOrientationReadCreateManyUserOrientationInputEnvelope = {
    data: UserOrientationReadCreateManyUserOrientationInput | UserOrientationReadCreateManyUserOrientationInput[]
    skipDuplicates?: boolean
  }

  export type UserOrientationReadUpsertWithWhereUniqueWithoutUserOrientationInput = {
    where: UserOrientationReadWhereUniqueInput
    update: XOR<UserOrientationReadUpdateWithoutUserOrientationInput, UserOrientationReadUncheckedUpdateWithoutUserOrientationInput>
    create: XOR<UserOrientationReadCreateWithoutUserOrientationInput, UserOrientationReadUncheckedCreateWithoutUserOrientationInput>
  }

  export type UserOrientationReadUpdateWithWhereUniqueWithoutUserOrientationInput = {
    where: UserOrientationReadWhereUniqueInput
    data: XOR<UserOrientationReadUpdateWithoutUserOrientationInput, UserOrientationReadUncheckedUpdateWithoutUserOrientationInput>
  }

  export type UserOrientationReadUpdateManyWithWhereWithoutUserOrientationInput = {
    where: UserOrientationReadScalarWhereInput
    data: XOR<UserOrientationReadUpdateManyMutationInput, UserOrientationReadUncheckedUpdateManyWithoutUserOrientationReadsInput>
  }

  export type UserOrientationCreateWithoutUserOrientationReadsInput = {
    name: string
    createdAt?: Date | string
  }

  export type UserOrientationUncheckedCreateWithoutUserOrientationReadsInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type UserOrientationCreateOrConnectWithoutUserOrientationReadsInput = {
    where: UserOrientationWhereUniqueInput
    create: XOR<UserOrientationCreateWithoutUserOrientationReadsInput, UserOrientationUncheckedCreateWithoutUserOrientationReadsInput>
  }

  export type UserCreateWithoutUserOrientationReadsInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutCreatedByInput
    reads?: ReadCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserOrientationReadsInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    reads?: ReadUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutCreatedByInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserOrientationReadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserOrientationReadsInput, UserUncheckedCreateWithoutUserOrientationReadsInput>
  }

  export type UserOrientationUpsertWithoutUserOrientationReadsInput = {
    update: XOR<UserOrientationUpdateWithoutUserOrientationReadsInput, UserOrientationUncheckedUpdateWithoutUserOrientationReadsInput>
    create: XOR<UserOrientationCreateWithoutUserOrientationReadsInput, UserOrientationUncheckedCreateWithoutUserOrientationReadsInput>
  }

  export type UserOrientationUpdateWithoutUserOrientationReadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationUncheckedUpdateWithoutUserOrientationReadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUserOrientationReadsInput = {
    update: XOR<UserUpdateWithoutUserOrientationReadsInput, UserUncheckedUpdateWithoutUserOrientationReadsInput>
    create: XOR<UserCreateWithoutUserOrientationReadsInput, UserUncheckedCreateWithoutUserOrientationReadsInput>
  }

  export type UserUpdateWithoutUserOrientationReadsInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserOrientationReadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackFileCreateWithoutFeedbackInput = {
    name: string
    fileType: string
  }

  export type FeedbackFileUncheckedCreateWithoutFeedbackInput = {
    id?: number
    name: string
    fileType: string
  }

  export type FeedbackFileCreateOrConnectWithoutFeedbackInput = {
    where: FeedbackFileWhereUniqueInput
    create: XOR<FeedbackFileCreateWithoutFeedbackInput, FeedbackFileUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackFileCreateManyFeedbackInputEnvelope = {
    data: FeedbackFileCreateManyFeedbackInput | FeedbackFileCreateManyFeedbackInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackActionFileCreateWithoutFeedbackInput = {
    name: string
    fileType: string
  }

  export type FeedbackActionFileUncheckedCreateWithoutFeedbackInput = {
    id?: number
    name: string
    fileType: string
  }

  export type FeedbackActionFileCreateOrConnectWithoutFeedbackInput = {
    where: FeedbackActionFileWhereUniqueInput
    create: XOR<FeedbackActionFileCreateWithoutFeedbackInput, FeedbackActionFileUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackActionFileCreateManyFeedbackInputEnvelope = {
    data: FeedbackActionFileCreateManyFeedbackInput | FeedbackActionFileCreateManyFeedbackInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFeedbacksInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutCreatedByInput
    reads?: ReadCreateNestedManyWithoutUserInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    reads?: ReadUncheckedCreateNestedManyWithoutUserInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutUserInput
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type FeedbackAssignmentCreateWithoutFeedbackInput = {
    assignmentCompleted: boolean
    user: UserCreateNestedOneWithoutFeedbackAssignmentsInput
  }

  export type FeedbackAssignmentUncheckedCreateWithoutFeedbackInput = {
    id?: number
    assignmentCompleted: boolean
    userId: number
  }

  export type FeedbackAssignmentCreateOrConnectWithoutFeedbackInput = {
    where: FeedbackAssignmentWhereUniqueInput
    create: XOR<FeedbackAssignmentCreateWithoutFeedbackInput, FeedbackAssignmentUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackAssignmentCreateManyFeedbackInputEnvelope = {
    data: FeedbackAssignmentCreateManyFeedbackInput | FeedbackAssignmentCreateManyFeedbackInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackFileUpsertWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackFileWhereUniqueInput
    update: XOR<FeedbackFileUpdateWithoutFeedbackInput, FeedbackFileUncheckedUpdateWithoutFeedbackInput>
    create: XOR<FeedbackFileCreateWithoutFeedbackInput, FeedbackFileUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackFileUpdateWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackFileWhereUniqueInput
    data: XOR<FeedbackFileUpdateWithoutFeedbackInput, FeedbackFileUncheckedUpdateWithoutFeedbackInput>
  }

  export type FeedbackFileUpdateManyWithWhereWithoutFeedbackInput = {
    where: FeedbackFileScalarWhereInput
    data: XOR<FeedbackFileUpdateManyMutationInput, FeedbackFileUncheckedUpdateManyWithoutFilesInput>
  }

  export type FeedbackFileScalarWhereInput = {
    AND?: FeedbackFileScalarWhereInput | FeedbackFileScalarWhereInput[]
    OR?: FeedbackFileScalarWhereInput[]
    NOT?: FeedbackFileScalarWhereInput | FeedbackFileScalarWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    feedbackId?: IntFilter | number
  }

  export type FeedbackActionFileUpsertWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackActionFileWhereUniqueInput
    update: XOR<FeedbackActionFileUpdateWithoutFeedbackInput, FeedbackActionFileUncheckedUpdateWithoutFeedbackInput>
    create: XOR<FeedbackActionFileCreateWithoutFeedbackInput, FeedbackActionFileUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackActionFileUpdateWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackActionFileWhereUniqueInput
    data: XOR<FeedbackActionFileUpdateWithoutFeedbackInput, FeedbackActionFileUncheckedUpdateWithoutFeedbackInput>
  }

  export type FeedbackActionFileUpdateManyWithWhereWithoutFeedbackInput = {
    where: FeedbackActionFileScalarWhereInput
    data: XOR<FeedbackActionFileUpdateManyMutationInput, FeedbackActionFileUncheckedUpdateManyWithoutActionFilesInput>
  }

  export type FeedbackActionFileScalarWhereInput = {
    AND?: FeedbackActionFileScalarWhereInput | FeedbackActionFileScalarWhereInput[]
    OR?: FeedbackActionFileScalarWhereInput[]
    NOT?: FeedbackActionFileScalarWhereInput | FeedbackActionFileScalarWhereInput[]
    id?: IntFilter | number
    name?: StringFilter | string
    fileType?: StringFilter | string
    feedbackId?: IntFilter | number
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUpdateManyWithoutUserNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUncheckedUpdateManyWithoutUserNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutUserNestedInput
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackAssignmentUpsertWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackAssignmentWhereUniqueInput
    update: XOR<FeedbackAssignmentUpdateWithoutFeedbackInput, FeedbackAssignmentUncheckedUpdateWithoutFeedbackInput>
    create: XOR<FeedbackAssignmentCreateWithoutFeedbackInput, FeedbackAssignmentUncheckedCreateWithoutFeedbackInput>
  }

  export type FeedbackAssignmentUpdateWithWhereUniqueWithoutFeedbackInput = {
    where: FeedbackAssignmentWhereUniqueInput
    data: XOR<FeedbackAssignmentUpdateWithoutFeedbackInput, FeedbackAssignmentUncheckedUpdateWithoutFeedbackInput>
  }

  export type FeedbackAssignmentUpdateManyWithWhereWithoutFeedbackInput = {
    where: FeedbackAssignmentScalarWhereInput
    data: XOR<FeedbackAssignmentUpdateManyMutationInput, FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackAssignmentsInput>
  }

  export type FeedbackCreateWithoutFeedbackAssignmentsInput = {
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
    files?: FeedbackFileCreateNestedManyWithoutFeedbackInput
    actionFiles?: FeedbackActionFileCreateNestedManyWithoutFeedbackInput
    createdBy: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateWithoutFeedbackAssignmentsInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdById: number
    createdAt?: Date | string
    files?: FeedbackFileUncheckedCreateNestedManyWithoutFeedbackInput
    actionFiles?: FeedbackActionFileUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackCreateOrConnectWithoutFeedbackAssignmentsInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutFeedbackAssignmentsInput, FeedbackUncheckedCreateWithoutFeedbackAssignmentsInput>
  }

  export type UserCreateWithoutFeedbackAssignmentsInput = {
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutCreatedByInput
    reads?: ReadCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutCreatedByInput
    userOrientationReads?: UserOrientationReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackAssignmentsInput = {
    id?: number
    avatar?: string | null
    name: string
    email: string
    phone: string
    department: string
    employeeNumber?: string
    password: string
    fcmToken?: string | null
    type?: $Enums.UserType
    adminApproved?: $Enums.AdminApproved
    resetPasswordToken?: string | null
    resetPasswordExpire?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    memberInGroups?: MemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutCreatedByInput
    reads?: ReadUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutCreatedByInput
    userOrientationReads?: UserOrientationReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackAssignmentsInput, UserUncheckedCreateWithoutFeedbackAssignmentsInput>
  }

  export type FeedbackUpsertWithoutFeedbackAssignmentsInput = {
    update: XOR<FeedbackUpdateWithoutFeedbackAssignmentsInput, FeedbackUncheckedUpdateWithoutFeedbackAssignmentsInput>
    create: XOR<FeedbackCreateWithoutFeedbackAssignmentsInput, FeedbackUncheckedCreateWithoutFeedbackAssignmentsInput>
  }

  export type FeedbackUpdateWithoutFeedbackAssignmentsInput = {
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUpdateManyWithoutFeedbackNestedInput
    actionFiles?: FeedbackActionFileUpdateManyWithoutFeedbackNestedInput
    createdBy?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutFeedbackAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUncheckedUpdateManyWithoutFeedbackNestedInput
    actionFiles?: FeedbackActionFileUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type UserUpsertWithoutFeedbackAssignmentsInput = {
    update: XOR<UserUpdateWithoutFeedbackAssignmentsInput, UserUncheckedUpdateWithoutFeedbackAssignmentsInput>
    create: XOR<UserCreateWithoutFeedbackAssignmentsInput, UserUncheckedCreateWithoutFeedbackAssignmentsInput>
  }

  export type UserUpdateWithoutFeedbackAssignmentsInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutCreatedByNestedInput
    userOrientationReads?: UserOrientationReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    adminApproved?: EnumAdminApprovedFieldUpdateOperationsInput | $Enums.AdminApproved
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpire?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberInGroups?: MemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCreatedByNestedInput
    reads?: ReadUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutCreatedByNestedInput
    userOrientationReads?: UserOrientationReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackCreateWithoutFilesInput = {
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
    actionFiles?: FeedbackActionFileCreateNestedManyWithoutFeedbackInput
    createdBy: UserCreateNestedOneWithoutFeedbacksInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutFilesInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdById: number
    createdAt?: Date | string
    actionFiles?: FeedbackActionFileUncheckedCreateNestedManyWithoutFeedbackInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackCreateOrConnectWithoutFilesInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutFilesInput, FeedbackUncheckedCreateWithoutFilesInput>
  }

  export type FeedbackUpsertWithoutFilesInput = {
    update: XOR<FeedbackUpdateWithoutFilesInput, FeedbackUncheckedUpdateWithoutFilesInput>
    create: XOR<FeedbackCreateWithoutFilesInput, FeedbackUncheckedCreateWithoutFilesInput>
  }

  export type FeedbackUpdateWithoutFilesInput = {
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionFiles?: FeedbackActionFileUpdateManyWithoutFeedbackNestedInput
    createdBy?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionFiles?: FeedbackActionFileUncheckedUpdateManyWithoutFeedbackNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackCreateWithoutActionFilesInput = {
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
    files?: FeedbackFileCreateNestedManyWithoutFeedbackInput
    createdBy: UserCreateNestedOneWithoutFeedbacksInput
    feedbackAssignments?: FeedbackAssignmentCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutActionFilesInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdById: number
    createdAt?: Date | string
    files?: FeedbackFileUncheckedCreateNestedManyWithoutFeedbackInput
    feedbackAssignments?: FeedbackAssignmentUncheckedCreateNestedManyWithoutFeedbackInput
  }

  export type FeedbackCreateOrConnectWithoutActionFilesInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutActionFilesInput, FeedbackUncheckedCreateWithoutActionFilesInput>
  }

  export type FeedbackUpsertWithoutActionFilesInput = {
    update: XOR<FeedbackUpdateWithoutActionFilesInput, FeedbackUncheckedUpdateWithoutActionFilesInput>
    create: XOR<FeedbackCreateWithoutActionFilesInput, FeedbackUncheckedCreateWithoutActionFilesInput>
  }

  export type FeedbackUpdateWithoutActionFilesInput = {
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUpdateManyWithoutFeedbackNestedInput
    createdBy?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutActionFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUncheckedUpdateManyWithoutFeedbackNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type MembersListCreateWithoutMeetingInput = {
    memberId: string
    memberName: string
  }

  export type MembersListUncheckedCreateWithoutMeetingInput = {
    id?: number
    memberId: string
    memberName: string
  }

  export type MembersListCreateOrConnectWithoutMeetingInput = {
    where: MembersListWhereUniqueInput
    create: XOR<MembersListCreateWithoutMeetingInput, MembersListUncheckedCreateWithoutMeetingInput>
  }

  export type MembersListCreateManyMeetingInputEnvelope = {
    data: MembersListCreateManyMeetingInput | MembersListCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type MembersAttendedCreateWithoutMeetingInput = {
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    digitalSignatureFile?: DigitalSignatureFileCreateNestedOneWithoutAttendanceInput
  }

  export type MembersAttendedUncheckedCreateWithoutMeetingInput = {
    id?: number
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    digitalSignatureFile?: DigitalSignatureFileUncheckedCreateNestedOneWithoutAttendanceInput
  }

  export type MembersAttendedCreateOrConnectWithoutMeetingInput = {
    where: MembersAttendedWhereUniqueInput
    create: XOR<MembersAttendedCreateWithoutMeetingInput, MembersAttendedUncheckedCreateWithoutMeetingInput>
  }

  export type MembersAttendedCreateManyMeetingInputEnvelope = {
    data: MembersAttendedCreateManyMeetingInput | MembersAttendedCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type MembersListUpsertWithWhereUniqueWithoutMeetingInput = {
    where: MembersListWhereUniqueInput
    update: XOR<MembersListUpdateWithoutMeetingInput, MembersListUncheckedUpdateWithoutMeetingInput>
    create: XOR<MembersListCreateWithoutMeetingInput, MembersListUncheckedCreateWithoutMeetingInput>
  }

  export type MembersListUpdateWithWhereUniqueWithoutMeetingInput = {
    where: MembersListWhereUniqueInput
    data: XOR<MembersListUpdateWithoutMeetingInput, MembersListUncheckedUpdateWithoutMeetingInput>
  }

  export type MembersListUpdateManyWithWhereWithoutMeetingInput = {
    where: MembersListScalarWhereInput
    data: XOR<MembersListUpdateManyMutationInput, MembersListUncheckedUpdateManyWithoutMembersListInput>
  }

  export type MembersListScalarWhereInput = {
    AND?: MembersListScalarWhereInput | MembersListScalarWhereInput[]
    OR?: MembersListScalarWhereInput[]
    NOT?: MembersListScalarWhereInput | MembersListScalarWhereInput[]
    id?: IntFilter | number
    memberId?: StringFilter | string
    memberName?: StringFilter | string
    meetingId?: IntFilter | number
  }

  export type MembersAttendedUpsertWithWhereUniqueWithoutMeetingInput = {
    where: MembersAttendedWhereUniqueInput
    update: XOR<MembersAttendedUpdateWithoutMeetingInput, MembersAttendedUncheckedUpdateWithoutMeetingInput>
    create: XOR<MembersAttendedCreateWithoutMeetingInput, MembersAttendedUncheckedCreateWithoutMeetingInput>
  }

  export type MembersAttendedUpdateWithWhereUniqueWithoutMeetingInput = {
    where: MembersAttendedWhereUniqueInput
    data: XOR<MembersAttendedUpdateWithoutMeetingInput, MembersAttendedUncheckedUpdateWithoutMeetingInput>
  }

  export type MembersAttendedUpdateManyWithWhereWithoutMeetingInput = {
    where: MembersAttendedScalarWhereInput
    data: XOR<MembersAttendedUpdateManyMutationInput, MembersAttendedUncheckedUpdateManyWithoutMembersAttendedInput>
  }

  export type MembersAttendedScalarWhereInput = {
    AND?: MembersAttendedScalarWhereInput | MembersAttendedScalarWhereInput[]
    OR?: MembersAttendedScalarWhereInput[]
    NOT?: MembersAttendedScalarWhereInput | MembersAttendedScalarWhereInput[]
    id?: IntFilter | number
    memberId?: IntFilter | number
    membersName?: StringFilter | string
    memberInTime?: DateTimeFilter | Date | string
    memberOutTime?: DateTimeFilter | Date | string
    dateTime?: DateTimeFilter | Date | string
    latitude?: DecimalFilter | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter | Decimal | DecimalJsLike | number | string
    meetingId?: IntFilter | number
  }

  export type MeetingCreateWithoutMembersListInput = {
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
    membersAttended?: MembersAttendedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutMembersListInput = {
    meetingId?: number
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
    membersAttended?: MembersAttendedUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutMembersListInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutMembersListInput, MeetingUncheckedCreateWithoutMembersListInput>
  }

  export type MeetingUpsertWithoutMembersListInput = {
    update: XOR<MeetingUpdateWithoutMembersListInput, MeetingUncheckedUpdateWithoutMembersListInput>
    create: XOR<MeetingCreateWithoutMembersListInput, MeetingUncheckedCreateWithoutMembersListInput>
  }

  export type MeetingUpdateWithoutMembersListInput = {
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    membersAttended?: MembersAttendedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutMembersListInput = {
    meetingId?: IntFieldUpdateOperationsInput | number
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    membersAttended?: MembersAttendedUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type DigitalSignatureFileCreateWithoutAttendanceInput = {
    name: string
    fileType: string
    path: string
  }

  export type DigitalSignatureFileUncheckedCreateWithoutAttendanceInput = {
    fileId?: number
    name: string
    fileType: string
    path: string
  }

  export type DigitalSignatureFileCreateOrConnectWithoutAttendanceInput = {
    where: DigitalSignatureFileWhereUniqueInput
    create: XOR<DigitalSignatureFileCreateWithoutAttendanceInput, DigitalSignatureFileUncheckedCreateWithoutAttendanceInput>
  }

  export type MeetingCreateWithoutMembersAttendedInput = {
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
    membersList?: MembersListCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutMembersAttendedInput = {
    meetingId?: number
    meetCreater: string
    meetDateTime: Date | string
    meetTitle: string
    meetingTime: number
    department: string
    createrId: number
    membersCount: number
    isOnline: boolean
    attId?: number | null
    meetEndTime: Date | string
    membersList?: MembersListUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutMembersAttendedInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutMembersAttendedInput, MeetingUncheckedCreateWithoutMembersAttendedInput>
  }

  export type DigitalSignatureFileUpsertWithoutAttendanceInput = {
    update: XOR<DigitalSignatureFileUpdateWithoutAttendanceInput, DigitalSignatureFileUncheckedUpdateWithoutAttendanceInput>
    create: XOR<DigitalSignatureFileCreateWithoutAttendanceInput, DigitalSignatureFileUncheckedCreateWithoutAttendanceInput>
  }

  export type DigitalSignatureFileUpdateWithoutAttendanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type DigitalSignatureFileUncheckedUpdateWithoutAttendanceInput = {
    fileId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUpsertWithoutMembersAttendedInput = {
    update: XOR<MeetingUpdateWithoutMembersAttendedInput, MeetingUncheckedUpdateWithoutMembersAttendedInput>
    create: XOR<MeetingCreateWithoutMembersAttendedInput, MeetingUncheckedCreateWithoutMembersAttendedInput>
  }

  export type MeetingUpdateWithoutMembersAttendedInput = {
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    membersList?: MembersListUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutMembersAttendedInput = {
    meetingId?: IntFieldUpdateOperationsInput | number
    meetCreater?: StringFieldUpdateOperationsInput | string
    meetDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    meetTitle?: StringFieldUpdateOperationsInput | string
    meetingTime?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    createrId?: IntFieldUpdateOperationsInput | number
    membersCount?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    attId?: NullableIntFieldUpdateOperationsInput | number | null
    meetEndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    membersList?: MembersListUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MembersAttendedCreateWithoutDigitalSignatureFileInput = {
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    meeting: MeetingCreateNestedOneWithoutMembersAttendedInput
  }

  export type MembersAttendedUncheckedCreateWithoutDigitalSignatureFileInput = {
    id?: number
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    meetingId: number
  }

  export type MembersAttendedCreateOrConnectWithoutDigitalSignatureFileInput = {
    where: MembersAttendedWhereUniqueInput
    create: XOR<MembersAttendedCreateWithoutDigitalSignatureFileInput, MembersAttendedUncheckedCreateWithoutDigitalSignatureFileInput>
  }

  export type MembersAttendedUpsertWithoutDigitalSignatureFileInput = {
    update: XOR<MembersAttendedUpdateWithoutDigitalSignatureFileInput, MembersAttendedUncheckedUpdateWithoutDigitalSignatureFileInput>
    create: XOR<MembersAttendedCreateWithoutDigitalSignatureFileInput, MembersAttendedUncheckedCreateWithoutDigitalSignatureFileInput>
  }

  export type MembersAttendedUpdateWithoutDigitalSignatureFileInput = {
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meeting?: MeetingUpdateOneRequiredWithoutMembersAttendedNestedInput
  }

  export type MembersAttendedUncheckedUpdateWithoutDigitalSignatureFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingId?: IntFieldUpdateOperationsInput | number
  }

  export type MemberCreateManyUserInput = {
    groupId: number
  }

  export type MessageCreateManyCreatedByInput = {
    id?: number
    title?: string
    content: string
    timer: number
    createdAt?: Date | string
  }

  export type ReadCreateManyUserInput = {
    id?: number
    messageId: number
    groupId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
  }

  export type FeedbackCreateManyCreatedByInput = {
    id?: number
    location: string
    organizationName: string
    date: string
    time: string
    feedback: string
    source: string
    color: $Enums.FeedbackColor
    selectedValues: string
    description: string
    reportedBy: string
    responsiblePerson?: string | null
    actionTaken?: string | null
    status?: $Enums.Status | null
    userAcknowledgement?: string | null
    createdAt?: Date | string
  }

  export type FeedbackAssignmentCreateManyUserInput = {
    id?: number
    assignmentCompleted: boolean
    feedbackId: number
  }

  export type UserOrientationReadCreateManyUserInput = {
    id?: number
    userOrientationId: number
    readAt?: Date | string
  }

  export type MemberUpdateWithoutUserInput = {
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type MemberUncheckedUpdateManyWithoutMemberInGroupsInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUpdateManyWithoutMessageNestedInput
    files?: FileUpdateManyWithoutMessageNestedInput
    groups?: GroupUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUncheckedUpdateManyWithoutMessageNestedInput
    files?: FileUncheckedUpdateManyWithoutMessageNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadUpdateWithoutUserInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadNestedInput
  }

  export type ReadUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadUncheckedUpdateManyWithoutReadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    messageId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutCreatedByInput = {
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUpdateManyWithoutFeedbackNestedInput
    actionFiles?: FeedbackActionFileUpdateManyWithoutFeedbackNestedInput
    feedbackAssignments?: FeedbackAssignmentUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FeedbackFileUncheckedUpdateManyWithoutFeedbackNestedInput
    actionFiles?: FeedbackActionFileUncheckedUpdateManyWithoutFeedbackNestedInput
    feedbackAssignments?: FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateManyWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    color?: EnumFeedbackColorFieldUpdateOperationsInput | $Enums.FeedbackColor
    selectedValues?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    responsiblePerson?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userAcknowledgement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackAssignmentUpdateWithoutUserInput = {
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedback?: FeedbackUpdateOneRequiredWithoutFeedbackAssignmentsNestedInput
  }

  export type FeedbackAssignmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackAssignmentUncheckedUpdateManyWithoutFeedbackAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedbackId?: IntFieldUpdateOperationsInput | number
  }

  export type UserOrientationReadUpdateWithoutUserInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userOrientation?: UserOrientationUpdateOneRequiredWithoutUserOrientationReadsNestedInput
  }

  export type UserOrientationReadUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOrientationId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationReadUncheckedUpdateManyWithoutUserOrientationReadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userOrientationId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyGroupInput = {
    userId: number
  }

  export type RiskAssessmentCreateManyGroupInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type MemberUpdateWithoutGroupInput = {
    user?: UserUpdateOneRequiredWithoutMemberInGroupsNestedInput
  }

  export type MemberUncheckedUpdateWithoutGroupInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MemberUncheckedUpdateManyWithoutMembersInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RiskAssessmentUpdateWithoutGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateManyWithoutAssessmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutGroupsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUpdateManyWithoutMessageNestedInput
    files?: FileUpdateManyWithoutMessageNestedInput
    createdBy?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timer?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: ReadUncheckedUpdateManyWithoutMessageNestedInput
    files?: FileUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ReadCreateManyMessageInput = {
    id?: number
    groupId: number
    userId: number
    reply?: string | null
    mode?: string | null
    readAt?: Date | string
  }

  export type FileCreateManyMessageInput = {
    id?: number
    name: string
    fileType: string
  }

  export type ReadUpdateWithoutMessageInput = {
    groupId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadsNestedInput
  }

  export type ReadUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadUncheckedUpdateManyWithoutReadInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateManyWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type GroupUpdateWithoutMessagesInput = {
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutGroupNestedInput
    assessments?: RiskAssessmentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutGroupNestedInput
    assessments?: RiskAssessmentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOrientationReadCreateManyUserOrientationInput = {
    id?: number
    userId: number
    readAt?: Date | string
  }

  export type UserOrientationReadUpdateWithoutUserOrientationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserOrientationReadsNestedInput
  }

  export type UserOrientationReadUncheckedUpdateWithoutUserOrientationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFileCreateManyFeedbackInput = {
    id?: number
    name: string
    fileType: string
  }

  export type FeedbackActionFileCreateManyFeedbackInput = {
    id?: number
    name: string
    fileType: string
  }

  export type FeedbackAssignmentCreateManyFeedbackInput = {
    id?: number
    assignmentCompleted: boolean
    userId: number
  }

  export type FeedbackFileUpdateWithoutFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFileUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFileUncheckedUpdateManyWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackActionFileUpdateWithoutFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackActionFileUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackActionFileUncheckedUpdateManyWithoutActionFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackAssignmentUpdateWithoutFeedbackInput = {
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutFeedbackAssignmentsNestedInput
  }

  export type FeedbackAssignmentUncheckedUpdateWithoutFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MembersListCreateManyMeetingInput = {
    id?: number
    memberId: string
    memberName: string
  }

  export type MembersAttendedCreateManyMeetingInput = {
    id?: number
    memberId: number
    membersName: string
    memberInTime: Date | string
    memberOutTime: Date | string
    dateTime: Date | string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
  }

  export type MembersListUpdateWithoutMeetingInput = {
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
  }

  export type MembersListUncheckedUpdateWithoutMeetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
  }

  export type MembersListUncheckedUpdateManyWithoutMembersListInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
  }

  export type MembersAttendedUpdateWithoutMeetingInput = {
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    digitalSignatureFile?: DigitalSignatureFileUpdateOneWithoutAttendanceNestedInput
  }

  export type MembersAttendedUncheckedUpdateWithoutMeetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    digitalSignatureFile?: DigitalSignatureFileUncheckedUpdateOneWithoutAttendanceNestedInput
  }

  export type MembersAttendedUncheckedUpdateManyWithoutMembersAttendedInput = {
    id?: IntFieldUpdateOperationsInput | number
    memberId?: IntFieldUpdateOperationsInput | number
    membersName?: StringFieldUpdateOperationsInput | string
    memberInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    memberOutTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOrientationCountOutputTypeDefaultArgs instead
     */
    export type UserOrientationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOrientationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackCountOutputTypeDefaultArgs instead
     */
    export type FeedbackCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingCountOutputTypeDefaultArgs instead
     */
    export type MeetingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDefaultArgs instead
     */
    export type MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReadDefaultArgs instead
     */
    export type ReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileDefaultArgs instead
     */
    export type FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskAssessmentDefaultArgs instead
     */
    export type RiskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtherFileDefaultArgs instead
     */
    export type OtherFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtherFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOrientationDefaultArgs instead
     */
    export type UserOrientationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOrientationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOrientationReadDefaultArgs instead
     */
    export type UserOrientationReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOrientationReadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackAssignmentDefaultArgs instead
     */
    export type FeedbackAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackFileDefaultArgs instead
     */
    export type FeedbackFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackActionFileDefaultArgs instead
     */
    export type FeedbackActionFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackActionFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingDefaultArgs instead
     */
    export type MeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembersListDefaultArgs instead
     */
    export type MembersListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembersListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembersAttendedDefaultArgs instead
     */
    export type MembersAttendedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembersAttendedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DigitalSignatureFileDefaultArgs instead
     */
    export type DigitalSignatureFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DigitalSignatureFileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormDefaultArgs instead
     */
    export type FormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}